# 一、Linux操作系统综述

## 1.一些比喻

- 软件外包公司-**操作系统**：

  操作系统其实就像一个软件外包公司，其内核就相当于这家外包公司的老板。

- 客户对接员-**输入设备驱动**：

  当客户（即输入设备）告诉对接员需求的时候，对于操作系统来讲，输入设备会发送一个中断。客户肯定希望外包公司停下手头的事来服务它。这个时候客户发送的需求就被称之为**中断事件interrupt event.**

- 交付人员-**输出设备驱动**

  作为外包公司，对客户的需求无论做或不做，做的结果如何，都要给客户一个反馈。例：显卡的显卡驱动。

- 立项-**运行软件**

  - 项目执行计划书：即已经编译的二进制执行程序，确定能做什么、怎么做、做的顺序是什么。
  - 档案管理系统-**文件管理子系统File Management Subsystem**：管理储存各个程序（他们都以二进制文件的形式保存在硬盘上）。二进制文件是静态的，称为program程序。运行起来的是动态的，称为process进程。
  - 项目管理系统-**进程管理子系统Process Management Subsystem**：进程的执行需要分配cpu来执行，即按照二进制代码一行一行的执行。该系统用于管理进程
  - 会议室管理系统-**内存管理子系统Memory Management Subsystem**：统一管理和分配不同进程所用到的内存空间。不同进程不共享内存，就像不同项目组不同时共用一个会议室

- 办事大厅-**系统调用System Call子系统**

  明文列出提供哪些服务(接口)，谁需要可以来申请，然后就会有回应。立项是办事大厅提供的关键服务之一。任何一个程序要想运行起来，就需要调用系统调用，创建进程。

- 对外合作部-**网络子系统**

  QQ 进程是不能直接发送网络包的，需要调用系统调用，内核使用网卡驱动程序进行发送。就像依靠公司的对外合作部和其他公司进行沟通合作。

### 内核源代码

https://elixir.bootlin.com/linux/latest/source

kernel 	 内核管理核心代码-进程管理子系统

mm		  内存管理代码-内存管理子系统

drivers     驱动程序代码-设备管理子系统

fs 			 文件系统代码-文件管理子系统

net 		  网络协议代码-网络管理子系统

arch		 体系结构代码，如x86、arm等

ipc 		   进程间通信子系统

init 		   Linux系统启动初始化相关代码

## 2.系统调用

在源码中，系统调用定义于：对于 64 位操作系统unistd_64.h。

- 立项服务-**创建进程**

  - 创建进程的系统调用是**fork**，分支。要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。
  - 当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。子进程需要做不同的事，就需要先判断哪个进程是子进程：

  - 对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。通过if-else判断当前是父进程时，还接着做原来应该做的事情；是子进程时，需要请求另一个系统调用**execve**来执行另一个程序
  - 系统调用**waitpid**。父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

- 内存管理

  在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。

  - 代码段（Code Segment）：对于进程的内存空间来讲，放程序代码的这部分
  - 数据段（Data Segment）：对于进程的内存空间来讲，放进程运行中产生数据的这部分
    - 其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；
    - 也有动态分配的，会较长时间保存，指明才销毁的，这部分称为堆（Heap）。
  - 2个在堆里分配内存的系统调用
    - **brk**:当分配的内存数量比较小的时候，使用 brk，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。
    - **mmap**:当分配的内存数量比较大的时候，使用 mmap，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

- 文件管理

  Linux的一个特点：一切皆文件。Linux会为每一个文件分配一个文件描述符File Descriptor.常用的系统调用：

  - **open**打开文件，**close**关闭文件
  - **creat**创建文件
  - **lseek**打开文件跳到文件的某个位置
  - **read**读文件的内容，**write**写文件的内容

- 异常/信号处理

  当项目组收到信号的时候，项目组需要决定如何处理这些异常情况。

  对于一些不严重的信号，可以忽略，该干啥干啥，但是像 SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）是不能忽略的，会执行对于该信号的默认动作。

  - **sigaction**为某一个信号提供处理函数。

- 进程间通信

  - 首先就是发个消息，不需要一段很长的数据，这种方式称为**消息队列（Message Queue）**。
    - **msgget**创建一个新的队列
    - **msgsnd**将消息发送到消息队列
    - **msgrcv**从队列中取消息
  - 当两个项目组需要交互的信息比较大的时候，可以使用**共享内存**的方式，也即两个项目组共享一个会议室（这样数据就不需要拷贝来拷贝去）。
    - **shmget**创建一个共享的内存块
    - **shmat**将共享内存映射到自己的内存空间
      - 避免同时访问一块数据：**Semaphore**机制

- 网络通信

  - **Socket**建立一个Socket.

# 二、系统初始化

## 1. X86架构

X86架构是微处理器执行的计算机语言指令集，指一个intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合。

- **计算机工作模式**

  - CPU(Central Processing Unit 中央处理器)三部分组成：

    - 运算单元：加法、位移等计算操作
    - 数据单元：CPU内部的缓存和寄存器组。空间小但速度飞快。临时储存数据和运算结果
    - 控制单元：获得指令，并执行指令。
      - 指令指针寄存器：存放下一条指令在内存中的地址。因为进程的内存虽然隔离但并不连续。
      - 指令分两部分，一部分是做什么操作，例如是加法还是位移；一部分是操作哪些数据。执行这条指令，就要把第一部分交给运算单元，第二部分交给数据单元。

  - 总线Bus: CPU 和内存来来回回传数据，靠的都是总线。

    - 地址总线（Address Bus):传输地址数据，也就是我想拿内存中哪个位置的数据
      - 地址总线的位数，决定了能访问的地址范围到底有多广。例如只有两位，那 CPU 就只能认 00，01，10，11 四个位置，超过四个位置，就区分不出来了。位数越多，能够访问的位置就越多，能管理的内存的范围也就越广。
    - 数据总线（Data Bus):传输真正的数据
      - 数据总线的位数，决定了一次能拿多少个数据进来。例如只有两位，那 CPU 一次只能从内存拿两位数。要想拿八位，就要拿四次。位数越多，一次拿的数据就越多，访问速度也就越快。
  
- **8086PC**

    IBM用英特尔的8088 CPU开始做PC，而英特尔的这一系列CPU又开端于8086，所以称为X86架构：
    
    ![](https://static001.geekbang.org/resource/image/2d/1c/2dc8237e996e699a0361a6b5ffd4871c.jpeg)
    
    - 8086处理器由8个16位通用寄存器，用于计算工程中暂存数据
    
        - AX,BX,CX,DX,SP,BP,SI,DI
        - 其中AX,BX,CX,DX可以分成2个8位寄存器来使用，如：AH,AL。H代表高位，L代表低位。
    
    - IP寄存器 即 指令指针寄存器（Instruction Pointer Register）
    
        - 指向代码段中下一条指令的位置
        - CPU会根据此来不断的将指令从内存中提取到CPU的指令队列中去
    
    - 4个16位段寄存器
    
        - CS,DS,SS,ES。用于切换进程，指向不同进程的地址空间。每个进程都有各自的代码段和数据段。
        - CS:就是代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置
        - DS 是数据段的寄存器，通过它可以找到数据在内存中的位置
          - 对于一个段，有一个起始的地址，而段内的具体位置，我们称为**偏移量（Offset）**。例如 8 号会议室的第三排，8 号会议室就是起始地址，第三排就是偏移量。
          - 寄存器都是16位的，但8086 的地址总线地址是 20 位。怎么凑够这 20 位呢？方法就是“起始地址 *16+ 偏移量”，也就是把 CS 和 DS 中的值左移 4 位，变成 20 位的，加上 16 位的偏移量，这样就可以得到最终 20 位的数据地址。
          - 无论真正的内存多么大，对于只有 20 位地址总线的 8086 来讲，能够区分出的地址也就 2^20=1M
          - 因为偏移量只能是 16 位的，所以一个段最大的大小是 2^16=64k。
    
        - SS 是栈寄存器（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则，push 就是入栈，pop 就是出栈。
          - 凡是与函数调用相关的操作，都与栈紧密相关。例如，A 调用 B，B 调用 C。当 A 调用 B 的时候，要执行 B 函数的逻辑，因而 A 运行的相关信息就会被 push 到栈里面。当 B 调用 C 的时候，同样，B 运行相关信息会被 push 到栈里面，然后才运行 C 函数的逻辑。当 C 运行完毕的时候，先 pop 出来的是 B，B 就接着调用 C 之后的指令运行下去。B 运行完了，再 pop 出来的就是 A，A 接着运行，直到结束。
    
- 32位处理器

    在 32 位处理器中，有 32 根地址总线，可以访问 2^32=4G 的内存。在开放架构X86的基础上进行扩展：

    ![](https://static001.geekbang.org/resource/image/e3/84/e3f4f64e6dfe5591b7d8ef346e8e8884.jpeg)
    - 通用寄存器：
        - 将 8 个 16 位的扩展到 8 个 32 位的，但是依然可以保留 16 位的和 8 位的使用方式。不用将高16位分成2个8位，因为没有人写程序用高位的。。。
    - 段寄存器（Segment Register）：
        - 根据当时的硬件，没有把 16 位当成一个段的起始地址而是弄了一个不上不下的 20 位的地址，每次都要左移四位。如果新的段寄存器都改成 32 位的，明明 4G 的内存全部都能访问到，还左移不左移四位呢？
        - 所以从新定义：段的起始地址放在内存的某个地方。这个地方是一个表格，表格中的一项一项是**段描述符（Segment Descriptor**）。这里面才是真正的段的起始地址。而段寄存器里面保存的是在这个表格中的哪一项，称为**选择子（Selector）**。
            - 这样，将一个从段寄存器直接拿到的段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。
        - 保护模式下为了更快的拿到段起始地址，会将内存中的段描述符拿到CPU内的高速缓存中。
            - 实模式（Real Pattern）：段的起始地址是放在寄存器里面的，所以速度就比在内存里面快很多。当系统刚刚启动的时候，CPU 是处于实模式的
            - 保护模式（Protected Pattern）： 端起始地址放到内存里面了，就慢了，怎么办呢？将内存中的段描述符拿到CPU内的高速缓存中，就又快了。

