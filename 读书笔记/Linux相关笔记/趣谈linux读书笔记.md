# 一、Linux操作系统综述

## 1.一些比喻

- 软件外包公司-**操作系统**：

  操作系统其实就像一个软件外包公司，其内核就相当于这家外包公司的老板。

- 客户对接员-**输入设备驱动**：

  当客户（即输入设备）告诉对接员需求的时候，对于操作系统来讲，输入设备会发送一个中断。客户肯定希望外包公司停下手头的事来服务它。这个时候客户发送的需求就被称之为**中断事件interrupt event.**

- 交付人员-**输出设备驱动**

  作为外包公司，对客户的需求无论做或不做，做的结果如何，都要给客户一个反馈。例：显卡的显卡驱动。

- 立项-**运行软件**

  - 项目执行计划书：即已经编译的二进制执行程序，确定能做什么、怎么做、做的顺序是什么。
  - 档案管理系统-**文件管理子系统File Management Subsystem**：管理储存各个程序（他们都以二进制文件的形式保存在硬盘上）。二进制文件是静态的，称为program程序。运行起来的是动态的，称为process进程。
  - 项目管理系统-**进程管理子系统Process Management Subsystem**：进程的执行需要分配cpu来执行，即按照二进制代码一行一行的执行。该系统用于管理进程
  - 会议室管理系统-**内存管理子系统Memory Management Subsystem**：统一管理和分配不同进程所用到的内存空间。不同进程不共享内存，就像不同项目组不同时共用一个会议室

- 办事大厅-**系统调用System Call子系统**

  明文列出提供哪些服务(接口)，谁需要可以来申请，然后就会有回应。立项是办事大厅提供的关键服务之一。任何一个程序要想运行起来，就需要调用系统调用，创建进程。

- 对外合作部-**网络子系统**

  QQ 进程是不能直接发送网络包的，需要调用系统调用，内核使用网卡驱动程序进行发送。就像依靠公司的对外合作部和其他公司进行沟通合作。

### 内核源代码

https://elixir.bootlin.com/linux/latest/source

kernel 	 内核管理核心代码-进程管理子系统

mm		  内存管理代码-内存管理子系统

drivers     驱动程序代码-设备管理子系统

fs 			 文件系统代码-文件管理子系统

net 		  网络协议代码-网络管理子系统

arch		 体系结构代码，如x86、arm等

ipc 		   进程间通信子系统

init 		   Linux系统启动初始化相关代码

## 2.系统调用

在源码中，系统调用定义于：对于 64 位操作系统unistd_64.h。

- 立项服务-**创建进程**

  - 创建进程的系统调用是**fork**，分支。要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。
  - 当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。子进程需要做不同的事，就需要先判断哪个进程是子进程：

  - 对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。通过if-else判断当前是父进程时，还接着做原来应该做的事情；是子进程时，需要请求另一个系统调用**execve**来执行另一个程序
  - 系统调用**waitpid**。父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

- 内存管理

  在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。

  - 代码段（Code Segment）：对于进程的内存空间来讲，放程序代码的这部分
  - 数据段（Data Segment）：对于进程的内存空间来讲，放进程运行中产生数据的这部分
    - 其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；
    - 也有动态分配的，会较长时间保存，指明才销毁的，这部分称为堆（Heap）。
  - 2个在堆里分配内存的系统调用
    - **brk**:当分配的内存数量比较小的时候，使用 brk，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。
    - **mmap**:当分配的内存数量比较大的时候，使用 mmap，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

- 文件管理

  Linux的一个特点：一切皆文件。Linux会为每一个文件分配一个文件描述符File Descriptor.常用的系统调用：

  - **open**打开文件，**close**关闭文件
  - **creat**创建文件
  - **lseek**打开文件跳到文件的某个位置
  - **read**读文件的内容，**write**写文件的内容

- 异常/信号处理

  当项目组收到信号的时候，项目组需要决定如何处理这些异常情况。

  对于一些不严重的信号，可以忽略，该干啥干啥，但是像 SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）是不能忽略的，会执行对于该信号的默认动作。

  - **sigaction**为某一个信号提供处理函数。

- 进程间通信

  - 首先就是发个消息，不需要一段很长的数据，这种方式称为**消息队列（Message Queue）**。
    - **msgget**创建一个新的队列
    - **msgsnd**将消息发送到消息队列
    - **msgrcv**从队列中取消息
  - 当两个项目组需要交互的信息比较大的时候，可以使用**共享内存**的方式，也即两个项目组共享一个会议室（这样数据就不需要拷贝来拷贝去）。
    - **shmget**创建一个共享的内存块
    - **shmat**将共享内存映射到自己的内存空间
      - 避免同时访问一块数据：**Semaphore**机制

- 网络通信

  - **Socket**建立一个Socket.
