# 一、Linux操作系统综述

## 1.一些比喻

- 软件外包公司-**操作系统**：

  操作系统其实就像一个软件外包公司，其内核就相当于这家外包公司的老板。

- 客户对接员-**输入设备驱动**：

  当客户（即输入设备）告诉对接员需求的时候，对于操作系统来讲，输入设备会发送一个中断。客户肯定希望外包公司停下手头的事来服务它。这个时候客户发送的需求就被称之为**中断事件interrupt event.**

- 交付人员-**输出设备驱动**

  作为外包公司，对客户的需求无论做或不做，做的结果如何，都要给客户一个反馈。例：显卡的显卡驱动。

- 立项-**运行软件**

  - 项目执行计划书：即已经编译的二进制执行程序，确定能做什么、怎么做、做的顺序是什么。
  - 档案管理系统-**文件管理子系统File Management Subsystem**：管理储存各个程序（他们都以二进制文件的形式保存在硬盘上）。二进制文件是静态的，称为program程序。运行起来的是动态的，称为process进程。
  - 项目管理系统-**进程管理子系统Process Management Subsystem**：进程的执行需要分配cpu来执行，即按照二进制代码一行一行的执行。该系统用于管理进程
  - 会议室管理系统-**内存管理子系统Memory Management Subsystem**：统一管理和分配不同进程所用到的内存空间。不同进程不共享内存，就像不同项目组不同时共用一个会议室

- 办事大厅-**系统调用System Call子系统**

  明文列出提供哪些服务(接口)，谁需要可以来申请，然后就会有回应。立项是办事大厅提供的关键服务之一。任何一个程序要想运行起来，就需要调用系统调用，创建进程。

- 对外合作部-**网络子系统**

  QQ 进程是不能直接发送网络包的，需要调用系统调用，内核使用网卡驱动程序进行发送。就像依靠公司的对外合作部和其他公司进行沟通合作。

### 内核源代码

https://elixir.bootlin.com/linux/latest/source

| 文件夹名字    | 内容                                                         |
| ------------- | ------------------------------------------------------------ |
| arch          | 架构相关，存放了许多cpu架构，比如arm,x86,MIPS,PPC            |
| block         | block表示块设备，以块(多个字节组成的整体)为单位来整体访问。比如sd卡、硬盘等都是块设备，可认为块设备就是存储设备。block目录下村粗着linux存储体系中关于块设备管理的代码。 |
| certs         | 与证书相关                                                   |
| crypto        | 加密。存放了一些常见的加密算法的C语言实现。比如crc32,md5,sha1。 |
| Documentation | 说明文档，对每个目录的具体作用进行说明                       |
| drivers       | 内核中所有设备的驱动程序，其中的每一个子目录对应一种设备驱动 |
| fs            | fs就是file system，文件系统，里面列出了linux支持的各种文件系统的实现。 |
| include       | 头文件目录，公共的（各种CPU架构共用的）头文件都在这里。每种CPU架构特有的一些头文件在arch/arm/include目录及其子目录下。 |
| init          | init是初始化的意思，这个目录下的代码就是linux内核启动时初始化内核的代码。 |
| ipc           | inter process commuication，进程间通信，里面都是linux支持的IPC的代码实现。 |
| kernel        | linux内核，所以这个文件夹下放的就是内核本身需要的一些代码文件。与处理器架构相关的内核代码在/kernel/$ARCH/kernel。 |
| lib           | 库。内核共用的函数库，与处理器架构相关的库在 /kernel/$ARCH/lib |
| mm            | 内存管理代码，譬如页式存储管理内存的分配和释放等。与具体处理器架构相关的内存管理代码位于/arch/$ARCH/mm目录下。 |
| net           | 网络相关的代码，譬如TCP/IP协议栈等都在这里。                 |
| samples       | 示例代码。                                                   |
| scripts       | 脚本，这个目录下全部是脚本文件.不是linux内核工作时使用的，而是用来辅助对linux内核进行配置编译生产的。用于实现内核配置的图形界面 |
| sound         | 与音频有关的代码，包括与音频有关的驱动程序                   |
| security      | 安全性相关的代码                                             |
| tools         | Linux中的常用工具                                            |
| usr           | 为内核尚未完全启动时执行用户空间代码提供了支持               |
| virt          | 此文件夹包含了虚拟化代码，它允许用户一次运行多个操作系统     |
| Kbuild        | Kbuild是kernel build的意思，就是内核编译的意思。这个文件就是linux内核特有的内核编译体系需要用到的文件。 |
| Kconfig       | 配置哪些文件编译，那些文件不用编译                           |
| CREDITS       | 贡献者列表                                                   |



## 2.系统调用

在源码中，系统调用定义于：对于 64 位操作系统unistd_64.h。

- 立项服务-**创建进程**

  - 创建进程的系统调用是**fork**，分支。要创建一个新的进程，需要一个老的进程调用 fork 来实现，其中老的进程叫作父进程（Parent Process），新的进程叫作子进程（Child Process）。
  - 当父进程调用 fork 创建进程的时候，子进程将各个子系统为父进程创建的数据结构也全部拷贝了一份，甚至连程序代码也是拷贝过来的。子进程需要做不同的事，就需要先判断哪个进程是子进程：

  - 对于 fork 系统调用的返回值，如果当前进程是子进程，就返回 0；如果当前进程是父进程，就返回子进程的进程号。通过if-else判断当前是父进程时，还接着做原来应该做的事情；是子进程时，需要请求另一个系统调用**execve**来执行另一个程序
  - 系统调用**waitpid**。父进程可以调用它，将子进程的进程号作为参数传给它，这样父进程就知道子进程运行完了没有，成功与否。

- 内存管理

  在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间。

  - 代码段（Code Segment）：对于进程的内存空间来讲，放程序代码的这部分
  - 数据段（Data Segment）：对于进程的内存空间来讲，放进程运行中产生数据的这部分
    - 其中局部变量的部分，在当前函数执行的时候起作用，当进入另一个函数时，这个变量就释放了；
    - 也有动态分配的，会较长时间保存，指明才销毁的，这部分称为堆（Heap）。
  - 2个在堆里分配内存的系统调用
    - **brk**:当分配的内存数量比较小的时候，使用 brk，会和原来的堆的数据连在一起，这就像多分配两三个工位，在原来的区域旁边搬两把椅子就行了。
    - **mmap**:当分配的内存数量比较大的时候，使用 mmap，会重新划分一块区域，也就是说，当办公空间需要太多的时候，索性来个一整块。

- 文件管理

  Linux的一个特点：一切皆文件。Linux会为每一个文件分配一个文件描述符File Descriptor.常用的系统调用：

  - **open**打开文件，**close**关闭文件
  - **creat**创建文件
  - **lseek**打开文件跳到文件的某个位置
  - **read**读文件的内容，**write**写文件的内容

- 异常/信号处理

  当项目组收到信号的时候，项目组需要决定如何处理这些异常情况。

  对于一些不严重的信号，可以忽略，该干啥干啥，但是像 SIGKILL（用于终止一个进程的信号）和 SIGSTOP（用于中止一个进程的信号）是不能忽略的，会执行对于该信号的默认动作。

  - **sigaction**为某一个信号提供处理函数。

- 进程间通信

  - 首先就是发个消息，不需要一段很长的数据，这种方式称为**消息队列（Message Queue）**。
    - **msgget**创建一个新的队列
    - **msgsnd**将消息发送到消息队列
    - **msgrcv**从队列中取消息
  - 当两个项目组需要交互的信息比较大的时候，可以使用**共享内存**的方式，也即两个项目组共享一个会议室（这样数据就不需要拷贝来拷贝去）。
    - **shmget**创建一个共享的内存块
    - **shmat**将共享内存映射到自己的内存空间
      - 避免同时访问一块数据：**Semaphore**机制

- 网络通信

  - **Socket**建立一个Socket.

# 二、系统初始化

## 1. X86架构

X86架构是微处理器执行的计算机语言指令集，指一个intel通用计算机系列的标准编号缩写，也标识一套通用的计算机指令集合。

- **计算机工作模式**

  - CPU(Central Processing Unit 中央处理器)三部分组成：

    - 运算单元：加法、位移等计算操作
    - 数据单元：CPU内部的缓存和寄存器组。空间小但速度飞快。临时储存数据和运算结果
    - 控制单元：获得指令，并执行指令。
      - 指令指针寄存器：存放下一条指令在内存中的地址。因为进程的内存虽然隔离但并不连续。
      - 指令分两部分，一部分是做什么操作，例如是加法还是位移；一部分是操作哪些数据。执行这条指令，就要把第一部分交给运算单元，第二部分交给数据单元。

  - 总线Bus: CPU 和内存来来回回传数据，靠的都是总线。

    - 地址总线（Address Bus):传输地址数据，也就是我想拿内存中哪个位置的数据
      - 地址总线的位数，决定了能访问的地址范围到底有多广。例如只有两位，那 CPU 就只能认 00，01，10，11 四个位置，超过四个位置，就区分不出来了。位数越多，能够访问的位置就越多，能管理的内存的范围也就越广。
    - 数据总线（Data Bus):传输真正的数据
      - 数据总线的位数，决定了一次能拿多少个数据进来。例如只有两位，那 CPU 一次只能从内存拿两位数。要想拿八位，就要拿四次。位数越多，一次拿的数据就越多，访问速度也就越快。
  
- **8086PC**

    IBM用英特尔的8088 CPU开始做PC，而英特尔的这一系列CPU又开端于8086，所以称为X86架构：
    
    ![](https://static001.geekbang.org/resource/image/2d/1c/2dc8237e996e699a0361a6b5ffd4871c.jpeg)
    
    - 8086处理器由8个16位通用寄存器，用于计算工程中暂存数据
    
        - AX,BX,CX,DX,SP,BP,SI,DI
        - 其中AX,BX,CX,DX可以分成2个8位寄存器来使用，如：AH,AL。H代表高位，L代表低位。
    
    - **IP**寄存器 即 指令指针寄存器（Instruction Pointer Register）
        - 指向代码段中下一条指令的位置
        - CPU会根据此来不断的将指令从内存中提取到CPU的指令队列中去
        
    - 4个16位段寄存器
        - CS,DS,SS,ES。用于切换进程，指向不同进程的地址空间。每个进程都有各自的代码段和数据段。
        - **CS**:就是代码段寄存器（Code Segment Register），通过它可以找到代码在内存中的位置
        - DS 是数据段的寄存器，通过它可以找到数据在内存中的位置
          - 对于一个段，有一个起始的地址，而段内的具体位置，我们称为**偏移量（Offset）**。例如 8 号会议室的第三排，8 号会议室就是起始地址，第三排就是偏移量。
          - 寄存器都是16位的，但8086 的地址总线地址是 20 位。怎么凑够这 20 位呢？方法就是“起始地址 *16+ 偏移量”，也就是把 CS 和 DS 中的值左移 4 位，变成 20 位的，加上 16 位的偏移量，这样就可以得到最终 20 位的数据地址。
          - 无论真正的内存多么大，对于只有 20 位地址总线的 8086 来讲，能够区分出的地址也就 2^20=1M
          - 因为偏移量只能是 16 位的，所以一个段最大的大小是 2^16=64k。
        
        - SS 是栈寄存器（Stack Register）。栈是程序运行中一个特殊的数据结构，数据的存取只能从一端进行，秉承后进先出的原则，push 就是入栈，pop 就是出栈。
          - 凡是与函数调用相关的操作，都与栈紧密相关。例如，A 调用 B，B 调用 C。当 A 调用 B 的时候，要执行 B 函数的逻辑，因而 A 运行的相关信息就会被 push 到栈里面。当 B 调用 C 的时候，同样，B 运行相关信息会被 push 到栈里面，然后才运行 C 函数的逻辑。当 C 运行完毕的时候，先 pop 出来的是 B，B 就接着调用 C 之后的指令运行下去。B 运行完了，再 pop 出来的就是 A，A 接着运行，直到结束。
    
- 32位处理器

    在 32 位处理器中，有 32 根地址总线，可以访问 2^32=4G 的内存。在开放架构X86的基础上进行扩展：

    ![](https://static001.geekbang.org/resource/image/e3/84/e3f4f64e6dfe5591b7d8ef346e8e8884.jpeg)
    - 通用寄存器：
        - 将 8 个 16 位的扩展到 8 个 32 位的，但是依然可以保留 16 位的和 8 位的使用方式。不用将高16位分成2个8位，因为没有人写程序用高位的。。。
    - 段寄存器（Segment Register）：
        - 根据当时的硬件，没有把 16 位当成一个段的起始地址而是弄了一个不上不下的 20 位的地址，每次都要左移四位。如果新的段寄存器都改成 32 位的，明明 4G 的内存全部都能访问到，还左移不左移四位呢？
        - 所以从新定义：段的起始地址放在内存的某个地方。这个地方是一个表格，表格中的一项一项是**段描述符（Segment Descriptor**）。这里面才是真正的段的起始地址。而段寄存器里面保存的是在这个表格中的哪一项，称为**选择子（Selector）**。
            - 这样，将一个从段寄存器直接拿到的段起始地址，就变成了先间接地从段寄存器找到表格中的一项，再从表格中的一项中拿到段起始地址。
        - 保护模式下为了更快的拿到段起始地址，会将内存中的段描述符拿到CPU内的高速缓存中。
            - 实模式（Real Pattern）：段的起始地址是放在寄存器里面的，所以速度就比在内存里面快很多。当系统刚刚启动的时候，CPU 是处于实模式的
            - 保护模式（Protected Pattern）： 端起始地址放到内存里面了，就慢了，怎么办呢？将内存中的段描述符拿到CPU内的高速缓存中，就又快了。

## 2. 从BIOS到boot loader

- **BIOS**（Basic Input and Output System，基本输入输出系统）

  - 存储于ROM（Read Only Memory，只读存储器），区别于内存RAM（Random Access Memory，随机存取存储器）。是一个初始化程序。

    - 在 x86 系统中，将 1M 空间最上面的 0xF0000 到 0xFFFFF 这 64K 映射给 ROM，也就是说，到这部分地址访问的时候，会访问 ROM。

      ![](https://static001.geekbang.org/resource/image/5f/fc/5f364ef5c9d1a3b1d9bb7153bd166bfc.jpeg)

    - 当电脑刚加电的时候，会做一些重置的工作，将 CS (代码段寄存器Code Segment Register)设置为 0xFFFF，将 IP(指令指针寄存器Instruction Pointer Register)设置为 0x0000，所以第一条指令就会指向 0xFFFF0，正是在 ROM 的范围内。在这里，有一个 JMP 命令会跳到 ROM 中做初始化工作的代码，于是，BIOS 开始进行初始化的工作。

  - BIOS做3件事：

    1. 首先要检查下系统的各个硬件是不是都好着。
    2. 并建立一个中断向量表和中断服务程序，提供基本输入(中断)输出(显存映射)服务。
    3. 加载MBR**主引导记录**（Master Boot Record）到内存(0x7c00)
       - MBR又叫主引导扇区是计算机开机后访问硬盘时所必须要读取的首个扇区

- boot loader引导进程，位于电脑或其他计算机应用上，是指引导操作系统启动的进程。

  - 操作系统安装在硬盘上，在 BIOS 的界面上，可以看到一个启动盘的选项。
    - 启动盘一般在第一个扇区，占 512 字节，而且以 0xAA55 结束。这是一个约定，当满足这个条件的时候，就说明这是一个启动盘，在 512 字节以内会启动相关的代码。
  - 在 Linux 里有一个工具 Grub2(Grand Unified Bootloader Version 2),搞系统启动的
    - `grub2-mkconfig -o /boot/grub2/grub.cfg`配置系统启动的选项
    - `grub2-install /dev/sda`可以将启动程序安装到相应的位置。
  - MBR: 启动盘第一个扇区(512B, 由 Grub2 写入 boot.img 镜像)
    - boot.img 加载 Grub2 的 core.img 镜像
    - core.img 包括 diskroot.img, lzma_decompress.img, kernel.img 以及其他模块
    - boot.img 先加载运行 diskroot.img, 再由 diskroot.img 加载 core.img 的其他内容
    -  diskroot.img 解压运行 lzma_compress.img, 由lzma_compress.img 切换到保护模式

- 从实模式切换到保护模式需要做3件事

  1. **启用分段**，就是在内存里面建立段描述符表，将寄存器里面的段寄存器变成段选择子，指向某个段描述符，这样就能实现不同进程的切换了。辅助进程管理

  2. 启动分页。能够管理的内存变大了，就需要将内存分成相等大小的块。辅助内存管理

  3. 打开 Gate A20，也就是第 21 根地址线的控制线。

     - 在实模式 8086 下面，一共就 20 个地址线，只可访问 1M 的地址空间。

     - 打开了门后，就可以访问更宽的地址了

- zma_compress.img 解压运行 grub 内核 kernel.img, kernel.img 做以下四件事:

  1. 解析 grub.conf 文件

  2. 选择操作系统
  3. 例如选择 linux16, 会先读取内核头部数据进行检查, 检查通过后加载完整系统内核
  4. 启动系统内核

## 3. 内核初始化

从实模式切换到保护模式后，有了更强的寻址能力，就要开始启动内核了

- 内核的启动从入口函数 start_kernel() 开始。

  在 init/main.c 文件中，start_kernel 相当于内核的 main 函数。里面是各种各样初始化函数 XXXX_init。

  ![](https://static001.geekbang.org/resource/image/cd/01/cdfc33db2fe1e07b6acf8faa3959cb01.jpeg)

1. 首先初始化项目管理部门

   `set_task_stack_end_magic(&init_task)`创建**0号进程**

   - 参数`init_task`定义是`struct task_struct init_task = INIT_TASK(init_task)`
   - 它是系统创建的第一个进程，称为 **0 号进程**。这是唯一一个没有通过 fork 或者 kernel_thread 产生的进程，是**进程列表**的第一个。
   - 进程列表（Process List），就是咱们前面说的项目管理工具，里面列着我们所有接的项目。

2. 接着初始化办事大厅

   `tarp_init()`设置了很多中断门（Interrupt Gate），用于处理各种中断。

   - `set_system_intr_gate(IA32_SYSCALL_VECTOR, entry_INT80_32)`系统调用的中断门。系统调用也是通过发送中断的方式进行的

3. 初始化会议室管理系统

   `mm_init()`初始化内存管理模块。

4. 初始化项目管理调度

   `sched_init()`初始化调度模块

5. 文件系统初始化

   - `vfs_caches_init()`初始化基于内存的文件系统 rootfs

     - 这个函数里面，会调用 mnt_init()->init_rootfs() 这里有一行代码：`register_filesystem(&rootfs_fs_type)`。rootfs_fs_type是在 VFS 虚拟文件系统里面注册的一种类型，`struct file_system_type rootfs_fs_type。`
     - VFS（Virtual File System），虚拟文件系统。
       - 文件系统是我们的项目资料库，为了兼容各种各样的文件系统，我们需要将文件的相关数据结构和操作抽象出来，形成一个抽象层对上提供统一的接口。这个抽象层就是vfs

6. 最后start_kernel做其他初始化

   `rest_init()`做了很多初始化的工作

   1. 初始化 1 号进程（用户态所有进程的祖先）

      - 用 `kernel_thread(kernel_init, NULL, CLONE_FS)` 创建第二个进程，这个是 1 号进程

        - 有了其他进程后，就要区分哪些是核心资源，哪些是核心人员才能访问的核心保密区

        - x86提供了分层的权限机制，把区域分成了4个ring，越往里权限越高

          ![](https://static001.geekbang.org/resource/image/2b/42/2b53b470673cde8f9d8e2573f7d07242.jpg)

          - **内核态（Kernel Mode）**

            - 能够访问关键资源的代码放在 Ring0

          - **用户态（User Mode）**

            - 普通的程序代码放在 Ring3

            - 如果用户态的代码想要访问核心资源，就要通过系统调用。用户态代码不用管后面发生了什么，系统调用背后是内核态。

            - 当用户态程序运行到一半访问一个核心资源时，当前运行会停止并调用系统调用。暂停时，用户态程序运行代码到哪一行，当前的栈在哪里，这些信息都存在寄存器里。

                 ![](https://static001.geekbang.org/resource/image/71/e6/71b04097edb2d47f01ab5585fd2ea4e6.jpeg)

            - 调用过程：用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态，然后接着运行。

   2. 从内核态到用户态

      - 在1号进程启动的时候，还处在内核态，现在要转到用户态去运行一个程序。

        `kernel_thread`的参数是一个函数`kernel_init`，即1号进程会运行这个函数。这个函数会调用`kernel_init_freeable()`。里面有一代码：

        ```c
        if (!ramdisk_execute_command)
            ramdisk_execute_command = "/init";
        ```

        ramdisk在第3步，进入用户态后启用。

        - 1号进程`run_init_process()`函数会调用`do_execve`

          - execve 是一个系统调用，它的作用是运行一个执行文件。加一个 do_ 的往往是内核系统调用的实现。
          - 它会尝试运行 ramdisk 的“/init”，或者普通文件系统上的“/sbin/init”“/etc/init”“/bin/init”“/bin/sh”。不同版本的 Linux 会选择不同的文件启动，但是只要有一个起来了就可以。
          -  从内核态执行系统调用开始：do_execve->do_execveat_common->exec_binprm->search_binary_handler
            - 运行一个程序，在这里会加载一个二进制文件，linux下通常为ELF（Executable and Linkable Format，可执行与可链接格式）

        - 最后调用`start_thread`

          ```c
          
          void
          start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp){
          	set_user_gs(regs, 0);
          	regs->fs  = 0;
          	regs->ds  = __USER_DS;
          	regs->es  = __USER_DS;
          	regs->ss  = __USER_DS;
          	regs->cs  = __USER_CS;
          	regs->ip  = new_ip;
          	regs->sp  = new_sp;
          	regs->flags  = X86_EFLAGS_IF;
          	force_iret();
          }
          EXPORT_SYMBOL_GPL(start_thread);
          ```

          - `struct pt_regs`即寄存器，系统调用时在内核中保存用户态运行上下文

          - 用户态的代码段CS设置为`_USER_CS`

          - 用户态的数据段DS设置为`_USER_DS`

          - 指针寄存器IP

          - 栈指针寄存器SP

          - force_iret()：用于从系统调用中返回，恢复寄存器。

      - 到达用户态后：ramdisk的作用

        - 一开始到用户态的是 ramdisk 的 init，后来会启动真正根文件系统上的 init，成为所有用户态进程的祖先。
      
        - ramdisk是解决init程序的存储问题，在内核启动过程中需要init文件，如果从文件系统直接获取那么我们必须有各种磁盘的驱动才能从磁盘之上的文件系统读取到我们需要的文件，这样内核就复杂化啦，而采用ramdisk就是弱化磁盘驱动依赖，采用内存保存，这样就能直接启动。
        - 一开始运行 ramdisk 上的 /init。等它运行完了就已经在用户态了。/init 这个程序会先根据存储系统的类型加载驱动，有了驱动就可以设置真正的根文件系统了。有了真正的根文件系统，ramdisk 上的 /init 会启动文件系统上的 init。
        - 接下来就是各种系统的初始化。启动系统的服务，启动控制台，用户就可以登录进来了

   3. 创建2号进程（内核态所有线程运行的祖先）
   
      用户态的所有进程都有大师兄1号进程了。内核态的进程也需要一个进程统一管理：2号进程。
   
      - `kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES)`创建2号进程
        - 函数`kthreadd`负责所有内核态的线程的调度和管理，是内核态所有线程运行的祖先。
        - 为什么创建进程的函数名字叫kernel_thread()线程呢？因为从内核态来看，无论是进程，还是线程，我们都可以统称为任务（Task），都使用相同的数据结构，平放在同一个链表中。

