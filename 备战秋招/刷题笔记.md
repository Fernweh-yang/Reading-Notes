# 一、数组

## 1.理论基础

- 数组是存放在连续内存空间上的相同类型数据的集合
  - 数组下标都是从0开始的。
  - 数组内存空间的地址是连续的
  - 数组的元素是不能删的，只能覆盖！
    - 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）
  
- 二分法：
  - **循环不变量原则**，只有在循环中坚持对区间的定义
  
- 双指针法：
  - 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作
  
- 滑动窗口
  - 滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。
  
- 总结图：

  <img src="https://github.com/Fernweh-yang/Reading-Notes/blob/main/%E7%AC%94%E8%AE%B0%E9%85%8D%E5%A5%97%E5%9B%BE%E7%89%87/Algorithm/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png?raw=true"  />

## 2.二分查找

### 2.1 题目：704 Binary Search

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 `nums` 中的所有元素是不重复的。

示例

```
示例1：
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例2：
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

### 2.2 暴力搜索

#### 2.2.1 C++

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        for(vector<int>::iterator iter = nums.begin(); iter!=nums.end(); iter++){
            # 读取迭代器的值，用指针
            if(*iter==target)
                # 返回迭代器的下标
                return distance(nums.begin(),iter);
        }
        return -1;
    }
};
```

#### 2.2.2 python

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        for i in nums:
            if i == target:
                return nums.index(i)
        return -1
```

### 2.2 解题：二分法

- **这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，这些都是使用二分法的前提条件。

- **循环不变量规则**：**区间的定义是不变量**，在while寻找中每一次边界的处理都要坚持根据区间的定义来操作。二分法，区间的定义一般为两种：

  1. 左闭右闭即[left, right]
  2. 左闭右开即[left, right)

- 第一种解法：左闭右闭[left, right]

  区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

  - while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
  - if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int left = 0;
          int right = nums.size()-1;	//2种写法的区别
          int middle
          while(left <= right){
              middle = left + ((right - left) / 2);
              if(nums[middle]>target){
                  right = middle - 1;	//2种写法的区别
              }
              else if(nums[middle]<target){
                  left = middle + 1;
              }
              else
                  return middle;
          }
          return -1;
  
      }
  };
  ```
  ```python
  class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)-1
        while left <= right:
            middle = int(left + (right - right)/2)
            if nums[middle] == target:
                return middle
            elif nums[middle] < target:
                left = middle+1
            else:
                right = middle -1
        return -1 
  ```

- 第二种解法：左闭右开[left, right)

  有如下两点：

  - while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的，即right代表的那个数是不考虑在内的。
  - if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int left = 0;
          int right = nums.size(); 	//2种写法的区别
          int middle
          while(left < right){
              middle = left + ((right - left) / 2);
              if(nums[middle]>target){
                  right = middle ;	//2种写法的区别
              }
              else if(nums[middle]<target){
                  left = middle + 1;
              }
              else
                  return middle;
          }
          return -1;
  
      }
  };
  ```
  ```python
  class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            middle = int(left + (right - right)/2)
            if nums[middle] == target:
                return middle
            elif nums[middle] < target:
                left = middle+1
            else:
                right = middle 
        return -1 
  ```

### 2.3 相似题：

- 35.搜索插入位置-Search Insert Position
- 34.在排序数组中查找元素的第一个和最后一个位置-Find First and Last Position of Element in Sorted Array
- 69.x 的平方根-Sqrt(x)
- 367.有效的完全平方数-Valid Perfect Square

## 3.移除元素

### 3.1 题目：27 Remove Element

给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

- 说明：

  为什么返回数值是整数，但输出的答案是数组呢?

  请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

  你可以想象内部操作如下:

  ```
  // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
  int len = removeElement(nums, val);
  
  // 在函数里修改输入数组对于调用者是可见的。
  // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
  for (int i = 0; i < len; i++) {
      print(nums[i]);
  }
  ```

- 示例

  ```
  输入：nums = [3,2,2,3], val = 3
  输出：2, nums = [2,2]
  解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
  
  输入：nums = [0,1,2,2,3,0,4,2], val = 2
  输出：5, nums = [0,1,4,0,3]
  解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
  ```

### 3.2 解题：双指针

- 第一种解法：暴力解法

  用两层for循环，第一层便利数组元素，第二层更新数组

  时间复杂度O(n^2)

- 第二种解法：双指针法（快慢指针）

  **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

  - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
  - 慢指针：指向更新新数组下标的位置(即目标元素的位置)

  ```c++
  class Solution {
  public:
      int removeElement(vector<int>& nums, int val) {
          int slowIndex=0;
          for(int fastIndex=0;fastIndex<nums.size();fastIndex++){
              if(nums[fastIndex]!=val){
                  nums[slowIndex++]=nums[fastIndex];
              }
          }
          return slowIndex;
      }
  };
  ```
  ```python
  class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast = 0
        slow = 0
        while fast < len(nums):
            if nums[fast]!= val:
                nums[slow] = nums[fast]
                slow +=1
            fast +=1
        return slow 
  ```
- 第三种解法:双指针(两端向中间)
  - 左指针：找要删除的值
  - 右指针：找不删除的值，然后两者交换
  ```c++
  class Solution {
  public:
      int removeElement(vector<int>& nums, int val) {
          int left =0;
          int right = nums.size()-1;
          while(left<=right){
              if(nums[right]==val)
                  right--;
              else{
                  if(nums[left]==val){
                      nums[left] = nums[right];
                      left++;
                      right--;
                  }else{
                      left++;
                  }
              }
          }
          return left;
      }
  };
  ```
  ```python
  class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        left = 0
        right = len(nums)-1
        while left <= right:
            if nums[right] == val:
                right = right -1
            elif nums[left] == val:
                nums[left] = nums[right]
                left = left + 1
                right = right -1
            else:
                left = left + 1
        return left
            
  ```

### 3.3 相似题：

- 26.删除排序数组中的重复项
- 283.移动零
- 844.比较含退格的字符串
- 977.有序数组的平方



## 4.有序数组的平方

### 4.1 题目：977 Squares of a Sorted Array

给你一个按 **非递减顺序non-decreasing** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

- 示例

  ```
  输入：nums = [-4,-1,0,3,10]
  输出：[0,1,9,16,100]
  解释：平方后，数组变为 [16,1,0,9,100]
  排序后，数组变为 [0,1,9,16,100
  
  输入：nums = [-7,-3,2,3,11]
  输出：[4,9,9,49,121]
  ```

### 4.2 解题：双指针

- 第一种解法：暴力解法

  每个数平方后，再排序

  ```c++
  class Solution {
  public:
      vector<int> sortedSquares(vector<int>& nums) {
          for(int i=0;i<nums.size();i++){
              nums[i]*=nums[i];
          }
          sort(nums.begin(),nums.end()); #快速排序
          return nums;
      }
  };
  ```

  时间复杂度：O(n+log(n))

- 第二种解法：双指针法

  数组其实是有序的， 只不过负数平方之后可能成为最大数了。

  那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

  此时可以考虑双指针法了，left指向起始位置，right指向终止位置。

  定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

  如果`A[left] * A[left] < A[right] * A[right]` 那么`result[k--] = A[right] * A[right];` 。

  如果`A[left] * A[left] >= A[right] * A[right]` 那么`result[k--] = A[left] * A[left];` 。

  ```c++
  class Solution {
  public:
      vector<int> sortedSquares(vector<int>& nums) {
          int k = nums.size()-1;
          vector<int> results(nums.size(),0);
          for(int left=0,right=nums.size()-1; left<=right; ){
              if(nums[left]*nums[left]<=nums[right]*nums[right]){
                  results[k--]=nums[right]*nums[right];
                  right--;
              }
              else{
                  results[k--]=nums[left]*nums[left];
                  left++;
              }
          }
          return results;
      }
  };
  ```


## 5.长度最小的子数组

### 5.1 题目：209 Minimum Size Subarray Sum

给定一个含有 n 个正整数的数组和一个正整数(positive integer) target 。

找出该数组中满足其和 ≥ target 的长度最小的连续子数组(contiguous subarray) [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

- 示例

  ```
  输入：target = 7, nums = [2,3,1,2,4,3]
  输出：2
  解释：子数组 [4,3] 是该条件下的长度最小的子数组。
  
  输入：target = 4, nums = [1,4,4]
  输出：1
  
  输入：target = 11, nums = [1,1,1,1,1,1,1,1]
  输出：0
  ```

### 5.2 解题：滑动窗口

- 第一种解法：暴力解法：用2个for循环，不断寻找符合条件的子序列

  时间复杂度O(n^2)

  ```c++
  class Solution {
  public:
      int minSubArrayLen(int s, vector<int>& nums) {
          int result = INT32_MAX; // 最终的结果
          int sum = 0; // 子序列的数值之和
          int subLength = 0; // 子序列的长度
          for (int i = 0; i < nums.size(); i++) { // 设置子序列起点为i
              sum = 0;
              for (int j = i; j < nums.size(); j++) { // 设置子序列终止位置为j
                  sum += nums[j];
                  if (sum >= s) { // 一旦发现子序列和超过了s，更新result
                      subLength = j - i + 1; // 取子序列的长度
                      result = result < subLength ? result : subLength;
                      break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break
                  }
              }
          }
          // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
          return result == INT32_MAX ? 0 : result;
      }
  };
  ```

- 第二种解法：滑动窗口

  所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。滑动窗口也可以理解为双指针法的一种。只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

  如果只用一个for循环来表示滑动窗口的起始位置，那么此时难免再次陷入暴力解法的怪圈。

  所以只用一个for循环，那么这个循环的索引，一定是表示滑动窗口的终止位置。

  在本题中实现滑动窗口，主要确定如下三点：

  - 窗口内是什么？

    窗口就是满足其和 ≥ s 的长度最小的连续子数组。

  - 如何移动窗口的起始位置？

    窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

  - 如何移动窗口的结束位置？

    窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

  **滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

  ```c++
  class Solution {
  public:
      int minSubArrayLen(int s, vector<int>& nums) {
          int result = INT32_MAX;
          int sum = 0; // 滑动窗口数值之和
          int i = 0; // 滑动窗口起始位置
          int subLength = 0; // 滑动窗口的长度
          for (int j = 0; j < nums.size(); j++) {
              sum += nums[j];
              // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
              // 虽然for里放了一个while，但看元素被操作的次数是一进一出2次，所以是2n即o(n)
              while (sum >= s) {
                  subLength = (j - i + 1); // 取子序列的长度
                  result = result < subLength ? result : subLength;
                  sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
              }
          }
          // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
          return result == INT32_MAX ? 0 : result;
      }
  };
  ```

  

### 5.3 相似题：

- 904.水果成篮
- 76.最小覆盖子串

## 6.螺旋矩阵2

### 6.1 题目：Spiral Matrix II

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

- 示例：

  ```
  输入：n = 3
  输出：[[1,2,3],[8,9,4],[7,6,5]]
  
  输入：n = 1
  输出：[[1]]
  ```

### 6.2 解题：

本题并不涉及到什么算法，就是模拟过程。

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。

和二分法一样，本题要坚持**循环不变量**的原则。即我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的**左闭右开，或者左开右闭**的原则，这样这一圈才能按照统一的规则画下来。

按**左闭右开**的原则即处理到每一个拐角时：拐角处让给新的一条边来继续画。

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j = starty; j < n - offset; j++) {
                res[startx][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i = startx; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

### 6.3 相似题

- 54.螺旋矩阵
- 剑指Offer 29.顺时针打印矩阵



## 7.总结：

- **数组是存放在连续内存空间上的相同类型数据的集合。**

  - 一维数组的地址是连续的
  - 二维数组的地址不一定连续。
    - 矩阵每行上的元素地址是连续的
    - 但是行与行之间的地址不一定连续

- **数组的元素是不能删的，只能覆盖。**

  - 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。

- 上面总共列举了四种数组题目

  1. 二分法(2)

     **循环不变量原则**，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。

  2. 双指针法(3,4)

     **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

  3. 滑动窗口(5)

     **滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

  4. 模拟行为(6)

     不涉及到什么算法，就是单纯的模拟。要遵守**循环不变量原则**

# 二、链表

## 1.理论基础

- 链表类型

  1. 单链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）
     - 链接的入口节点称为链表的头结点也就是head。

  2. 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。
     - 双链表既可以向前查询也可以向后查询。

  3. 循环链表：链表首尾相连。
     - 循环链表可以用来解决约瑟夫环问题。

- 链表的存储方式

  链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

- 链表的定义

  ```c++
  struct ListNode {
      int val;  // 节点上存储的元素
      ListNode *next;  // 指向下一个节点的指针
      ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
  };
  ```

- 性能分析

  | 时间复杂度 | 插入/删除 | 查询 | 适用场景                         |
  | ---------- | --------- | ---- | -------------------------------- |
  | 数组       | O(n)      | O(1) | 数据量固定，频繁查询，较少增删   |
  | 链表       | O(1)      | O(n) | 数据量不固定，频繁增删，较少查询 |

  - 数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

  - 链表的长度可以是不固定的，并且可以动态增删， 

- 总结图

  ![](https://github.com/Fernweh-yang/Reading-Notes/blob/main/%E7%AC%94%E8%AE%B0%E9%85%8D%E5%A5%97%E5%9B%BE%E7%89%87/Algorithm/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png?raw=true)

## 2.移除链表元素

- 题目：203：Remove Linked List Elements

  给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
  
  示例：
  
  ```
  示例1：
  输入：head = [1,2,6,3,4,5,6], val = 6
  输出：[1,2,3,4,5]
  
  示例2：
  输入：head = [], val = 1
  输出：[]
  
  示例3：
  输入：head = [7,7,7,7], val = 7
  输出：[]
  ```
  
- 解题：

  - 设立一个虚拟头节点来保证，处理任何节点都是同一个思路。会比直接操作原链表更方便

    ```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    // 第一种做法：直接操作原链表
    class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            // 需要单独处理头节点
            while(head!=NULL && head->val == val){
                ListNode* tmp = head;
                head = head->next;
                delete tmp;
            }
            // 然后再处理后面的节点
            ListNode* cur = head;
            while(cur!=NULL && cur->next!=NULL){
                if(cur->next->val==val){
                    ListNode* tmp = cur->next;
                    cur->next = cur->next->next;
                    delete tmp;
                }
                else
                    cur = cur->next;
            }
            return head;
        }
    };
    
    // 第二种做法：设疑一个虚拟头节点
    class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
            dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
            ListNode* cur = dummyHead;
            while (cur->next != NULL) {
                if(cur->next->val == val) {
                    ListNode* tmp = cur->next;
                    cur->next = cur->next->next;
                    // malloc/free->new/delete。delete不仅可以释放内存，还可以在对对象时自动调用析构函数
                    delete tmp;
                } else {
                    cur = cur->next;
                }
            }
            head = dummyHead->next;
            delete dummyHead;
            return head;
        }
    };
    ```
    
    


# 三、哈希表

Hash table

## 1.理论基础

- 哈希表是根据关键码的值而直接进行访问的数据结构

  - 数据就是一个哈希表：关键码就是数组的索引下标，然后通过下标直接访问数组中的元素
  - 一般哈希表都是用来快速判断一个元素是否出现集合里。

- 哈希函数：把元素的值直接映射为哈希表上的索引

  - 哈希函数通过hashCode把元素值转化为哈希表上的索引。
  - 如果hashCode得到的数值大于哈希表的大小了，就对数值做一个取模操作，以保证元素的值一定可以映射到哈希表上。

- 哈希碰撞：元素的数量大于哈希表的大小，多个元素映射到了同一个索引下。

- 解决哈希碰撞的2种方法

  1. 拉链法Chaining：把散列到同一槽中的所有元素放在一个链表中，而将此链表的头指针放在散列表T[0…m-1]中
  2. 开放寻址Open Adressing：将所有结点均存放在散列表T[0…m-1]中.
     - 有线性探测、二次探测以及双重探测。三种技术
     - 即去找一个空位来放置冲突的元素，因此要求哈希表的tableSize必须大于datasize

- 常见的三种哈希结构：

  1. 数组

  2. set集合

     | 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
     | std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
     | std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

     - 红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。
     - 优先使用unordered_set，因为它的查询和增删效率最优
     - 所有的元素只有key，没有value, key即value

  3. map映射

     | 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
     | std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
     | std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

     - 所有的元素都是key :value

## 2.有效的字母异位词

- 题目：

  给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

  注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

  示例：

  ```
  输入: s = "anagram", t = "nagaram"
  输出: true
  
  输入: s = "rat", t = "car"
  输出: false
  ```

- 解题：

  - 暴力的解法，两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。

  - 利用哈希表来做：

    **数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组record，来记录字符串s里字符出现的次数。**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**

    - 遍历 s 时：**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。**
    - 遍历 t 时：，对t中出现的字符映射哈希表索引上的数值再做-1的操作。
    - 最后检查record数组是否所有元素都为0，如果不是那就说明s和t不是字母异位词。

    ```c++
    class Solution {
    public:
        bool isAnagram(string s, string t) {
            vector<int> record(26,0);
            for (int i = 0; i < s.size(); i++) {
                // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
                record[s[i] - 'a']++;
            }
            for (int i = 0; i < t.size(); i++) {
                record[t[i] - 'a']--;
            }
            for (int i = 0; i < 26; i++) {
                if (record[i] != 0) {
                    // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                    return false;
                }
            }
            // record数组所有元素都为零0，说明字符串s和t是字母异位词
            return true;
        }
    };
    ```

    

# 四、字符串

## 1.理论基础

- 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组

## 2. 反转字符串

- 题目：344:Reverse String

  编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

  不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

  示例：

  ```
  输入：s = ["h","e","l","l","o"]
  输出：["o","l","l","e","h"]
  
  输入：s = ["H","a","n","n","a","h"]
  输出：["h","a","n","n","a","H"]
  ```

- 题解

  使用库函数的原则：**如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。**

  - 使用reverse库函数：

    ```c++
    class Solution {
    public:
        void reverseString(vector<char>& s) {
            reverse(s.begin(),s.end());
        }
    };
    ```

  - 使用swap库函数

    ```c++
    class Solution {
    public:
        void reverseString(vector<char>& s) {
            for(int i=0,j=s.size()-1;i<s.size()/2;i++,j--){
                swap(s[i],s[j]);
            }
        }
    };
    
    // swap()实现的两种原理：
    //1. 中间值
    int tmp = s[i];
    s[i] = s[j];
    s[j] = tmp;
    //2. 位运算：异或
    s[i] ^= s[j];
    s[j] ^= s[i];
    s[i] ^= s[j];
    ```

    

# 五、双指针法

## 1.理论基础

- 双指针法并不隶属于某一种数据结构，但数组，链表，字符串都会用到双指针法

## 2. 移除元素

- 题目：27:Remove Element

  给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

  不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

  元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

  示例：

  ```
  输入：nums = [3,2,2,3], val = 3
  输出：2, nums = [2,2]
  解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
  
  输入：nums = [0,1,2,2,3,0,4,2], val = 2
  输出：5, nums = [0,1,4,0,3]
  解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
  ```

- 题解

  - 暴力方法：
  
    用2个for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。将val值移到数组的最后面。
  
    时间复杂度：O(n^2)
  
    ```c++
    class Solution {
    public:
        int removeElement(vector<int>& nums, int val) {
            int size = nums.size();
            for(int i=0;i<size;i++){
                if(nums[i]==val){
                    for(int j=i;j<size;j++){
                        nums[i]=nums[j];
                    }
                    i--;	// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                    size--;	// 此时数组的大小-1
                }
            }
            return size;
        }
    };
    ```
  
  - 双指针法：
  
    通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。
  
    核心思想就是：慢指针指向要处理的val值。快指针遍历整个数组，将不是val的值覆盖掉慢指针指向的val值。
  
    时间复杂度：O(n)。空间复杂度：O(1)
  
    ```c++
    class Solution {
    public:
        int removeElement(vector<int>& nums, int val) {
            int slowindex = 0;
            for(int fastindex=0;fastindex < nums.size(); fastindex++){
                // 如果不是val值，两个指针会一起往前进。
    			// 如果是val值，快指针移到下一个，慢指针仍指向val值。
                // 直到快指针移到下一个不是val值的地方，然后慢指针指向的val值会被该值覆盖掉。
                // 最后2个指针再往前移动处理下一个val值。
                if(val != nums[fastindex]){
                    nums[slowindex++]=nums[fastindex];
                }
            }
            return slowindex;
        }
    };
    ```
  
  - 类似题：
  
    - 26.删除排序数组中的重复项
    - 283.移动零
    - 844.比较含退格的字符串
    - 977.有序数组的平方
  
  

# 六、栈与队列

## 1.理论基础

- 队列是先进先出，栈是先进后出。
- **栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**
  - 栈的底层实现可以是vector，deque，list 
  - 栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。
  - 所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）
  - 我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构
  - deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。
  - 指定其他底层实现：
    - 指定vector为栈的底层实现：`std::stack<int, std::vector<int> > third;`
    - 指定list 为队列的底层实现：`std::queue<int, std::list<int>> third; `
- **SGI STL中 队列底层实现缺省情况下一样使用deque实现的。**
  - 同样不允许有遍历行为，不提供迭代器

## 2.用栈实现队列

- 题目 232:Implement Queue using Stacks

  实现 MyQueue 类：

  - void push(int x) 将元素 x 推到队列的末尾
    int pop() 从队列的开头移除并返回元素
    int peek() 返回队列开头的元素
    boolean empty() 如果队列为空，返回 true ；否则，返回 false

  示例

  ```
  输入：
  ["MyQueue", "push", "push", "peek", "pop", "empty"]
  [[], [1], [2], [], [], []]
  输出：
  [null, null, null, 1, 1, false]
  ```

- 题解

  用一个栈来模拟队列的功能是不现实的，必须用1个输入栈1个输出栈来模拟。

  ```c++
  class MyQueue {
  private:
      stack<int> stIn;
      stack<int> stOut;
  public:
      MyQueue() {
  
      }
      //在push数据的时候，只要数据放进输入栈就好
      void push(int x) {
          stIn.push(x);
      }
      //输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。
      int pop() {
          if(stOut.empty()){
              while(!stIn.empty()){
                  stOut.push(stIn.top());           
                  stIn.pop();
              }
          }
          int result = stOut.top();
          stOut.pop();
          return result;
      }
      // 区别于pop就是头元素不删除
      int peek() {
          if(stOut.empty()){
              while(!stIn.empty()){
                  stOut.push(stIn.top());           
                  stIn.pop();
              }
          }
          int result = stOut.top();
          return result;
      }
      // 2个栈都是空的，那队列就是空的
      bool empty() {
          if(stOut.empty()&&stIn.empty())
              return true;
          else
              return false;
      }
  };
  
  ```
  
  
  
  
  
  
  
  

# 七、二叉树

## 1.理论基础

- 二叉树的种类
  - 满二叉树：如果一棵二叉树只有度为0的结点（国外定义，国内度必须是2）和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
    - 度：即有几个子节点
    - 深度为k，有2^k-1个节点
  - 完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层**最左边**的若干位置。
    - 堆就是一棵完全二叉树，同时保证父子节点的顺序关系
  - 二叉搜索树：二叉搜索树是一个有有序数值的有序树
    - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
    - 它的左、右子树也分别为二叉排序树
  - 平衡二叉树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
    - C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树。所以map、set的增删操作时间时间复杂度是logn
      - unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。

- 二叉树的存储方式

  - 二叉树可以链式存储，也可以顺序存储。链式存储方式就用指针， 顺序存储的方式就是用数组。
  - 如果用数组来存储：如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2
  - 一般使用链式存储二叉树

- 二叉树的遍历方式

  - 深度优先遍历：使用递归的方式或借助栈使用非递归的方式来实现

    **这里前中后，其实指的就是中间节点的遍历顺序**

    - 前序遍历（递归法，迭代法）中间节点的顺序：中左右
    - 中序遍历（递归法，迭代法）中间节点的顺序：左中右
    - 后序遍历（递归法，迭代法）中间节点的顺序：左右中

  - 广度优先遍历：使用队列来实现

    - 层次遍历（迭代法）

- 二叉树的定义：

  ```c++
  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };
  ```

  

# 八、回溯算法

## 1.理论基础

- 回溯算法也叫回溯搜索法，是递归的副产品。

  - 回溯的本质是穷举，琼剧所有的可能，然后选出想要的答案。所以效率不高。

- 回溯法，一般解决如下问题：

  - 组合问题：N个数里面按一定规则找出k个数的集合。组合无序
  - 切割问题：一个字符串按一定规则有几种切割方式
  - 子集问题：一个N个数的集合里有多少符合条件的子集
  - 排列问题：N个数按一定规则全排列，有几种排列方式。排列有序
  - 棋盘问题：N皇后，解数独等等

  所有回溯法的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

- 回溯函数做题模板

  ```c++
  // 第一步：回溯函数模板返回值以及参数
  // 因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
  void backtracking(参数) {
      // 第二步：回溯函数终止条件
      // 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
      if (终止条件) {
          存放结果;
          return;
      }
  	
      // 第三步：回溯搜索的遍历过程
      // 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
      for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
          处理节点;
          backtracking(路径，选择列表); // 递归
          回溯，撤销处理结果
      }
  }
  ```
  
  
  

# 九、贪心算法

## 1.理论基础

- **贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。
  - 贪心算法并没有固定的套路。所以唯一的难点就是如何通过局部最优，推出整体最优。
- 如何验证可不可以用贪心?
  - **最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**
  - 严谨的话需要数学证明
    - 数学归纳法
    - 反证法
- 一般截图步骤
  - 将问题分解为若干个子问题
  - 找出适合的贪心策略
  - 求解每一个子问题的最优解
  - 将局部最优解堆叠成全局最优解

  
  
# 十、动态规划

Dynamic Programming,简称dp

## 1.理论基础

- 如果某一问题有很多重叠子问题，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的.

- 解题步骤
  1. 确定dp数组（dp table）以及下标的含义
  2. 确定递推公式
  3. dp数组如何初始化
  4. 确定遍历顺序
  5. 举例推导dp数组

- 动态规划如何debug

  - **做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

  - 然后再写代码，如果代码没通过就**打印dp数组**，看看是不是和自己预先推导的哪里不一样。

    - 如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。
    - 如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

  - 具体debug时问自己三个问题

    1. 这道题目我举例推导状态转移公式了么？
    2. 我打印dp数组的日志了么？
    3. 打印出来了dp数组和我想的一样么？

    
