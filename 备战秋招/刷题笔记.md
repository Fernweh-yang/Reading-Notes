# 零、学习资源汇总

- 主体：[代码随想录](https://www.programmercarl.com/)

## 一些重要概念的索引

- KMP：见第四章(字符串)的7
- 递归：见第七章(二叉树)的2

# 一、数组

## 1.理论基础

- 数组是存放在连续内存空间上的相同类型数据的集合
  - 数组下标都是从0开始的。
  - 数组内存空间的地址是连续的
  - 数组的元素是不能删的，只能覆盖！
    - 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）
  
- 二分法：
  - **循环不变量原则**，只有在循环中坚持对区间的定义
  
- 双指针法：
  - 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作
  
- 滑动窗口
  - 滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。
  
- 总结图：

  <img src="https://github.com/Fernweh-yang/Reading-Notes/blob/main/%E7%AC%94%E8%AE%B0%E9%85%8D%E5%A5%97%E5%9B%BE%E7%89%87/Algorithm/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png?raw=true"  />

## 2.二分查找

### 2.1 题目：704 Binary Search

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 `nums` 中的所有元素是不重复的。

示例

```
示例1：
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例2：
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

### 2.2 暴力搜索

#### 2.2.1 C++

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        for(vector<int>::iterator iter = nums.begin(); iter!=nums.end(); iter++){
            # 读取迭代器的值，用指针
            if(*iter==target)
                # 返回迭代器的下标
                return distance(nums.begin(),iter);
        }
        return -1;
    }
};
```

#### 2.2.2 python

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        for i in nums:
            if i == target:
                return nums.index(i)
        return -1
```

### 2.2 解题：二分法

- **这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，这些都是使用二分法的前提条件。

- **循环不变量规则**：**区间的定义是不变量**，在while寻找中每一次边界的处理都要坚持根据区间的定义来操作。二分法，区间的定义一般为两种：

  1. 左闭右闭即[left, right]
  2. 左闭右开即[left, right)

- 第一种解法：左闭右闭[left, right]

  区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

  - while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
  - if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int left = 0;
          int right = nums.size()-1;	//2种写法的区别
          int middle
          while(left <= right){
              middle = left + ((right - left) / 2);
              if(nums[middle]>target){
                  right = middle - 1;	//2种写法的区别
              }
              else if(nums[middle]<target){
                  left = middle + 1;
              }
              else
                  return middle;
          }
          return -1;
  
      }
  };
  ```
  ```python
  class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)-1
        while left <= right:
            middle = int(left + (right - right)/2)
            if nums[middle] == target:
                return middle
            elif nums[middle] < target:
                left = middle+1
            else:
                right = middle -1
        return -1 
  ```

- 第二种解法：左闭右开[left, right)

  有如下两点：

  - while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的，即right代表的那个数是不考虑在内的。
  - if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int left = 0;
          int right = nums.size(); 	//2种写法的区别
          int middle
          while(left < right){
              middle = left + ((right - left) / 2);
              if(nums[middle]>target){
                  right = middle ;	//2种写法的区别
              }
              else if(nums[middle]<target){
                  left = middle + 1;
              }
              else
                  return middle;
          }
          return -1;
  
      }
  };
  ```
  ```python
  class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            middle = int(left + (right - right)/2)
            if nums[middle] == target:
                return middle
            elif nums[middle] < target:
                left = middle+1
            else:
                right = middle 
        return -1 
  ```

### 2.3 相似题：

- 35.搜索插入位置-Search Insert Position
- 34.在排序数组中查找元素的第一个和最后一个位置-Find First and Last Position of Element in Sorted Array
- 69.x 的平方根-Sqrt(x)
- 367.有效的完全平方数-Valid Perfect Square

## 3.移除元素

### 3.1 题目：27 Remove Element

给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

- 说明：

  为什么返回数值是整数，但输出的答案是数组呢?

  请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

  你可以想象内部操作如下:

  ```
  // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
  int len = removeElement(nums, val);
  
  // 在函数里修改输入数组对于调用者是可见的。
  // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
  for (int i = 0; i < len; i++) {
      print(nums[i]);
  }
  ```

- 示例

  ```
  输入：nums = [3,2,2,3], val = 3
  输出：2, nums = [2,2]
  解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
  
  输入：nums = [0,1,2,2,3,0,4,2], val = 2
  输出：5, nums = [0,1,4,0,3]
  解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
  ```

### 3.2 解题：双指针

- 第一种解法：暴力解法

  用两层for循环，第一层便利数组元素，第二层更新数组

  时间复杂度O(n^2)

- 第二种解法：双指针法（快慢指针）

  **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

  - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
  - 慢指针：指向更新新数组下标的位置(即目标元素的位置)

  ```c++
  class Solution {
  public:
      int removeElement(vector<int>& nums, int val) {
          int slowIndex=0;
          for(int fastIndex=0;fastIndex<nums.size();fastIndex++){
              if(nums[fastIndex]!=val){
                  nums[slowIndex++]=nums[fastIndex];
              }
          }
          return slowIndex;
      }
  };
  ```
  ```python
  class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast = 0
        slow = 0
        while fast < len(nums):
            if nums[fast]!= val:
                nums[slow] = nums[fast]
                slow +=1
            fast +=1
        return slow 
  ```
- 第三种解法:双指针(两端向中间)
  - 左指针：找要删除的值
  - 右指针：找不删除的值，然后两者交换
  ```c++
  class Solution {
  public:
      int removeElement(vector<int>& nums, int val) {
          int left =0;
          int right = nums.size()-1;
          while(left<=right){
              if(nums[right]==val)
                  right--;
              else{
                  if(nums[left]==val){
                      nums[left] = nums[right];
                      left++;
                      right--;
                  }else{
                      left++;
                  }
              }
          }
          return left;
      }
  };
  ```
  ```python
  class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        left = 0
        right = len(nums)-1
        while left <= right:
            if nums[right] == val:
                right = right -1
            elif nums[left] == val:
                nums[left] = nums[right]
                left = left + 1
                right = right -1
            else:
                left = left + 1
        return left
            
  ```

### 3.3 相似题：

- 26.删除排序数组中的重复项
- 283.移动零
- 844.比较含退格的字符串
- 977.有序数组的平方



## 4.有序数组的平方

### 4.1 题目：977 Squares of a Sorted Array

给你一个按 **非递减顺序non-decreasing** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

- 示例

  ```
  输入：nums = [-4,-1,0,3,10]
  输出：[0,1,9,16,100]
  解释：平方后，数组变为 [16,1,0,9,100]
  排序后，数组变为 [0,1,9,16,100
  
  输入：nums = [-7,-3,2,3,11]
  输出：[4,9,9,49,121]
  ```

### 4.2 解题：双指针

- 第一种解法：暴力解法

  每个数平方后，再排序

  ```c++
  class Solution {
  public:
      vector<int> sortedSquares(vector<int>& nums) {
          for(int i=0;i<nums.size();i++){
              nums[i]*=nums[i];
          }
          sort(nums.begin(),nums.end()); #快速排序
          return nums;
      }
  };
  ```

  时间复杂度：O(n+log(n))

- 第二种解法：双指针法

  数组其实是有序的， 只不过负数平方之后可能成为最大数了。

  那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

  此时可以考虑双指针法了，left指向起始位置，right指向终止位置。

  定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

  如果`A[left] * A[left] < A[right] * A[right]` 那么`result[k--] = A[right] * A[right];` 。

  如果`A[left] * A[left] >= A[right] * A[right]` 那么`result[k--] = A[left] * A[left];` 。

  ```c++
  class Solution {
  public:
      vector<int> sortedSquares(vector<int>& nums) {
          int k = nums.size()-1;
          vector<int> results(nums.size(),0);
          for(int left=0,right=nums.size()-1; left<=right; ){
              if(nums[left]*nums[left]<=nums[right]*nums[right]){
                  results[k--]=nums[right]*nums[right];
                  right--;
              }
              else{
                  results[k--]=nums[left]*nums[left];
                  left++;
              }
          }
          return results;
      }
  };
  ```
  ```python
  class Solution:
      def sortedSquares(self, nums: List[int]) -> List[int]:
          i = len(nums)-1
          temp = [0] * (i+1)
          left = 0
          right = i
          while left <= right:
              if nums[left]*nums[left] <= nums[right]*nums[right]:
                  temp[i] = nums[right]*nums[right]
                  i -=1
                  right -=1
              else:
                  temp[i] = nums[left]*nums[left]
                  i-=1
                  left+=1
          return temp
  ```

## 5.长度最小的子数组

### 5.1 题目：209 Minimum Size Subarray Sum

给定一个含有 n 个正整数的数组和一个正整数(positive integer) target 。

找出该数组中满足其和 ≥ target 的长度最小的连续子数组(contiguous subarray) [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

- 示例

  ```
  输入：target = 7, nums = [2,3,1,2,4,3]
  输出：2
  解释：子数组 [4,3] 是该条件下的长度最小的子数组。
  
  输入：target = 4, nums = [1,4,4]
  输出：1
  
  输入：target = 11, nums = [1,1,1,1,1,1,1,1]
  输出：0
  ```

### 5.2 解题：滑动窗口

- 第一种解法：暴力解法：用2个for循环，不断寻找符合条件的子序列

  时间复杂度O(n^2)

  ```c++
  class Solution {
  public:
      int minSubArrayLen(int s, vector<int>& nums) {
          int result = INT32_MAX; // 最终的结果
          int sum = 0; // 子序列的数值之和
          int subLength = 0; // 子序列的长度
          for (int i = 0; i < nums.size(); i++) { // 设置子序列起点为i
              sum = 0;
              for (int j = i; j < nums.size(); j++) { // 设置子序列终止位置为j
                  sum += nums[j];
                  if (sum >= s) { // 一旦发现子序列和超过了s，更新result
                      subLength = j - i + 1; // 取子序列的长度
                      result = result < subLength ? result : subLength;
                      break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break
                  }
              }
          }
          // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
          return result == INT32_MAX ? 0 : result;
      }
  };
  ```

- 第二种解法：滑动窗口

  所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。滑动窗口也可以理解为双指针法的一种。只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

  如果只用一个for循环来表示滑动窗口的起始位置，那么此时难免再次陷入暴力解法的怪圈。

  所以只用一个for循环，那么这个循环的索引，一定是表示滑动窗口的终止位置。

  在本题中实现滑动窗口，主要确定如下三点：

  - 窗口内是什么？

    窗口就是满足其和 ≥ s 的长度最小的连续子数组。

  - 如何移动窗口的起始位置？

    窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

  - 如何移动窗口的结束位置？

    窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

  **滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

  ```c++
  class Solution {
  public:
      int minSubArrayLen(int s, vector<int>& nums) {
          int result = INT32_MAX;
          int sum = 0; // 滑动窗口数值之和
          int i = 0; // 滑动窗口起始位置
          int subLength = 0; // 滑动窗口的长度
          for (int j = 0; j < nums.size(); j++) {
              sum += nums[j];
              // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
              // 虽然for里放了一个while，但看元素被操作的次数是一进一出2次，所以是2n即o(n)
              while (sum >= s) {
                  subLength = (j - i + 1); // 取子序列的长度
                  result = result < subLength ? result : subLength;
                  sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
              }
          }
          // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
          return result == INT32_MAX ? 0 : result;
      }
  };
  ```

### 5.3 相似题：

- 904.水果成篮
- 76.最小覆盖子串

## 6.螺旋矩阵2

### 6.1 题目：59 Spiral Matrix II

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

- 示例：

  ```
  输入：n = 3
  输出：[[1,2,3],[8,9,4],[7,6,5]]
  
  输入：n = 1
  输出：[[1]]
  ```

### 6.2 解题：

本题并不涉及到什么算法，就是模拟过程。

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。

和二分法一样，本题要坚持**循环不变量**的原则。即我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的**左闭右开，或者左开右闭**的原则，这样这一圈才能按照统一的规则画下来。

按**左闭右开**的原则即处理到每一个拐角时：拐角处让给新的一条边来继续画。

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j = starty; j < n - offset; j++) {
                res[startx][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i = startx; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

### 6.3 相似题

- 54.螺旋矩阵
- 剑指Offer 29.顺时针打印矩阵



## 7.总结：

- **数组是存放在连续内存空间上的相同类型数据的集合。**

  - 一维数组的地址是连续的
  - 二维数组的地址不一定连续。
    - 矩阵每行上的元素地址是连续的
    - 但是行与行之间的地址不一定连续

- **数组的元素是不能删的，只能覆盖。**

  - 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。

- 上面总共列举了四种数组题目

  1. 二分法(2)

     **循环不变量原则**，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。

  2. 双指针法(3,4)

     **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

  3. 滑动窗口(5)

     **滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

  4. 模拟行为(6)

     不涉及到什么算法，就是单纯的模拟。要遵守**循环不变量原则**

# 二、链表

## 1.理论基础

- 链表类型

  1. 单链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）
     - 链接的入口节点称为链表的头结点也就是head。

  2. 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。
     - 双链表既可以向前查询也可以向后查询。

  3. 循环链表：链表首尾相连。
     - 循环链表可以用来解决约瑟夫环问题。

- 链表的存储方式

  链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

- 链表的定义

  ```c++
  struct ListNode {
      int val;  // 节点上存储的元素
      ListNode *next;  // 指向下一个节点的指针
      ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
  };
  ```

- 性能分析

  | 时间复杂度 | 插入/删除 | 查询 | 适用场景                         |
  | ---------- | --------- | ---- | -------------------------------- |
  | 数组       | O(n)      | O(1) | 数据量固定，频繁查询，较少增删   |
  | 链表       | O(1)      | O(n) | 数据量不固定，频繁增删，较少查询 |

  - 数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

  - 链表的长度可以是不固定的，并且可以动态增删， 

- 总结图

  ![](https://github.com/Fernweh-yang/Reading-Notes/blob/main/%E7%AC%94%E8%AE%B0%E9%85%8D%E5%A5%97%E5%9B%BE%E7%89%87/Algorithm/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png?raw=true)

## 2.移除链表元素

- 题目：203：Remove Linked List Elements

  给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
  
  示例：
  
  ```
  示例1：
  输入：head = [1,2,6,3,4,5,6], val = 6
  输出：[1,2,3,4,5]
  
  示例2：
  输入：head = [], val = 1
  输出：[]
  
  示例3：
  输入：head = [7,7,7,7], val = 7
  输出：[]
  ```
  
- 解题：

  - 设立一个虚拟头节点来保证，处理任何节点都是同一个思路。会比直接操作原链表更方便

    ```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    // 第一种做法：直接操作原链表
    class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            // 需要单独处理头节点
            while(head!=NULL && head->val == val){
                ListNode* tmp = head;
                head = head->next;
                delete tmp;
            }
            // 然后再处理后面的节点
            ListNode* cur = head;
            while(cur!=NULL && cur->next!=NULL){
                if(cur->next->val==val){
                    ListNode* tmp = cur->next;
                    cur->next = cur->next->next;
                    delete tmp;
                }
                else
                    cur = cur->next;
            }
            return head;
        }
    };
    
    // 第二种做法：设疑一个虚拟头节点
    class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
            dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
            ListNode* cur = dummyHead;
            while (cur->next != NULL) {
                if(cur->next->val == val) {
                    ListNode* tmp = cur->next;
                    cur->next = cur->next->next;
                    // malloc/free->new/delete。delete不仅可以释放内存，还可以在对对象时自动调用析构函数
                    delete tmp;
                } else {
                    cur = cur->next;
                }
            }
            head = dummyHead->next;
            delete dummyHead;
            return head;
        }
    };
    ```
    

## 3.设计链表

- 题目：707.Design Linked List

  设计一个自己的链表类，它有如下方法：

  - `MyLinkedList()` Initializes the `MyLinkedList` object.
  - `int get(int index)` Get the value of the `indexth` node in the linked list. If the index is invalid, return `-1`.
  - `void addAtHead(int val)` Add a node of value `val` before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
  - `void addAtTail(int val)` Append a node of value `val` as the last element of the linked list.
  - `void addAtIndex(int index, int val)` Add a node of value `val` before the `indexth` node in the linked list. If `index` equals the length of the linked list, the node will be appended to the end of the linked list. If `index` is greater than the length, the node **will not be inserted**.
  - `void deleteAtIndex(int index)` Delete the `indexth` node in the linked list, if the index is valid.

- 解题：

  ```c++
  class MyLinkedList {
  public:
      struct ListNode{    //用结构体来实现链表
          int val;
          ListNode *next;
          ListNode(int x):val(x),next(nullptr){}
      };
  
      MyLinkedList() {
          _dummyHead = new ListNode(0);   // 头节点使用虚拟节点有助于统一每个节点的操作
          _size=0;  						// 用于判断访问的index是否合法
      }
      
      int get(int index) {				// 注意index是从0开始的，第0个节点就是头结点
          if(index < _size && index >=0){
              ListNode* cur = _dummyHead->next; // 所以从虚拟节点的next开始
              while(index--){
                  cur = cur->next;
              }
              return cur->val;
          }
          else
              return -1;
      }
      
      void addAtHead(int val) {			
          ListNode* newHead = new ListNode(val);
          newHead->next = _dummyHead->next; //这里就体现了虚拟头节点的好处, 不用用一个中间节点来删减头节点的方式转换头节点。
          _dummyHead->next = newHead;
          _size++;
      }
      
      void addAtTail(int val) {
          ListNode* cur = _dummyHead;
          while(cur->next!=nullptr){		  // 一路找到最后那个节点先
              cur = cur->next;
          }
          ListNode* newTail = new ListNode(val);
          cur->next = newTail;
          _size++;
      }
      
      void addAtIndex(int index, int val) {	// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
          if(index <0 || index>_size){
              return;
          }
          ListNode* cur = _dummyHead;
          ListNode* newNode = new ListNode(val);
          while(index--){				// 一路找到index对应的节点先
              cur = cur->next;
          }
          newNode->next = cur->next;
          cur->next = newNode;
          _size++;
      }
      
      void deleteAtIndex(int index) {	// 注意index是从0开始的
          if(index <0 || index>=_size){
              return;
          }
          ListNode* cur = _dummyHead;
          while(index--){			    // 一路找到index对应的节点先
              cur = cur->next;
          }
          ListNode* temp = cur->next;
          cur->next = cur->next->next;
          delete temp;
          _size--;
      }
  private:    //类方法用到的变量都定义在私有域里
      int _size;  
      ListNode* _dummyHead;
  };
  
  /**
   * Your MyLinkedList object will be instantiated and called as such:
   * MyLinkedList* obj = new MyLinkedList();
   * int param_1 = obj->get(index);
   * obj->addAtHead(val);
   * obj->addAtTail(val);
   * obj->addAtIndex(index,val);
   * obj->deleteAtIndex(index);
   */
  ```

  

## 4.反转链表

- 题目：206.Reverse Linked List

  给予一个链表，反转它

  ```
  Input: head = [1,2,3,4,5]： 1->2->3->4->5
  Output: [5,4,3,2,1]:        5->4->3->2->1
  ```

- 解题：

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
  public:	
      ListNode* reverseList(ListNode* head) {	//用三个指针交替保存各自数据，实现链表反转。
          ListNode* temp ;
          ListNode* pre = nullptr;
          ListNode* cur = head;
          while(cur != nullptr){
              temp = cur->next;
              cur->next = pre;
              pre = cur;
              cur = temp;
          }
          return pre;
      }
  };
  ```

## 5.两两交换链表中的节点

- 题目：24.Swap Nodes in Pairs

  每两个节点之间改变位置：

  ```
  Input: head = [1,2,3,4]
  Output: [2,1,4,3]
  
  Input: head = []
  Output: []
  
  Input: head = [1]
  Output: [1]
  ```

- 解题：

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
  public:
      ListNode* swapPairs(ListNode* head) {
          ListNode* virtualHead = new ListNode(0,head);
          ListNode* cur = virtualHead;
          // 使用虚拟头节点来统一操作
          while(cur->next != nullptr && cur->next->next != nullptr){	//如果下/下下一个为空什么都不操作保持原样就可以
              ListNode* first = cur->next;
              ListNode* second = cur->next->next;
  
              cur->next = second;
              first->next = second->next;
              second->next = first;
  
              cur = cur->next->next;
          }
          return virtualHead->next;	//注意这里return head就不对了，因为18，23行已经把first(head)->next的关系变动了.
      
      }
  };
  ```

## 6.删除链表的倒数第N个节点

- 题目：19. Remove Nth Node From End of List

  给予一个链表，删除从它尾部数起的第n个节点

  ```
  Input: head = [1,2,3,4,5], n = 2
  Output: [1,2,3,5]
  ```

- 解题：

  - 笨办法：
  
    1. 先遍历一遍，有多少个节点
    2. 然后找到要操作的那个节点
  
    ```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
            ListNode* fakeHead = new ListNode(0,head);
            ListNode* cur = fakeHead;
            int i = 0;
            while(cur->next != nullptr){
                i++;
                cur = cur->next;
            }
            cur = fakeHead;
            for(int j=0;j<i-n;j++){
                cur = cur->next;
            }
            ListNode* temp = cur->next;
            cur->next = cur->next->next;
            delete temp;
            return fakeHead->next;
        }
    };
    ```
  
  - 双指针：
  
    1. 如果要删除倒数第n个节点，让fast移动n步，
    2. 然后让fast和slow同时移动，直到fast指向链表末尾。
    3. 删掉slow所指向的节点就可以了。
  
    ```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
            ListNode* fakeHead = new ListNode(0,head);
            ListNode* fast = fakeHead;
            ListNode* low = fakeHead;
            while(n-- && fast!=nullptr){	// 1. 如果要删除倒数第n个节点，让fast移动n步，
                fast = fast->next;
            }
            fast = fast ->next;
            while(fast != nullptr){			// 2. 然后让fast和slow同时移动，直到fast指向链表末尾。
                fast = fast->next;
                low = low->next;
            }
            ListNode* temp = low->next;		// 3. 删掉slow所指向的节点就可以了。
            low->next = low->next->next;	
            delete temp;
            return fakeHead->next;
        }
    };
    ```
  
## 7.链表相交

- 题目：Intersection of Two Linked Lists

  给定两个链表，找到链表中地址相同的节点

- 解题：

  1. 求出两个链表的长度，并求出两个链表长度的差值
  2. 然后让短的移动到，和长的那个列表末尾对齐的位置
  3. 比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
          ListNode* curA = headA;
          ListNode* curB = headB;
          int a=0,b=0;
          
          while(curA !=nullptr){		// 1. 求出两个链表的长度，并求出两个链表长度的差值
              curA = curA->next;
              a++;
          }
          while(curB !=nullptr){
              curB = curB->next;
              b++;
          }
          curA = headA;
          curB = headB;
          
          if(a>=b){					// 2. 然后让短的移动到，和长的那个列表末尾对齐的位置
              int i = a-b;
              while(i-- && curA->next!=nullptr){
                  curA = curA->next;
              }
          }
          else{
              int i = b-a;
              while(i-- && curB->next!=nullptr){
                  curB = curB->next;
              }
          }
          
          while(curA!=nullptr){		// 3. 比较curA和curB是否相同
              if(curA==curB)
                  return curA;
              curA = curA->next;
              curB = curB->next;
          }
          return NULL;
      }
  };
  ```

  

## 8.环形链表

- 题目：Linked List Cycle II

  给定一个链表，如果存在环形结构（即尾节点不指向null，而是指向某一中间节点），找到这个环境结构的起始点（中间节点）,否则返回NULL。

  ```
  Input: head = [3,2,0,-4], pos = 1
  Output: tail connects to node index 1
  Explanation: There is a cycle in the linked list, where tail connects to the second node.
  ```

- 解题:

  1. 首先用快慢指针判断是否有环

     - 快指针：从头结点出发，每次走两步
     - 慢指针：从头节点出发，每次走一步
     - 如果他们相遇，就说明有环。
     - **相对于slow来说，fast是一个节点一个节点的靠近slow的**，所以fast一定可以和slow重合。

  2. 找到入口：

     - 假设相遇时slow走了`x+y`,fast走了`x+y+n(y+z)`

       - x为头节点到环入口点的节点数
       - y为环形入口节点到 fast指针与slow指针相遇节点的节点数
       - z为相遇节点再到环形入口节点节点数
       - n为fast走了多少圈后和slow相遇，n至少1，因为快指针至少饶了一圈才能遇到slow

     - 因为fast速度是slow的两倍，所以有公式：`2(x+y)=x+y+n(y+z)`

     - 整理得到`x = (n - 1) (y + z) + z`

       - 当n=1时，x=z,说明

         **从头结点出发一个指针index1，从相遇节点也出发一个指针index2，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

       - 当n>1时，和n=1一样，

         只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode *detectCycle(ListNode *head) {
          ListNode* slow = head;
          ListNode* fast = head;
          while(fast!=nullptr && fast->next!=nullptr){	// 1. 用快慢指针判断是否有环
              slow = slow->next;
              fast = fast->next->next;
              
              if(slow == fast){							// 2. 如果有环，就去找到入口
                  ListNode* index1 = head;
                  ListNode* index2 = fast;
                  while(index1 != index2){
                      index1 = index1->next;
                      index2 = index2->next;
                  }
                  return index1;
              }
          }
          return NULL;
      }
  };
  ```

## 9. 删除排序链表中的重复元素

### 9.1 删除排序链表中的重复元素

- 题目：[83. Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)

  给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

  ```
  输入：head = [1,1,2]
  输出：[1,2]
  ```

- 代码

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
  public:
      ListNode* deleteDuplicates(ListNode* head) {
          ListNode* cur = head;
          if(head==nullptr) return head;
          while(cur->next != nullptr){
              if(cur->val == cur->next->val){
                  cur->next = cur->next->next;
              }else{
                  cur = cur->next;
              }
          }
          return head;
          
      }
  };
  ```

### 9.2 删除排序链表中的重复元素2

- 题目：[82. Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)

  给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

  ```
  输入：head = [1,2,3,3,4,4,5]
  输出：[1,2,5]
  ```

- 代码

  ```c++
  class Solution {
  public:
      ListNode* deleteDuplicates(ListNode* head) {
          if(head==nullptr) return head;
          ListNode* fakeHead = new ListNode(0,head);
          ListNode* cur = fakeHead;
          while(cur->next != nullptr && cur->next->next!=nullptr){
              if(cur->next->val != cur->next->next->val){
                  cur = cur->next;
              }else{
                  int x = cur->next->val;
                  while(cur->next && cur->next->val == x){
                      cur->next = cur->next->next;
                  }
              }
          }
          return fakeHead->next;
      }
  };
  ```

  

## 10.总结

- 主要要理解：
  - 链表的种类主要为：单链表，双链表，循环链表
  - 链表的存储方式：链表的节点在内存中是分散存储的，通过指针连在一起。
  - 链表是如何进行增删改查的。(3.设计链表)
  - 数组和链表在不同场景下的性能分析
- **虚拟头节点**：每次对应头结点的情况都要单独处理时，添加虚拟头节点，统一每个节点的操作。

# 三、哈希表

## 1.理论基础

- 什么是哈希表？

  - 哈希表Hash table，也叫散列表，是根据关键码的值而直接进行访问的数据结构

  - 数组就是一个哈希表：关键码就是数组的索引下标，然后通过下标**直接**访问数组中的元素

- 哈希表能解决什么问题

  - 快速判断一个元素是否出现集合里。
  - 需要查询一个元素是否出现过

- 什么是哈希函数：

  - 哈希函数hash function描述了元素和索引之间的关系。

    哈希函数通过hashCode把元素值转化为哈希表上的索引。

  - 如果hashCode得到的数值大于哈希表的大小了，即索引大过了哈希表的体积，怎么办？

    - 对数值做一个取模操作（即两数相除取余数），得到一个更小的数，就肯定可以映射到哈希表上了

- 什么是哈希碰撞：

  元素的数量大于哈希表的大小，多个元素映射到了同一个索引下。

- 解决哈希碰撞的2种方法

  1. 拉链法Chaining：把散列到同一槽中的所有元素放在一个链表中，而将此链表的头指针放在哈希表T[0…m-1]中
  2. 开放寻址Open Adressing：将所有结点均存放在哈希表T[0…m-1]中.
     - 有线性探测、二次探测以及双重探测。三种技术
     - 即去找一个空位来放置冲突的元素，因此要求哈希表的tableSize必须大于datasize

- 想要哈希法解决问题，常用下面三种数据结构：

  1. 数组

     本身就是可看作是哈希表。

  2. set集合

     c++提供了3种set数据结构

     | 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
     | std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
     | std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

     - 红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。
     - 优先使用[unordered_set](http://c.biancheng.net/view/7250.html)，因为它的查询和增删效率最优。

       如果要求集合有序，就用set。

       如果要求集合有序且有重复数据，就用multiset。
     - set这一大类的数据结构，所有的元素只有key，没有value, key即value

  3. map映射

     c++提供了3种map数据结构

     | 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
     | std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
     | std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

     - 所有的元素都是key :value
       - 所以当题目不仅要找到那个元素，还要直到下标时，用map而不用set。
     - map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

- 哈希法可以快速判断元素是否在集合里，但它**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找

## 2.有效的字母异位词

- 题目：242.Valid Anagram字谜

  给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

  注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

  示例：

  ```
  输入: s = "anagram", t = "nagaram"
  输出: true
  
  输入: s = "rat", t = "car"
  输出: false
  ```

- 解题：

  - 暴力的解法，两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。

  - 利用哈希表来做：

    **数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组record，来记录字符串s里字符出现的次数。**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**

    - 遍历 s 时：**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。**
    - 遍历 t 时：，对t中出现的字符映射哈希表索引上的数值再做-1的操作。
    - 最后检查record数组是否所有元素都为0，如果不是那就说明s和t不是字母异位词。

    ```c++
    class Solution {
    public:
        bool isAnagram(string s, string t) {
            vector<int> record(26,0);
            for (int i = 0; i < s.size(); i++) {
                // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
                record[s[i] - 'a']++;
            }
            for (int i = 0; i < t.size(); i++) {
                record[t[i] - 'a']--;
            }
            for (int i = 0; i < 26; i++) {
                if (record[i] != 0) {
                    // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                    return false;
                }
            }
            // record数组所有元素都为零0，说明字符串s和t是字母异位词
            return true;
        }
    };
    ```


## 3.两个数组的交集

- 题目：349.Intersection of Two Arrays

  给定2个数组，求数组中都有哪些相同的值(值范围是`0 <= nums1[i], nums2[i] <= 1000`)

  ```
  Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
  Output: [9,4]
  Explanation: [4,9] is also accepted.
  ```

- 解题

  - **用数组的做法**：

    1. 记录nums1中出现的值，每个值只记录一次
    2. 记录nums2中出现的值，每个值只记录一次
    3. 最后record中值为2的，就是两个数组中都有的值。

    ```c++
    class Solution {
    public:
        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
            vector<int> record(1000,0);
            for(int i=0; i <nums1.size(); i++){	// 1. 记录nums1中出现的值，每个值只记录一次
                if(record[nums1[i]]==0)
                    record[nums1[i]]++;
            }
            for(int i=0; i<nums2.size(); i++){	// 2. 记录nums2中出现的值，每个值只记录一次
                if(record[nums2[i]]==1)
                    record[nums2[i]]++;
            }
            vector<int> ans;
            for(int i=0; i<1000;i++){			// 3. 最后record中值为2的，就是两个数组中都有的值。
                if(record[i]==2)
                    ans.push_back(i);
            }
            return ans;
        }
    };
    ```

  - **用集合set的做法**：

    - 相比于数组，set解决了如下问题：

      1. 如果值得范围没有限制，我们就无法给定一个确定范围的record
      2. 如果数据集分布的很散，会浪费大量的数组空间

    - 根据1中理论可知，unordered_set 读写效率是最高的，并不需要对数据进行排序

      而本题不需要排序数据，且数据不重复，所以使用unordered_set

    ```c++
    class Solution {
    public:
        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
            unordered_set<int> result;		// 空集合，用于记录要填充的数字
            unordered_set<int> record(nums1.begin(),nums1.end());	// nums1.begin()返回头迭代器，nums1.end()返回尾迭代器。如此把nums1所有的值放入无序集合record里
            
            for(int nums:nums2){	// 冒号:是c++11中新加的用法，对可迭代对象，方便循环。
                if(record.find(nums) != record.end()){	//set.find(xx)如果没找到xx会返回指向尾节点的迭代器，否则返回指向xx的迭代器
                    result.emplace(nums);	//将数值加入到record集合中去
                }
            }
            return vector<int>(result.begin(),result.end());
        }
    };
    ```

    - 相比于数组，set不仅占用空间比数组大，而且速度更慢，set把数值映射到key上都要做hash计算的。

  - **结构数组和set去重的特性**

    ```c++
    class Solution {
    public:
        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
            unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
            int hash[1005] = {0}; // 默认数值为0
            for (int num : nums1) { // nums1中出现的字母在hash数组中做记录
                hash[num] = 1;
            }
            for (int num : nums2) { // nums2中出现话，result记录
                if (hash[num] == 1) {
                    result_set.insert(num);
                }
            }
            return vector<int>(result_set.begin(), result_set.end());
        }
    };
    ```


## 4.快乐数

- 题目：202.Happy Number

  - 编写一个算法来判断一个数 n 是不是快乐数。
  - 快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。

  - 如果 n 是快乐数就返回 True ；不是，则返回 False 

  ```c++
  Input: n = 19
  Output: true
  Explanation:
  12 + 92 = 82
  82 + 22 = 68
  62 + 82 = 100
  12 + 02 + 02 = 1
  ```

- 解题：

  - 找不到1时会无限循环，即sum会重复。

    所以我们就可以用哈希法快速判断一个元素是否出现在集合里

    ```c++
    class Solution {
    public:
        int getSum(int n){			// 求1个数每一位的平方和
            int sum = 0;
            while(n){
                sum +=(n%10)*(n%10);
                n /= 10;
            }
            return sum;
        }
        bool isHappy(int n) {
            unordered_set<int> record;
            if(n==1) return true;
            while(n!=1){
                n = getSum(n);
                if(record.find(n)==record.end()){	//判断是否重复，如果不重复则继续求和，直到找到1
                    record.emplace(n);
                }
                else{
                    return false;
                }
            }
            return true;
        }
    };
    ```

## 5.两数之和

- 题目：Two Sum

  给定一个包含各个数字的数组 和 一个目标数，求数组中哪些组合的和为目标数

  这里每一个目标，只有唯一解。

  ```
  Input: nums = [2,7,11,15], target = 9
  Output: [0,1]
  Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
  ```

- 解题：

  - 暴力法：两层for

    复杂度为$o(n^2)$

  - 用哈希法

    - 为什么用哈希法？

      因为是两数之和，所以只要1.在遍历数组时，2.找一下那个数对应的数在不在集合里就行了。而查看数是否出现过，显然是哈希法的应用场景。

    - 为什么用map来实现哈希法？

      - 数组：数组大小受限，如果元素很少而值很大时，会浪费大量空间

        因为哈希法时，元素值对应的是数组的下标。

      - set: 题目要求返回数组中那2个数的下标。

        显然set的值就是其key，无法返回下标

      - map:是一种key value的存储结构，符合题目要求。

        - key：存数组下标
        - value:存该下标对应的数组值

    ```c++
    class Solution {
    public:
        vector<int> twoSum(vector<int>& nums, int target) {
            unordered_map<int,int> map;
            vector<int> ans;
            for(int i =0;i<nums.size();i++){ 		// 1. 遍历数组 
                int j = target - nums[i];
                if(map.find(j) != map.end()){		// 2. 找一下那个数对应的数在不在集合里
                    return{map.find(j)->second,i};	// 如果在就找到了，返回索引
                }
                map.emplace(pair<int, int>(nums[i], i));	// 不在就加入到map里去
            }
            return {};
        }
    };
    ```

    

## 6.四数相加

- 题目：454.4sum 

  给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

  其中

  - `1 <= n <= 200`
  - `0 <= i, j, k, l < n`
  - `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`

  ```
  Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
  Output: 2
  Explanation:
  The two tuples are:
  1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
  2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
  ```

- 解题：

  - 把4个数组分成2组，
  - 遍历第一组，求两两元素的和作为key，和出现的次数作为value。
  - 遍历第二组，应用哈希表特性，快速寻找是否第一组中有满足4数组和为0的存在
  - 若有，就将出现的次数计入，最后汇总所有可能性。

  ```c++
  class Solution {
  public:
      int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
          unordered_map<int,int> map;
          for(int num1 : nums1){
              for(int num2 : nums2){					// 1. 遍历第一组，求两两元素的和作为key
                  int sum = num1 + num2;
                  if(map.find(sum)!=map.end()){		// map.find()返回的是一个迭代器
                      map.find(sum)->second ++;		// ->first是key,->second是value
                  }
                  else{
                      map.emplace(make_pair(sum,1));
                  }
              }
          }
          int ans=0;
          for(int num3:nums3){
              for(int num4:nums4){					// 2. 遍历第二组，查看是否第一组中有符合的
                  int sum = 0-(num3 + num4);
                  if(map.find(sum)!=map.end()){
                      ans += map.find(sum)->second;	// 3. 若有，则汇总出现的次数
                  }
              }
          }
          return ans;
      }
  };
  ```

  - 更简洁的写法：

    思路与上面一致。

    ```c++
    class Solution {
    public:
        int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
            unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数
            // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
            for (int a : A) {
                for (int b : B) {
                    umap[a + b]++;
                }
            }
            int count = 0; // 统计a+b+c+d = 0 出现的次数
            // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
            for (int c : C) {
                for (int d : D) {
                    if (umap.find(0 - (c + d)) != umap.end()) {
                        count += umap[0 - (c + d)];
                    }
                }
            }
            return count;
        }
    };
    ```

## 7.赎金信

- 题目：383.Ransom Note

  给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

  (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

  ```
  Input: ransomNote = "aa", magazine = "ab"
  Output: false
  
  Input: ransomNote = "aa", magazine = "aab"
  Output: true
  ```

- 解题：

  - 简单的数组应用,把字母从a开始的地址作为索引

  ```c++
  class Solution {
  public:
      bool canConstruct(string ransomNote, string magazine) {
          vector<int> record(26,0);
          for(char x : magazine){
              record[x-'a']++;
          }
          for(char x : ransomNote){
              record[x-'a']--;
              if(record[x-'a']<0) return false;
          }
          return true;
      }
  };
  ```

## 8.三数之和

- 题目：15.3Sum

  给定一个数组，从中选3个数，让他们和为0。返回所有的可能性，要求不能重复相同的数字组合。

  ```c++
  Input: nums = [-1,0,1,2,-1,-4]
  Output: [[-1,-1,2],[-1,0,1]]
  Explanation: 
  nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
  nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
  nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
  The distinct triplets are [-1,0,1] and [-1,-1,2].
  Notice that the order of the output and the order of the triplets does not matter.
  ```

- 解题：

  难点在于去重。

  - 如果用哈希法

    1. 两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在数组里出现过。

    2. 去重：

       - 方案一：把符合条件的三元组放进vector中，然后再去重。超时，无法通过。

       - 方案二：排序后，对a+b+c=0，的a,b,c分别去重。很麻烦,但能通过。o(n^2)

         ```c++
         class Solution {
         public:
             vector<vector<int>> threeSum(vector<int>& nums) {
                 vector<vector<int>> result;
                 sort(nums.begin(), nums.end());
                 // 找出a + b + c = 0
                 // a = nums[i], b = nums[j], c = -(a + b)
                 for (int i = 0; i < nums.size(); i++) {
                     // 排序之后如果第一个元素已经大于零，那么不可能凑成三元组
                     if (nums[i] > 0) {
                         break;
                     }
                     if (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重
                         continue;
                     }
                     unordered_set<int> set;
                     for (int j = i + 1; j < nums.size(); j++) {
                         if (j > i + 2
                                 && nums[j] == nums[j-1]
                                 && nums[j-1] == nums[j-2]) { // 三元组元素b去重
                             continue;
                         }
                         int c = 0 - (nums[i] + nums[j]);
                         if (set.find(c) != set.end()) {
                             result.push_back({nums[i], nums[j], c});
                             set.erase(c);// 三元组元素c去重
                         } else {
                             set.insert(nums[j]);
                         }
                     }
                 }
                 return result;
             }
         };
         ```

  - 双指针法：

    这题相比哈希法更高效

    - 首先将数组从小到大排序，定义三个下标，并对他们去重

      - i：下标0开始的地方

        nums[i]如果等于nums[i-1]，显然重复

      - left：i+1

        nums[left]如果等于nums[lefts+1],显然重复 

      - right:数组结尾的位置

        nums[right]如果等于nums[right-1]，显然重复

    - 对应于a + b +c =0：`a = nums[i]，b = nums[left]，c = nums[right]`。
    - for循环i,去重i，然后计算和
      - 如果`nums[i] + nums[left] + nums[right] > 0`，则让right向左移动。
      - 如果`nums[i] + nums[left] + nums[right] < 0`, 则让left向右移动。
      - 如果`nums[i] + nums[left] + nums[right] = 0`，则加入答案，然后去重right和left，最后移动right和left

    ```c++
    class Solution {
    public:
        vector<vector<int>> threeSum(vector<int>& nums) {
            vector<vector<int>> result;
            sort(nums.begin(), nums.end());
            // 找出a + b + c = 0
            // a = nums[i], b = nums[left], c = nums[right]
            for (int i = 0; i < nums.size(); i++) {
                // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
                if (nums[i] > 0) {
                    return result;
                }
                // 错误去重a方法，将会漏掉-1,-1,2 这种情况
                /*
                if (nums[i] == nums[i + 1]) {
                    continue;
                }
                */
                // 正确去重a方法
                if (i > 0 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {
                    // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                    /*
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    */
                    if (nums[i] + nums[left] + nums[right] > 0) right--;
                    else if (nums[i] + nums[left] + nums[right] < 0) left++;
                    else {
                        result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                        // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;
    
                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }
    
            }
            return result;
        }
    };
    ```

## 9.四数之和

- 题目：18.4Sum

  给定一个数组，选定其中4个，使他们和为给定的target。要求数字排列不重复。

  ```
  Input: nums = [1,0,-1,0,-2,2], target = 0
  Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
  ```

- 解题

  - 有别于6.四数相加，这里是从1个数组里选4个数

    这里也要求，数字排列组合不重复，而6.四数相加要求下标不同就行。

  - 所以这题更类似于8.三数之和，需要进行去重，

  - 解题思路也是再8.三数之和的双指针解法外再套一层for循环.

  ```c++
  class Solution {
  public:
      vector<vector<int>> fourSum(vector<int>& nums, int target) {
          vector<vector<int>> result;
          sort(nums.begin(), nums.end());
          for (int k = 0; k < nums.size(); k++) {
              // 剪枝处理
              if (nums[k] > target && nums[k] >= 0) {
              	break; // 这里使用break，统一通过最后的return返回
              }
              // 对nums[k]去重
              if (k > 0 && nums[k] == nums[k - 1]) {
                  continue;
              }
              for (int i = k + 1; i < nums.size(); i++) {
                  // 2级剪枝处理
                  if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
                      break;
                  }
  
                  // 对nums[i]去重
                  if (i > k + 1 && nums[i] == nums[i - 1]) {
                      continue;
                  }
                  int left = i + 1;
                  int right = nums.size() - 1;
                  while (right > left) {
                      // nums[k] + nums[i] + nums[left] + nums[right] > target 会溢出
                      if ((long) nums[k] + nums[i] + nums[left] + nums[right] > target) {
                          right--;
                      // nums[k] + nums[i] + nums[left] + nums[right] < target 会溢出
                      } else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  < target) {
                          left++;
                      } else {
                          result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                          // 对nums[left]和nums[right]去重
                          while (right > left && nums[right] == nums[right - 1]) right--;
                          while (right > left && nums[left] == nums[left + 1]) left++;
  
                          // 找到答案时，双指针同时收缩
                          right--;
                          left++;
                      }
                  }
  
              }
          }
          return result;
      }
  };
  
  ```

## 10.总结

- 一般来说哈希表都是用来快速判断一个元素是否出现集合里。

- 要知道**哈希函数**和**哈希碰撞**在哈希表中的作用

  - 哈希函数是把传入的key映射到符号表的索引上。
  - 哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。

- 常见的三种哈希结构：

  - 数组
    - 数组就是简单的哈希表，但是数组的大小是受限的
    - 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费
  - set（集合）
    - std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希， 
    - 使用unordered_set 读写效率是最高的，如果不需要对数据进行排序，而且还不要让数据重复，就选择unordered_set。
    - set是一个集合，里面放的元素只能是一个key
  - map（映射）
    - std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），
    - 5.两数之和，并不需要key有序，选择std::unordered_map 效率更高！

  要了解什么时候用具体的哪一种

# 四、字符串

## 1.理论基础

- 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组

- 在C语言中，把一个字符串存入一个数组时，也把结束符 '\0'存入数组，并以此作为该字符串是否结束的标志。

- 在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用'\0'来判断是否结束。

  - vector< char > 和 string 又有什么区别呢？

    其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。

## 2.反转字符串

- 题目：344:Reverse String

  编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

  不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

  示例：

  ```
  输入：s = ["h","e","l","l","o"]
  输出：["o","l","l","e","h"]
  
  输入：s = ["H","a","n","n","a","h"]
  输出：["h","a","n","n","a","H"]
  ```

- 题解

  使用库函数的原则：**如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。**

  - 使用reverse库函数：

    ```c++
    class Solution {
    public:
        void reverseString(vector<char>& s) {
            reverse(s.begin(),s.end());
        }
    };
    ```

  - 使用swap库函数

    ```c++
    class Solution {
    public:
        void reverseString(vector<char>& s) {
            for(int i=0,j=s.size()-1;i<s.size()/2;i++,j--){
                swap(s[i],s[j]);
            }
        }
    };
    
    // swap()实现的两种原理：
    //1. 中间值
    int tmp = s[i];
    s[i] = s[j];
    s[j] = tmp;
    //2. 位运算：异或
    s[i] ^= s[j];
    s[j] ^= s[i];
    s[i] ^= s[j];
    ```

  
## 3.反转字符串||

- 题目：541.Reverse String ||

  给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。

  如果剩余字符少于 k 个，则将剩余字符全部反转。

  如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样

  ```
  Input: s = "abcdefg", k = 2
  Output: "bacdfeg"
  
  Input: s = "abcd", k = 2
  Output: "bacd"
  ```

- 解题：

  - 在遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。

  ```c++
  class Solution {
  public:
      string reverseStr(string s, int k) {
          for (int i = 0; i < s.size(); i += (2 * k)) {
              // 1. 每隔 2k 个字符的前 k 个字符进行反转
              // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
              if (i + k <= s.size()) {
                  reverse(s.begin() + i, s.begin() + i + k );
              } else {
                  // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
                  reverse(s.begin() + i, s.end());
              }
          }
          return s;
      }
  };
  ```


## 4.替换空格

- 题目：[剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

  请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

  ```
  输入：s = "We are happy."
  输出："We%20are%20happy."
  ```

- 解题

  1. 首先扩充数组到每个空格替换成"%20"之后的大小。
  2. 然后**从后向前**替换空格，也就是双指针法，
     - i指向新长度的末尾，j指向旧长度的末尾。
     - j指向字符，就就将字符填入i对应的位置
     - j指向空格，就将%20填入i

  好处：

  1. 不用申请新数组。
  2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

  ```c++
  class Solution {
  public:
      string replaceSpace(string s) {
          int count = 0; // 统计空格的个数
          int sOldSize = s.size();
          for (int i = 0; i < s.size(); i++) {
              if (s[i] == ' ') {
                  count++;
              }
          }
          // 扩充字符串s的大小，也就是每个空格替换成"%20"之后的大小
          s.resize(s.size() + count * 2);	//为什么%20三个字符，这里却乘2呢，因为本身空格就占1位。
          int sNewSize = s.size();
          // 从后先前将空格替换为"%20"
          for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i--, j--) {
              if (s[j] != ' ') {
                  s[i] = s[j];
              } else {
                  s[i] = '0';
                  s[i - 1] = '2';
                  s[i - 2] = '%';
                  i -= 2;
              }
          }
          return s;
      }
  };
  ```


## 5.翻转字符串里的单词

- 题目：151. Reverse Words in a String

  给定一个字符串，根据空格，反转单词（不是反转每个字符）

  字符串可能会包含行首行尾空格或者连续多个空格，这些空格都不要。

  ```
  Input: s = "  hello world  "
  Output: "world hello"
  ```

- 解题：

  思路：

  1. 移除多余空格
  2. 将整个字符串反转
  3. 将每个单词反转

  ```c++
  class Solution {
  public:
      void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []
          for (int i = start, j = end; i < j; i++, j--) {
              swap(s[i], s[j]);
          }
      }
  
      void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
          int slow = 0;   
          for (int i = 0; i < s.size(); ++i) { //
              if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
                  if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                  while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                      s[slow++] = s[i++];
                  }
              }
          }
          s.resize(slow); //slow的大小即为去除多余空格后的大小。
      }
  
      string reverseWords(string s) {
          removeExtraSpaces(s); 				// 1. 去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
          reverse(s, 0, s.size() - 1);		// 2. 反转整个字符串
          									// 3. 反转单个单词
          int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。
          for (int i = 0; i <= s.size(); ++i) {
              if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。
                  reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。
                  start = i + 1; //更新下一个单词的开始下标start
              }
          }
          return s;
      }
  };
  ```




## 6.左旋转字符串

- 题目：[剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

  字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

  ```
  输入: s = "abcdefg", k = 2
  输出: "cdefgab"
  ```

- 解题：

  - 申请额外的空间：

    ```c++
    class Solution {
    public:
        string reverseLeftWords(string s, int n) {
            string ans;
            for(int i=n;i<s.size();i++){
                ans.push_back(s[i]);
            }
            for(int i=0;i<n;i++){
                ans.push_back(s[i]);
            }
            return ans;
        }
    };
    ```

  - 不申请额外的空间：

    abcdefg

    1. 反转区间为前n的子串:bacdefg
    2. 反转区间为n到末尾的子串:bagfedc
    3. 反转整个字符串:cdefgab

    ```c++
    class Solution {
    public:
        string reverseLeftWords(string s, int n) {
            reverse(s.begin(), s.begin() + n);
            reverse(s.begin() + n, s.end());
            reverse(s.begin(), s.end());
            return s;
        }
    };
    ```

## 7.KMP算法

### 7.1 KMP算法：

在一个串中查找是否出现过另一个串，这是KMP的看家本领。

- **KMP名字由来**：

  因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP

- **KMP有什么用**：

  KMP主要应用在字符串匹配上，主要思想是：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。

  所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。

- **前缀表**：

  - 什么是前缀表：
  
    KMP算法中的next数组就是一个前缀表（prefix table）。
  
  - 前缀表有什么用：
  
    前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。
  
    否则如果使用暴力匹配，发现不匹配时，就要从头匹配了。
  
  - 前缀表会记录什么？
  
    记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀
  
  - 前缀和后缀
  
    - 前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串
    - 后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串
    - **最长相等前后缀**：前缀表要求的就是相同前后缀的长度。
  
  - 为什么一定要用前缀表？
  
    前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。
  
- **如何计算前缀表**？
  
  以aabaaf为例：
  
  - 长度为前1个字符的子串`a`,
  
    前缀NULL,后缀NULL-->最长相同前后缀的长度=0
  
  - 长度为前2个字符的子串`aa`,
  
    前缀a,后缀a-->最长相同前后缀的长度=1, a
  
  - 长度为前3个字符的子串`aab`,
  
    前缀有a,aa,后缀b,ab-->最长相同前后缀的长度=0
  
  - 长度为前4个字符的子串`aaba`
  
    前缀有a,aa,aab，后缀有a,ba,aba-->最长相同前后缀的长度=1, a
  
  - 长度为前5个字符的子串`aabaa`
  
    前缀有a,aa,aab,aaba，后缀有a,aa,baa,abaa-->最长相同前后缀的长度=2, aa
  
    - 前缀表值为2，就意味着，当前位置`后缀:最后2个字母`和`前缀：开头的两个字母`相等
    - 所以如果在后缀后发现不匹配的字符，那我们就只需要移动到前缀后那一格重新开始匹配就行了、
    - 而前缀后那一格的下标，也就是这里前缀表值。
  
  - 长度为前6个字符的子串`aabaaf`
  
    前缀有a,aa,aab,aaba,aabaa 后缀有f,af,aaf,baaf,abaaf-->最长相同前后缀的长度=0
  
  如此得到aabaaf的前缀表:`[0,1,0,1,2,0]`
  
- **如何使用前缀表？**
  
  - 用法：
  
    在找到不匹配的位置，将模式串指针向前移动到前一个字符的前缀表值所在处。
  
  - 例子：
  
    在文本串`aabaabaafa`中找是否出现过`aabaaf`

      | 文本串下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 文本串     | a    | a    | b    | a    | a    | b    | a    | a    | f    | a    |
      | 模式串下标 | 0    | 1    | 2    | 3    | 4    | 5    |      |      |      |      |
      | 模式串     | a    | a    | b    | a    | a    | f    |      |      |      |      |
      | 前缀表     | 0    | 1    | 0    | 1    | 2    | 0    |      |      |      |      |

    - 在文本串和模式串指针一起指到5的时候，我们发现模式串是`f`和文本串`b`不符，然后看到模式串前一个字符`a`的前缀表值为2，所以将模式串指针从当前位置移动到下标为2处。
  
  - 为什么要前一个字符的前缀表的数值呢？
  
    因为要找前面字符串的最长相同的前缀和后缀。
  
- **时间复杂度分析**

  n为文本串长度，m为模式串长度，

  - 因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。

    所以整个KMP算法的时间复杂度是O(n+m)的。
  
  - 暴力的解法显而易见是O(n × m)，

​	所以KMP在字符串匹配中极大地提高了搜索的效率。

### 7.2 KMP的next数组构造

next数组就是前缀表，在实现的时候，有三种：

1. 将前缀表的值统一减一

   遇到冲突时，找前一位的前缀值并给其加1。

2. 右移一位，初始位置为-1，之后作为next数组。

   遇到冲突时，直接找当前位的前缀值。

3. 直接将前缀表作为next数组

   遇到冲突时，找前一位的前缀值。

- **构建next数组**

  构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步：

  1. 初始化
  2. 处理前后缀不相同的情况
  3. 处理前后缀相同的情况

  ```c++
  //********* 1. 前缀表统一减一的next数组构建 *********
  // 为什么这里next参数用指针引用呢？因为next是个数组，需要传递它的数组头地址
  void getNext(int* next, const string& s) {
      int j = -1;			// 这里的j是前缀表值-1，j指向前缀末尾位置，i指向后缀末尾位置
      next[0] = j;		// next[i]表示i处的前缀表值
      for(int i = 1; i < s.size(); i++) { // 注意i从1开始
          while (j >= 0 && s[i] != s[j + 1]) { // 前后缀只要不相等，j就不断向前回退
              j = next[j];					 // 直到j到起始位置，或找到前后缀相等的位置
          }
          if (s[i] == s[j + 1]) { // 如果遇到相同的前后缀，就前缀向后移动一位
              j++;			    // 此处的前缀表值也就等于++后的j，因为j表示了此时前后缀有j位相同的值
          }
          next[i] = j; // 将j（前缀的长度）赋给next[i]
      }
  }
  
  //********* 2. 前缀表不减一的next数组构建 *********
  void getNext(int* next, const string& s) {
      int j = 0;			// 这里的j是前缀表值
      next[0] = 0;		// next[i]表示i处的前缀表值
      for(int i = 1; i < s.size(); i++) {
          while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作
              j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了
          }
          if (s[i] == s[j]) {
              j++;
          }
          next[i] = j;
      }
  }
  ```

- **使用next数组来匹配**

  要在文本串s里找是否出现过模式串t

  - 对于统一减一的next数组

    ```c++
    // 下标j 指向模式串起始位置，i指向文本串起始位置。
    int j = -1; // 因为next数组里记录的起始位置为-1
    for (int i = 0; i < s.size(); i++) { // 注意i就从0开始
        while(j >= 0 && s[i] != t[j + 1]) { // 不匹配
            j = next[j]; // j 寻找之前匹配的位置
        }
        if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动
            j++; // i的增加在for循环里
        }
        if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t
            return (i - t.size() + 1);
        }
    }
    ```

  - 对于直接用前缀表的next数组

    ```c++
    for (int i = 0; i < haystack.size(); i++) {
        while(j > 0 && haystack[i] != needle[j]) {
            j = next[j - 1];
        }
        if (haystack[i] == needle[j]) {
            j++;
        }
        if (j == needle.size() ) {
            return (i - needle.size() + 1);
        }
    }
    ```

    

### 7.2 例题：找出字符串中第一个匹配项的下标

- 题目：28. Find the Index of the First Occurrence in a String

  给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。

  ```
  Input: haystack = "sadbutsad", needle = "sad"
  Output: 0
  
  Input: haystack = "leetcode", needle = "leeto"
  Output: -1
  ```

- 解题：

  利用KMP算法查看needle是否出现在haystack中

  直接使用前缀表构建这里的next数组

  ```c++
  class Solution {
  public:
      void getNext(int* next, const string& s) {
          int j = 0;
          next[0] = 0;
          for(int i = 1; i < s.size(); i++) {
              while (j > 0 && s[i] != s[j]) {
                  j = next[j - 1];
              }
              if (s[i] == s[j]) {
                  j++;
              }
              next[i] = j;
          }
      }
      int strStr(string haystack, string needle) {
          if (needle.size() == 0) {
              return 0;
          }
          int next[needle.size()];
          getNext(next, needle);
          int j = 0;
          for (int i = 0; i < haystack.size(); i++) {
              while(j > 0 && haystack[i] != needle[j]) {
                  j = next[j - 1];
              }
              if (haystack[i] == needle[j]) {
                  j++;
              }
              if (j == needle.size() ) {
                  return (i - needle.size() + 1);
              }
          }
          return -1;
      }
  };
  ```


## 8.重复的子字符串

- 题目：459. Repeated Substring Pattern

  给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

  ```
  Input: s = "abab"
  Output: true
  Explanation: It is the substring "ab" twice.
  
  Input: s = "aba"
  Output: false
  ```

- 解题

  - **暴力解法**：

    一个for循环找子串，嵌套一个for循环判断子串是否能重复构成字符串

    ```c++
    class Solution {
    public:
        bool repeatedSubstringPattern(string s) {
            int n = s.size();
            for (int i = 1; i * 2 <= n; ++i) {	// i表示子串的长度
                if (n % i == 0) {				// 字符串s的长度，一定是子串长度的倍数
                    bool match = true;
                    for (int j = i; j < n; ++j) {	// 判断是否是可以重复构成
                        if (s[j] != s[j - i]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) {
                        return true;
                    }
                }
            }
            return false;
        }
    };
    ```

    时间：$o(n^2)$

  - **移动匹配法**：

    判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。

    在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

    ```c++
    class Solution {
    public:
        bool repeatedSubstringPattern(string s) {
            string t = s + s;
            t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾
            if (t.find(s) != std::string::npos) return true; // r
            return false;
        }
    };
    ```

    时间:$o(m+n)$

  - **KMP法**：

    相比于用语言自带的find()方法，KMP方法可以更高效的实现找到是否存在另一个字符串。

    ```c++
    class Solution {
    public:
        void getNext (int* next, const string& s){
            next[0] = 0;
            int j = 0;
            for(int i = 1;i < s.size(); i++){
                while(j > 0 && s[i] != s[j]) {
                    j = next[j - 1];
                }
                if(s[i] == s[j]) {
                    j++;
                }
                next[i] = j;
            }
        }
        bool repeatedSubstringPattern (string s) {
            if (s.size() == 0) {
                return false;
            }
            int next[s.size()];
            getNext(next, s);
            int len = s.size();
            if (next[len - 1] != 0 && len % (len - (next[len - 1] )) == 0) {
                return true;
            }
            return false;
        }
    };
    ```

  ## 9.总结：

  主要考察有：

  1. 双指针法：

     很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。

  2. 反转系列：

     - 当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章
     - 也可以 先整体反转再局部反转 或者 先局部反转再整体反转

  3. KMP：

     见7

# 五、双指针法

## 1.理论基础

- 双指针法并不隶属于某一种数据结构，但数组，链表，字符串都会用到双指针法

## 2. 移除元素

- 题目：27:Remove Element

  给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

  不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

  元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

  示例：

  ```
  输入：nums = [3,2,2,3], val = 3
  输出：2, nums = [2,2]
  解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
  
  输入：nums = [0,1,2,2,3,0,4,2], val = 2
  输出：5, nums = [0,1,4,0,3]
  解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
  ```

- 题解

  - 暴力方法：
  
    用2个for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。将val值移到数组的最后面。
  
    时间复杂度：O(n^2)
  
    ```c++
    class Solution {
    public:
        int removeElement(vector<int>& nums, int val) {
            int size = nums.size();
            for(int i=0;i<size;i++){
                if(nums[i]==val){
                    for(int j=i;j<size;j++){
                        nums[i]=nums[j];
                    }
                    i--;	// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                    size--;	// 此时数组的大小-1
                }
            }
            return size;
        }
    };
    ```
  
  - 双指针法：
  
    通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。
  
    核心思想就是：慢指针指向要处理的val值。快指针遍历整个数组，将不是val的值覆盖掉慢指针指向的val值。
  
    时间复杂度：O(n)。空间复杂度：O(1)
  
    ```c++
    class Solution {
    public:
        int removeElement(vector<int>& nums, int val) {
            int slowindex = 0;
            for(int fastindex=0;fastindex < nums.size(); fastindex++){
                // 如果不是val值，两个指针会一起往前进。
    			// 如果是val值，快指针移到下一个，慢指针仍指向val值。
                // 直到快指针移到下一个不是val值的地方，然后慢指针指向的val值会被该值覆盖掉。
                // 最后2个指针再往前移动处理下一个val值。
                if(val != nums[fastindex]){
                    nums[slowindex++]=nums[fastindex];
                }
            }
            return slowindex;
        }
    };
    ```
  
  - 类似题：
  
    - 26.删除排序数组中的重复项
    - 283.移动零
    - 844.比较含退格的字符串
    - 977.有序数组的平方
  
  

# 六、栈与队列

## 1.理论基础

- 队列queue是先进先出，栈stack是先进后出。

- **栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。
  
  定义一个栈：`stack<int> xxx`
  
  - 栈的底层实现可以是容器vector，deque，list 
  - 栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也**不提供迭代器(iterator)**。
  - STL有3个普遍版本：HP STL, P.J.Plauger STL,和SGL STL
    -  知道了使用版本，才知道对应的底层实现。
  - 我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈和队列的底层结构
    - SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。
  - deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。
  - 如果不想用dqeque作为底层实现，也可以指定其他底层实现：
    - 指定vector为栈的底层实现：`std::stack<int, std::vector<int> > third;`
    - 指定list 为队列的底层实现：`std::queue<int, std::list<int>> third; `
  
- **SGI STL中 队列底层实现缺省情况下一样使用deque实现的。**STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。
  
  [deque](https://en.cppreference.com/w/cpp/container/deque): double-ended queue
  
  定义一个队列：`queue<int> xxx`
  
  - 和栈一样不允许有遍历行为，**不提供迭代器**

- 二叉树使用什么遍历顺序
  - 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
  - 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。
  - 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

## 2.用栈实现队列

- 题目 232:Implement Queue using Stacks

  实现 MyQueue 类：

  - void push(int x) 将元素 x 推到队列的末尾
    int pop() 从队列的开头移除并返回元素
    int peek() 返回队列开头的元素
    boolean empty() 如果队列为空，返回 true ；否则，返回 false

  示例

  ```
  输入：
  ["MyQueue", "push", "push", "peek", "pop", "empty"]
  [[], [1], [2], [], [], []]
  输出：
  [null, null, null, 1, 1, false]
  ```

- 题解

  用一个栈来模拟队列的功能是不现实的，必须用1个输入栈1个输出栈来模拟。

  - 在push数据时：把数据放入输入栈
  - 在pop时：
    - 如果输出栈为空，就先把输入栈元素先全导入输出栈，然后从输出栈弹出数据
    - 如果输出栈不为空，直接从输出弹出数据
  
  ```c++
  class MyQueue {
  private:
      stack<int> stIn;
      stack<int> stOut;
  public:
      MyQueue() {
  
      }
      //在push数据的时候，只要数据放进输入栈就好
      void push(int x) {
          stIn.push(x);
      }
      //输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。
      int pop() {
          if(stOut.empty()){
              while(!stIn.empty()){
                  stOut.push(stIn.top());           
                  stIn.pop();
              }
          }
          int result = stOut.top();
          stOut.pop();
          return result;
      }
      // 区别于pop就是头元素不删除
      int peek() {
          if(stOut.empty()){
              while(!stIn.empty()){
                  stOut.push(stIn.top());           
                  stIn.pop();
              }
          }
          int result = stOut.top();
          return result;
      }
      // 2个栈都是空的，那队列就是空的
      bool empty() {
          if(stOut.empty()&&stIn.empty())
              return true;
          else
              return false;
      }
  };
  
  ```
  

## 3.用队列实现栈

- 题目：225. Implement Stack using Queues

  使用队列实现栈的下列操作：

  - push(x) -- 元素 x 入栈
  - pop() -- 移除栈顶元素
  - top() -- 获取栈顶元素
  - empty() -- 返回栈是否为空

- 解题：

  - 用两个队列来模拟栈

    - 输入：正常输入到第一个队列
    - 输出：先将除最后一个元素外的所有元素，移动到第二个队列，然后第一个队列输出最后的那个元素

    ```c++
    class MyStack {
    public:
        queue<int> que1;
        queue<int> que2; // 辅助队列，用来备份
        /** Initialize your data structure here. */
        MyStack() {
    
        }
    
        /** Push element x onto stack. */
        void push(int x) {
            que1.push(x);
        }
    
        /** Removes the element on top of the stack and returns that element. */
        int pop() {
            int size = que1.size();
            size--;
            while (size--) { // 将que1 导入que2，但要留下最后一个元素
                que2.push(que1.front());
                que1.pop();
            }
    
            int result = que1.front(); // 留下的最后一个元素就是要返回的值
            que1.pop();
            que1 = que2;            // 再将que2赋值给que1
            while (!que2.empty()) { // 清空que2
                que2.pop();
            }
            return result;
        }
    
        /** Get the top element. */
        int top() {
            return que1.back();
        }
    
        /** Returns whether the stack is empty. */
        bool empty() {
            return que1.empty();
        }
    };
    ```

    

  - 用一个队列来模拟栈

    - 输入：正常输入到队列
    - 输出：只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。

    ```c++
    class MyStack {
    public:
        queue<int> que;
        /** Initialize your data structure here. */
        MyStack() {
    
        }
        /** Push element x onto stack. */
        void push(int x) {
            que.push(x);
        }
        /** Removes the element on top of the stack and returns that element. */
        int pop() {
            int size = que.size();
            while (--size) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
                que.push(que.front());
                que.pop();
            }
            int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
            que.pop();
            return result;
        }
    
        /** Get the top element. */
        int top() {
            return que.back();
        }
    
        /** Returns whether the stack is empty. */
        bool empty() {
            return que.empty();
        }
    };
    ```

    

## 4.有效的括号

- 题目: 20. Valid Parentheses

  给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

  有效字符串需满足：

  - 左括号必须用相同类型的右括号闭合。
  - 左括号必须以正确的顺序闭合。
  - 注意空字符串可被认为是有效字符串。

  ```
  Input: s = "()[]{}"
  Output: true
  
  Input: s = "(]"
  Output: false
  ```

- 解题

  **括号匹配是使用栈解决的经典问题。**

  1. 遍历数组，识别到左括号时，将对应的右括号入栈
  2. 识别到右括号时，栈头应该就是该右括号，否则返回错误
  3. 最后遍历完成，若为空栈，就返回正确。

  ```c++
  class Solution {
  public:
      bool isValid(string s) {
          stack<char> sta;
          for(int i=0; i<s.size();i++){		// 1. 遍历数组，识别到左括号时，将对应的右括号入栈
              if(s[i]=='(') sta.push(')');
              else if(s[i]=='[') sta.push(']');
              else if(s[i]=='{') sta.push('}');
              else{
                  if(sta.empty()!=true && s[i]==sta.top()) sta.pop();	// 2. 识别到右括号时，栈头应该就是该右括号，否则返回错误
                  else return false;
              }
          }
          if(sta.empty()==true) return true;	// 3. 后遍历完成，若为空栈，就返回正确。
          else return false;
      }
  };
  ```


## 5.删除字符中的所有相邻重复项

- 题目：1047. Remove All Adjacent Duplicates In String

  给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

  在 S 上反复执行重复项删除操作，直到无法继续删除。

  在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

  ```
  输入："abbaca"
  输出："ca"
  解释：例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
  ```

- 解题：

  1. 遍历字符串，将字符存入栈中
  2. 如果栈头和字符串的字符相同，就将该字符从栈中移出

  ```c++
  class Solution {
  public:
      string removeDuplicates(string S) {
          stack<char> st;
          for (char s : S) {
              // 一定要先判断栈是否为空，否则会地址错误
              if (st.empty() || s != st.top()) {
                  st.push(s);
              } else {
                  st.pop(); // s 与 st.top()相等的情况
              }
          }
          string result = "";
          while (!st.empty()) { // 将栈中元素放到result字符串汇总
              result += st.top();
              st.pop();
          }
          reverse (result.begin(), result.end()); // 此时字符串需要反转一下
          return result;
  
      }
  };
  ```

## 6.逆波兰表达式求值

- 题目：150. Evaluate Reverse Polish Notation

  根据[逆波兰表示法](https://en.wikipedia.org/wiki/Reverse_Polish_notation)，求表达式的值。有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

  ```
  Input: tokens = ["2","1","+","3","*"]
  Output: 9
  Explanation: ((2 + 1) * 3) = 9
  
  Input: tokens = ["4","13","5","/","+"]
  Output: 6
  Explanation: (4 + (13 / 5)) = 6
  ```

- 解题：

  用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。

  ```c++
  class Solution {
  public:
      int evalRPN(vector<string>& tokens) {
          stack<int> sta;
          for(string s: tokens){
              if(s=="+" || s=="-" || s=="*" || s=="/"){
                  int num1 = sta.top();
                  sta.pop();
                  int num2 = sta.top();
                  sta.pop();
                  if(s=="+") sta.push(num2+num1);
                  if(s=="-") sta.push(num2-num1);
                  if(s=="*") sta.push(num2*num1);
                  if(s=="/") sta.push(num2/num1);
              }
              else{
                  sta.push(stoi(s));
              }
          }
          return sta.top();
      }
  };
  ```


## 7.滑动窗口最大值

- 题目：239. Sliding Window Maximum

  给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

  返回滑动窗口中的最大值。

  ```
  Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
  Output: [3,3,5,5,6,7]
  Explanation: 
  Window position                Max
  ---------------               -----
  [1  3  -1] -3  5  3  6  7       3
   1 [3  -1  -3] 5  3  6  7       3
   1  3 [-1  -3  5] 3  6  7       5
   1  3  -1 [-3  5  3] 6  7       5
   1  3  -1  -3 [5  3  6] 7       6
   1  3  -1  -3  5 [3  6  7]      7
  ```

- 解题

  - 暴力方法，遍历一遍的过程中每次从窗口中再找到最大的数值，这样很明显是O(n × k)的算法。

  - 这是使用单调队列的经典题目。

    - 这个队列应该长这个样子：

      ```++
      class MyQueue {
      public:
          void pop(int value) {
          }
          void push(int value) {
          }
          int front() {
              return que.front();
          }
      };
      ```

      每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。

    - 队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。

    - 单调队列: 即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来实现一个单调队列

      - 实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。
      - 比如元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。

    -  因为只保留递减的元素，比如上面的{2, 3, 5, 1 ,4}，就需要这个数据结构支持两端都可以删除元素(左端的2、3和右端的1)。显然队列queue和栈都不满足，而实现他们的底层容器[std::deque](https://en.cppreference.com/w/cpp/container/deque)双端队列，可以满足这个需求。

  ```c++
  class Solution {
  private:
      //先实现我们的单调队列
      class MyQueue { //单调队列（从大到小）
      public:
          deque<int> que; // 使用deque来实现单调队列
          // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
          // 同时pop之前判断队列当前是否为空。
          void pop(int value) {
              if (!que.empty() && value == que.front()) {
                  que.pop_front();
              }
          }
          // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
          // 这样就保持了队列里的数值是单调从大到小的了。
          void push(int value) {
              while (!que.empty() && value > que.back()) {
                  que.pop_back();
              }
              que.push_back(value);
  
          }
          // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
          int front() {
              return que.front();
          }
      };
  public:
      vector<int> maxSlidingWindow(vector<int>& nums, int k) {
          MyQueue que;
          vector<int> result;
          for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
              que.push(nums[i]);
          }
          result.push_back(que.front()); // result 记录前k的元素的最大值
          for (int i = k; i < nums.size(); i++) {
              que.pop(nums[i - k]); // 滑动窗口移除最前面元素
              que.push(nums[i]); // 滑动窗口前加入最后面的元素
              result.push_back(que.front()); // 记录对应的最大值
          }
          return result;
      }
  };
  ```


## 8.前K个高频元素

- 题目：347. Top K Frequent Elements

  给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

  ```
  Input: nums = [1,1,1,2,2,3], k = 2
  Output: [1,2]
  
  Input: nums = [1], k = 1
  Output: [1]
  ```

- 解题：

  1. 统计元素出现频率：map

  2. 对频率排序：优先级队列

     - **优先级队列**：就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。
     - 缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。
     - **堆**：堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。

     不使用快排而用优先级队列的原因：使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。

  3. 找出前K个高频元素

     我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。

  ```c++
  // 时间复杂度：O(nlogk)
  // 空间复杂度：O(n)
  class Solution {
  public:
      // 小顶堆定义规则
      // 这里有2个值，不能直接用less<int>表示小顶堆，greater<int>表示大顶堆，因为我们要比较的是键值对的值，即第二个元素。
      class mycomparison {
      public:
          bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
              return lhs.second > rhs.second;
          }
      };
      vector<int> topKFrequent(vector<int>& nums, int k) {
          // 1. 要统计元素出现频率
          unordered_map<int, int> map; // map<nums[i],对应出现的次数>
          for (int i = 0; i < nums.size(); i++) {
              map[nums[i]]++;
          }
  
          // 2. 对频率排序
          // 定义一个小顶堆，大小为k
          // 使用std::priority_queuey优先队列，变量1：存储元素的类型，变量2存储这些元素的容器，变量3用于定义大顶堆/小顶堆的比较规则。
          // std::pair是一个模板类，用于把2个不同/相同类型的量组合成一个量
          // 因为map类型是<int,int>，所以优先队列里要存的也是这个类型
          priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
  
          // 用固定大小为k的小顶堆，扫面所有频率的数值
          for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
              pri_que.push(*it);	//将数字-频率传入优先队列
              if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k，因为小顶堆的头是最小元素，所以弹出后的就是我们要的频率高的。
                  pri_que.pop();
              }
          }
  
          // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
          vector<int> result(k);
          for (int i = k - 1; i >= 0; i--) {
              result[i] = pri_que.top().first;
              pri_que.pop();
          }
          return result;
      }
  };
  ```

  

  

  

# 七、二叉树

## 1.理论基础

- 二叉树的种类
  - 满二叉树Full Binary Tree：如果一棵二叉树只有度为0的结点（国外定义，国内度必须是2）和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
    - 度：即有几个子节点
    - 深度为k，有2^k-1个节点
    
    ![image-20230515224258664](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202305152242697.png)
    
  - 完全二叉树Complete Binary Tree：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层**最左边**的若干位置。
    - 堆就是一棵完全二叉树，同时保证父子节点的顺序关系
    
    ![image-20230515224358204](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202305152243230.png)
    
  - 二叉搜索树Binary Search Tree：二叉搜索树是一个有有序数值的有序树
    - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
    - 它的左、右子树也分别为二叉排序树
    
    ![image-20230515224426071](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202305152244096.png)
    
  - 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
    - C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树。所以map、set的增删操作时间时间复杂度是logn
      - unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。
    
    ![image-20230515224449588](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202305152244613.png)
  
- 二叉树的存储方式

  - 二叉树可以链式存储，也可以顺序存储。链式存储方式就用指针， 顺序存储的方式就是用数组。
  - 如果用数组来存储：如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2
  - 一般使用链式存储二叉树

- 二叉树的遍历方式

  - 深度优先遍历：使用递归的方式或借助栈使用非递归的方式来实现

    **这里前中后，其实指的就是中间节点的遍历顺序**

    - 前序遍历（递归法，迭代法）中间节点的顺序：中左右
    - 中序遍历（递归法，迭代法）中间节点的顺序：左中右
    - 后序遍历（递归法，迭代法）中间节点的顺序：左右中

  - 广度优先遍历：使用队列来实现

    - 层次遍历（迭代法）

- 二叉树的定义：

  ```c++
  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };
  ```

## 2.二叉树的递归遍历

### 2.1 递归的基础

每次写递归，要遵从三要素：**二叉树递归的三部曲**

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

### 2.2 前序遍历

- 题目：144. Binary Tree Preorder Traversal

  给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

  ```
  Input: root = [1,null,2,3]
  Output: [1,2,3]
  ```

- 解题：

  ```c++
  class Solution {
  public:
      // 1. 确定递归函数的参数和返回值
      void recursion(TreeNode* cur, vector<int>& vec) {
          // 2. 确定终止条件
          if (cur == NULL) return;
          // 3. 确定单层递归的逻辑：前序遍历：中->左->右
          vec.push_back(cur->val);    // 中
          recursion(cur->left, vec);  // 左
          recursion(cur->right, vec); // 右
      }
      vector<int> preorderTraversal(TreeNode* root) {
          vector<int> result;
          recursion(root, result);
          return result;
      }
  };
  ```

### 2.3 中序遍历

- 题目：94. Binary Tree Inorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **中序遍历** 

  ```
  Input: root = [1,null,2,3]
  Output: [1,3,2]
  ```

- 解题：

  ```c++
  class Solution {
  public:
      // 1. 确定递归函数的参数和返回值
      void recursion(TreeNode* cur, vector<int>* result){
          // 2. 确定终止条件
          if(cur==NULL) return;
          // 3. 确定单层递归的逻辑：前序遍历：左->中->右
          recursion(cur->left,result);
          result->push_back(cur->val);
          recursion(cur->right,result);
      }
      vector<int> inorderTraversal(TreeNode* root) {
          vector<int> result;
          // 对比2.2，如果参数用的指针不是索引的话，这里要把地址传进去
          recursion(root, &result);
          return result;
      }
  };
  ```

### 2.4 后序遍历

- 题目：145. Binary Tree Postorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

  ```
  Input: root = [1,null,2,3]
  Output: [3,2,1]
  ```

- 解题：

  ```c++
  class Solution {
  public:
      // 1. 确定递归函数的参数和返回值
      void recursion(TreeNode* cur, vector<int>* result){
          // 2. 确定终止条件
          if(cur==NULL) return;
          // 3. 确定单层递归的逻辑：前序遍历：左->右->中
          recursion(cur->left, result);
          recursion(cur->right,result);
          result->push_back(cur->val);
      }
      vector<int> postorderTraversal(TreeNode* root) {
          vector<int> result;
          // 对比2.2，如果参数用的指针，这里要把地址传进去
          recursion(root,&result);
          return result;
      }
  };
  ```

## 3.二叉树的迭代遍历

用迭代法(非递归方式，用**栈**)来实现2中的二叉树前中后序遍历。

**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

所以下面用栈来实现二叉树的前后中序遍历。我们会做2个操作：

1. **处理：将元素放进result数组中**
2. **访问：遍历节点**

### 3.1 前序遍历

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。

为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。

- 题目：144. Binary Tree Preorder Traversal

  给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

  ```
  Input: root = [1,null,2,3]
  Output: [1,2,3]
  ```

- 解题：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
   class Solution {
  public:
      vector<int> preorderTraversal(TreeNode* root) {
          stack<TreeNode*> st;
          vector<int> result;
          if (root == NULL) return result;
          st.push(root);
          while (!st.empty()) {
              // 1. 处理：将元素放进result数组中
              TreeNode* node = st.top();                       // 中
              st.pop();
              result.push_back(node->val);					
              // 2. 访问：遍历节点
              if (node->right) st.push(node->right);           // 右（空节点不入栈）
              if (node->left) st.push(node->left);             // 左（空节点不入栈）
          }
          return result;
      }
  };
  ```

### 3.2 中序遍历

刚刚写的前序遍历的代码不能和中序遍历通用，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**

那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

- 题目：94. Binary Tree Inorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **中序遍历** 

  ```
  Input: root = [1,null,2,3]
  Output: [1,3,2]
  ```

- 解题：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> inorderTraversal(TreeNode* root) {
          vector<int> result;
          stack<TreeNode*> st;
          TreeNode* cur = root;
          while (cur != NULL || !st.empty()) {
              if (cur != NULL) { // 指针来访问节点，访问到最底层
                  st.push(cur); // 将访问的节点放进栈
                  cur = cur->left;                // 左
              } else {
                  cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                  st.pop();
                  result.push_back(cur->val);     // 中
                  cur = cur->right;               // 右
              }
          }
          return result;
      }
  };
  
  ```

### 3.3 后序遍历

先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了：

![前序到后序](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/20200808200338924.png)

- 题目：145. Binary Tree Postorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

  ```
  Input: root = [1,null,2,3]
  Output: [3,2,1]
  ```

- 解题：

  ```c++
  class Solution {
  public:
      vector<int> postorderTraversal(TreeNode* root) {
          stack<TreeNode*> st;
          vector<int> result;
          if (root == NULL) return result;
          st.push(root);
          while (!st.empty()) {
              TreeNode* node = st.top();
              st.pop();
              result.push_back(node->val);
              if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
              if (node->right) st.push(node->right); // 空节点不入栈
          }
          reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
          return result;
      }
  };
  ```

## 4.二叉树的统一迭代法

在3中，先中后序的实现无法保持统一的风格，因为**无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况**。

为了实现统一的风格：**就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点(中)放入栈之后，紧接着放入一个空指针作为标记。** 

之后就可以在遍历的时候判断是不是NULL,如果是NULL就执行从栈取出元素放入结果集的操作。

### 4.1 前序遍历

- 题目：144. Binary Tree Preorder Traversal

  给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

  ```
  Input: root = [1,null,2,3]
  Output: [1,2,3]
  ```

- 解题:

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> preorderTraversal(TreeNode* root) {
          stack<TreeNode*> st;
          vector<int> result;
          if (root != NULL) st.push(root);
          while(!st.empty()){
              TreeNode* node = st.top();
              if(node != NULL){
                  // 前序遍历：中->左->右
                  // 注意，由于栈先进后出的特性，如栈顺序为右->左->中
                  st.pop();	// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                  if(node->right) st.push(node->right);// 添加右节点（空节点不入栈）
                  if(node->left) st.push(node->left); // 添加左节点（空节点不入栈）
                  st.push(node);	// 添加中节点
                  st.push(NULL);	// 中节点访问过，但是还没有处理，加入空节点做为标记。
              }
              else{	// 只有遇到空节点的时候，才将下一个节点(中)放进结果集
                  st.pop();	// 将空节点弹出
                  node = st.top();	// 取出中节点
                  result.push_back(node->val);// 加入到结果集
                  st.pop();	// 删除被取出的中节点
              }
          }
          return result;
      }
  };
  ```

  

### 4.2 中序遍历

- 题目：94. Binary Tree Inorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **中序遍历** 

  ```
  Input: root = [1,null,2,3]
  Output: [1,3,2]
  ```

- 解题：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> inorderTraversal(TreeNode* root) {
          vector<int> result;
          stack<TreeNode*> st;
          if(root!=NULL) st.push(root);
          while(!st.empty()){
              TreeNode* node = st.top();
              if(node!=NULL){ 
                  //和4.1变得只是从中->左->右变成了左->中->右
                  //注意，由于栈先进后出的特性，如栈顺序为右->中->左
                  st.pop();
                  if(node->right) st.push(node->right);
                  st.push(node);
                  st.push(NULL);
                  if(node->left) st.push(node->left);
              }else{
                  st.pop();
                  node = st.top();
                  result.push_back(node->val);
                  st.pop();
              }
          }
          return result;
      }
  };
  ```

### 4.3 后序遍历

- 题目：145. Binary Tree Postorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

  ```
  Input: root = [1,null,2,3]
  Output: [3,2,1]
  ```

- 解题:

  ```c++
  class Solution {
  public:
      vector<int> postorderTraversal(TreeNode* root) {
          vector<int> result;
          stack<TreeNode*> st;
          if(root!=NULL) st.push(root);
          while(!st.empty()){
              TreeNode* node = st.top();
              if(node!=NULL){ 
                  //和4.1变得只是从中->左->右变成了左->右->中
                  //注意，由于栈先进后出的特性，如栈顺序为中->右->左
                  st.pop();
                  st.push(node);
                  st.push(NULL);
                  if(node->right) st.push(node->right);
                  if(node->left) st.push(node->left);
              }else{
                  st.pop();
                  node = st.top();
                  result.push_back(node->val);
                  st.pop();
              }
          }
          return result;
      }
  };
  ```


## 5.二叉树的层序遍历

2,3,4都是深度优先遍历，这里是另一种遍历方式：层序遍历。

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

**而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**、

除了用队列外，也可以向2一样用递归的形式来完成层序遍历

### 5.1 二叉树的层序遍历

- 题目102.Binary Tree Level Order Traversal

  给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/tree1.jpg)

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: [[3],
  		 [9,20],
  		 [15,7]]
  ```

- 解题：

  1. 用队列来实现

     ```c++
     /**
      * Definition for a binary tree node.
      * struct TreeNode {
      *     int val;
      *     TreeNode *left;
      *     TreeNode *right;
      *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
      *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
      *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
      * };
      */
     class Solution {
     public:
         vector<vector<int>> levelOrder(TreeNode* root) {
             queue<TreeNode*> que;
             if (root != NULL) que.push(root);
             vector<vector<int>> result;
             while (!que.empty()) {
                 int size = que.size();
                 vector<int> vec;
                 // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
                 // 遍历某一行的每个节点
                 for (int i = 0; i < size; i++) {
                     TreeNode* node = que.front();
                     que.pop();
                     vec.push_back(node->val);
                     if (node->left) que.push(node->left);
                     if (node->right) que.push(node->right);
                 }
                 result.push_back(vec);
             }
             return result;
         }
     };
     ```
  
  2. 递归法
  
     ```c++
     class Solution {
     public:
         void order(TreeNode* cur, vector<vector<int>>& result, int depth)
         {
             if (cur == nullptr) return;
             // 每当到达新的一层，就往result这个2维数组里加入一个新的1维数组
             if (result.size() == depth) result.push_back(vector<int>());
             // 往对应的一维数组里添加元素
             result[depth].push_back(cur->val);
             // 递归下去往新的一层里加元素
             order(cur->left, result, depth + 1);
             order(cur->right, result, depth + 1);
         }
         vector<vector<int>> levelOrder(TreeNode* root) {
             vector<vector<int>> result;
             int depth = 0;
             order(root, result, depth);
             return result;
         }
     };
     ```

### 5.2 二叉树的层次遍历 II

-  题目：107.Binary Tree Level Order Traversal II

  给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/tree1.jpg)
  
  ```c++
  class Solution {
  public:
      vector<vector<int>> levelOrderBottom(TreeNode* root) {
          queue<TreeNode*> que;
          if (root != NULL) que.push(root);
          vector<vector<int>> result;
          while (!que.empty()) {
              int size = que.size();
              vector<int> vec;
              for (int i = 0; i < size; i++) {
                  TreeNode* node = que.front();
                  que.pop();
                  vec.push_back(node->val);
                  if (node->left) que.push(node->left);
                  if (node->right) que.push(node->right);
              }
              result.push_back(vec);
          }
          reverse(result.begin(), result.end()); // 在这里反转一下数组即可
          return result;
  
      }
  };
  ```
  

### 5.3 二叉树的右试图

- 题目：199. Binary Tree Right Side View

  给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/tree.jpg)

  ```
  Input: root = [1,2,3,null,5,null,4]
  Output: [1,3,4]
  ```

- 解题：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> rightSideView(TreeNode* root) {
          vector<int> result;
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size = que.size();
              for(int i=0; i<size; i++){
                  TreeNode* node = que.front();
                  que.pop();
                  if(i==(size-1)) result.push_back(node->val);
                  if(node->left) que.push(node->left);
                  if(node->right) que.push(node->right);
              }
          }
          return result;
      }
  };
  ```

### 5.4 二叉树的层平均值

- 题目: 637. Average of Levels in Binary Tree

  给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/tree1.jpg)

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: [3.00000,14.50000,11.00000]
  Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
  Hence return [3, 14.5, 11].
  ```

- 解题

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<double> averageOfLevels(TreeNode* root) {
          vector<double> result;
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              double sum = 0;
              for(int i=0;i<size;i++){
                  TreeNode* node = que.front();
                  que.pop();
                  sum+=node->val;
                  if(node->left) que.push(node->left);
                  if(node->right) que.push(node->right);
              }
              result.push_back(sum/size);
          }
          return result;
      }
  };
  ```

### 5.5 N叉树的层序遍历

- 题目: 429. N-ary Tree Level Order Traversal

  给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/narytreeexample.png)

  ```
  Input: root = [1,null,3,2,4,null,5,6]
  Output: [[1],[3,2,4],[5,6]]
  ```

- 解题

  ```c++
  /*
  // Definition for a Node.
  class Node {
  public:
      int val;
      vector<Node*> children;
  
      Node() {}
  
      Node(int _val) {
          val = _val;
      }
  
      Node(int _val, vector<Node*> _children) {
          val = _val;
          children = _children;
      }
  };
  */
  
  class Solution {
  public:
      vector<vector<int>> levelOrder(Node* root) {
          queue<Node*> que;
          vector<vector<int>> result;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              vector<int> temp;
              for(int i=0;i<size;i++){
                  Node* current = que.front();
                  que.pop();
                  temp.push_back(current->val);
                  int size_children=current->children.size();
                  for(int j=0;j<size_children;j++){
                      que.push(current->children[j]);
                  }
              }
              result.push_back(temp);
          }
          return result;
      }
  };
  ```

### 5.6  在每个树行中找最大值

- 题目：515. Find Largest Value in Each Tree Row

  您需要在二叉树的每一行中找到最大的值。

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/largest_e1.jpg)

  ```
  Input: root = [1,3,2,5,3,null,9]
  Output: [1,3,9]
  ```

- 解题：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> largestValues(TreeNode* root) {
          vector<int> result;
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size = que.size();
              int max=INT_MIN;
              for(int i=0;i<size;i++){
                  TreeNode* current = que.front();
                  que.pop();
                  if(current->val > max) max=current->val;
                  if(current->left) que.push(current->left);
                  if(current->right) que.push(current->right);
              }
              result.push_back(max);
          }
          return result;
      }
  };
  ```

### 5.7 填充每个节点的下一个右侧节点指针

- 题目:116. Populating Next Right Pointers in Each Node

  给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

  ```
  struct Node {
    int val;
    Node *left;
    Node *right;
    Node *next;
  }
  ```

  填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

  初始状态下，所有 next 指针都被设置为 NULL。

  ![img](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202306071820022.png)

  ```
  输入：root = [1,2,3,4,5,6,7]
  输出：[1,#,2,3,#,4,5,6,7,#]
  解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
  ```

- 解题

  ```c++
  /*
  // Definition for a Node.
  class Node {
  public:
      int val;
      Node* left;
      Node* right;
      Node* next;
  
      Node() : val(0), left(NULL), right(NULL), next(NULL) {}
  
      Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}
  
      Node(int _val, Node* _left, Node* _right, Node* _next)
          : val(_val), left(_left), right(_right), next(_next) {}
  };
  */
  
  class Solution {
  public:
      Node* connect(Node* root) {
          queue<Node*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              Node* current;
              Node* previous;
              int size = que.size();
              for(int i=0; i<size; i++){
                  if(i==0){
                      previous = que.front();// 取出一层的头结点
                      que.pop();
                      current = previous;
                  }else{
                      current = que.front();
                      que.pop();
                      previous->next = current;// 本层前一个节点next指向本节点
                      previous = current;
                  }
                  if(current->left) que.push(current->left);
                  if(current->right) que.push(current->right);
              }
              current->next = NULL;// 本层最后一个节点指向NULLe
          }
          return root;
      }
  };
  ```

### 5.8 填充每个节点的下一个右侧节点指针II

- 题目：117. Populating Next Right Pointers in Each Node II

  ![img](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202306071929380.png)

  ```
  Input: root = [1,2,3,4,5,null,7]
  Output: [1,#,2,3,#,4,5,7,#]
  Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
  ```

- 解题：

  ```c++
  /*
  // Definition for a Node.
  class Node {
  public:
      int val;
      Node* left;
      Node* right;
      Node* next;
  
      Node() : val(0), left(NULL), right(NULL), next(NULL) {}
  
      Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}
  
      Node(int _val, Node* _left, Node* _right, Node* _next)
          : val(_val), left(_left), right(_right), next(_next) {}
  };
  */
  
  class Solution {
  public:
      Node* connect(Node* root) {
          queue<Node*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              Node* current;
              Node* previous;
              for(int i=0;i<size;i++){
                  if(i==0){
                      previous=que.front();
                      que.pop();
                      current = previous;
                  }else{
                      current = que.front();
                      que.pop();
                      previous->next=current;
                      previous=current;
                  }
                  if(current->left) que.push(current->left);
                  if(current->right) que.push(current->right);
              }
              current->next=NULL;
          }
          return root;
      }
  };
  ```

### 5.9 二叉树的最大深度

- 题目：104. Maximum Depth of Binary Tree

  给定一个二叉树，找出其最大深度。

  二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

  说明: 叶子节点是指没有子节点的节点。

  ![img](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202306071939623.jpeg)

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: 3
  ```

- 解题

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      int maxDepth(TreeNode* root) {
          int depth=0;
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              for(int i=0;i<size; i++){
                  TreeNode* node = que.front();
                  que.pop();
                  if(node->left) que.push(node->left);
                  if(node->right) que.push(node->right);
              }
              depth++;
          } 
          return depth;
      }
  };
  ```

- 也可以用递归的方法

  1. 确定递归函数的参数和返回值：
  2. 确定终止条件：
  3. 确定单层递归的逻辑：

  ```c++
  class solution {
  public:
      // 1. 确定递归函数的参数和返回值
      int getdepth(TreeNode* node) {
          // 2. 确定终止条件
          if (node == NULL) return 0;
          // 3. 确定单层递归的逻辑
          int leftdepth = getdepth(node->left);       // 左
          int rightdepth = getdepth(node->right);     // 右
          int depth = 1 + max(leftdepth, rightdepth); // 中
          return depth;
      }
      int maxDepth(TreeNode* root) {
          return getdepth(root);
      }
  };
  ```

  

### 5.10二叉树的最小深度

- 题目:111. Minimum Depth of Binary Tree

  **需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点**

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: 2
  ```

- 解题

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      int minDepth(TreeNode* root) {
          int depth=0;
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              depth++;
              for(int i=0;i<size; i++){
                  TreeNode* node = que.front();
                  que.pop();
                  if(node->left) que.push(node->left);
                  if(node->right) que.push(node->right);
                  if(!node->left && !node->right) return depth;
              }
              
          } 
          return depth;
      }
  };
  ```

- 递归法：

  1. 确定递归函数的参数和返回值：
  2. 确定终止条件：
  3. 确定单层递归的逻辑：

  ```c++
  class Solution {
  public:
      int getDepth(TreeNode* node) {
          if (node == NULL) return 0;
          int leftDepth = getDepth(node->left);           // 左
          int rightDepth = getDepth(node->right);         // 右
                                                          // 中
          // 当一个左子树为空，右不为空，这时并不是最低点
          if (node->left == NULL && node->right != NULL) { 
              return 1 + rightDepth;
          }   
          // 当一个右子树为空，左不为空，这时并不是最低点
          if (node->left != NULL && node->right == NULL) { 
              return 1 + leftDepth;
          }
          int result = 1 + min(leftDepth, rightDepth);
          return result;
      }
  
      int minDepth(TreeNode* root) {
          return getDepth(root);
      }
  };
  ```

  

## 6.反转二叉树

- 题目

  翻转一棵二叉树。

  ![img](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202306071959208.jpeg)

  ```
  Input: root = [4,2,7,1,3,6,9]
  Output: [4,7,2,9,6,3,1]
  ```

- 思路

  **只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果**

  **这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了**

  那么层序遍历可以不可以呢？**依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！**

### 6.1 递归法

- 递归三部曲：

  1. 确定递归函数的参数和返回值

     参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。

  2. 确定终止条件

     当前节点为空的时候，就返回

  3. 确定单层递归的逻辑

     因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树

- 解题

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      	// 1. 确定递归函数的参数和返回值
      TreeNode* invertTree(TreeNode* root) {
          // 2. 确定终止条件
          if(root==NULL) return root;
          // 3. 确定单层递归的逻辑
          swap(root->left,root->right); //中
          invertTree(root->left); //左
          invertTree(root->right); //右
          return root;
      }
  };
  ```

### 6.2 迭代法

- 深度优先遍历(栈)

  递归能做的，栈也都能做。

  ```c++
  // 前序遍历，迭代写法
  class Solution {
  public:
      TreeNode* invertTree(TreeNode* root) {
          if (root == NULL) return root;
          stack<TreeNode*> st;
          st.push(root);
          while(!st.empty()) {
              TreeNode* node = st.top();              // 中
              st.pop();
              swap(node->left, node->right);
              if(node->right) st.push(node->right);   // 右
              if(node->left) st.push(node->left);     // 左
          }
          return root;
      }
  };
  
  // 前序遍历，统一迭代方法
  class Solution {
  public:
      TreeNode* invertTree(TreeNode* root) {
          stack<TreeNode*> st;
          if (root != NULL) st.push(root);
          while (!st.empty()) {
              TreeNode* node = st.top();
              if (node != NULL) {
                  st.pop();
                  if (node->right) st.push(node->right);  // 右
                  if (node->left) st.push(node->left);    // 左
                  st.push(node);                          // 中
                  st.push(NULL);
              } else {
                  st.pop();
                  node = st.top();
                  st.pop();
                  swap(node->left, node->right);          // 节点处理逻辑
              }
          }
          return root;
      }
  };
  ```

- 广度优先遍历(队列)

  ```c++
  class Solution {
  public:
      TreeNode* invertTree(TreeNode* root) {
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              for(int i=0;i<size;i++){
                  TreeNode* node= que.front();
                  que.pop();
                  swap(node->left,node->right);
                  if(node->left) que.push(node->left);
                  if(node->right) que.push(node->right);
              }
          }
          return root;
      }
  };
  ```


## 7.对称二叉树

题目：101. Symmetric Tree

给定一个二叉树，检查它是否是镜像对称的。

```
Input: root = [1,2,2,3,4,4,3]
Output: true

Input: root = [1,2,2,null,3,null,3]
Output: false
```

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的。

### 7.1 递归法

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

**正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**都可以理解算是后序遍历。

- 递归三部曲：

  1. 确定递归函数的参数和返回值

     因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

     返回值自然是bool类型。

  2. 确定终止条件

     要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

     节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

     - 左节点为空，右节点不为空，不对称，return false

     - 左不为空，右为空，不对称 return false

     - 左右都为空，对称，返回true

     此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

     - 左右都不为空，比较节点数值，不相同就return false

     此时左右节点不为空，且数值也不相同的情况我们也处理了。

  3. 确定单层递归的逻辑

     此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

     - 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。

     - 比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。

     - 如果左右都对称就返回true ，有一侧不对称就返回false 。

- 代码：

  ```c++
  class Solution {
  public:
      // 1. 确定递归函数的参数和返回值
      bool compare(TreeNode* left, TreeNode* right) {
          // 2. 确定终止条件
          // 首先排除空节点的情况
          if (left == NULL && right != NULL) return false;
          else if (left != NULL && right == NULL) return false;
          else if (left == NULL && right == NULL) return true;
          // 排除了空节点，再排除数值不相同的情况
          else if (left->val != right->val) return false;
  		
          // 3. 确定单层递归的逻辑
          // 此时就是：左右节点都不为空，且数值相同的情况
          // 此时才做递归，做下一层的判断
          bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
          bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
          bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
          return isSame;
  
      }
      bool isSymmetric(TreeNode* root) {
          if (root == NULL) return true;
          return compare(root->left, root->right);
      }
  };
  ```

### 7.2 迭代法

下面用队列和栈，其实用任何数据结构来暂时保存节点值都是可以的。

- 使用队列

  ```c++
  class Solution {
  public:
  
      bool isSymmetric(TreeNode* root) {
          queue<TreeNode*> que1;
          queue<TreeNode*> que2;
          if(root==NULL) return true;
          que1.push(root->left);
          que2.push(root->right);
  
          while(!que1.empty() && !que2.empty()){
              int size = que1.size();
              for(int i=0;i<size;i++){
                  TreeNode* node1 = que1.front();
                  que1.pop();
                  TreeNode* node2 = que2.front();
                  que2.pop();
                  if (!node1 && !node2) {  // 左节点为空、右节点为空，此时说明是对称的
                      continue;
                  }
                  // 左右一个节点不为空，或者都不为空但数值不相同，返回false
                  if(!node1 || !node2 || node1->val != node2->val) return false;
                  // 注意下面不能加if(que->right)判断，否则NULL不会被记录
              	// 注意下面的加节点的顺序
                  que1.push(node1->left);
                  que1.push(node1->right);
                  que2.push(node2->right);
                  que2.push(node2->left);
              }
          }
          return true;
      }
  };
  ```

- 使用栈

  ```c++
  class Solution {
  public:
  
      bool isSymmetric(TreeNode* root) {
          stack<TreeNode*> st1;
          stack<TreeNode*> st2;
          if(root==NULL) return true;
          st1.push(root->left);
          st2.push(root->right);
  
          while(!st1.empty() && !st2.empty()){
              int size = st1.size();
              for(int i=0;i<size;i++){
                  TreeNode* node1 = st1.top();
                  st1.pop();
                  TreeNode* node2 = st2.top();
                  st2.pop();
                  if (!node1 && !node2) {  // 左节点为空、右节点为空，此时说明是对称的
                      continue;
                  }
                  if(!node1 || !node2 || node1->val != node2->val) return false;
                  st1.push(node1->left);
                  st1.push(node1->right);
                  st2.push(node2->right);
                  st2.push(node2->left);
              }
          }
          return true;
      }
  };
  ```

  

## 8.平衡二叉树

题目：110. Balanced Binary Tree

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: true
  ```

### 8.1 递归

1. 明确递归函数的参数和返回值

   参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。

   如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。

2. 明确终止条件

   递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0

3. 明确单层递归的逻辑

   如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。

   分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。

```c++
class Solution {
public:
    // 1. 明确递归函数的参数和返回值
    int getHeight(TreeNode* root){
        // 2. 明确终止条件
        if(root==NULL) return 0;
        int leftheight= getHeight(root->left);
        if(leftheight == -1) return -1;
        int rightheight = getHeight(root->right);
        if(rightheight == -1) return -1;
        // 3. 明确单层递归的逻辑
        if(abs(leftheight-rightheight)>1)
            return -1;
        else
            return 1+max(leftheight,rightheight);
    }
    bool isBalanced(TreeNode* root) {
        if(getHeight(root)==-1)
            return false;
        else
            return true;
    }
};
```

### 8.2 迭代(不推荐)

本题的迭代方式可以先定义一个函数，专门用来求高度。

这个函数通过栈模拟的后序遍历找每一个节点的高度（其实是通过求传入节点为根节点的最大深度来求的高度）

```c++
class Solution {
private:
    int getDepth(TreeNode* cur) {
        stack<TreeNode*> st;
        if (cur != NULL) st.push(cur);
        int depth = 0; // 记录深度
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);
                depth++;
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                depth--;
            }
            result = result > depth ? result : depth;
        }
        return result;
    }

public:
    bool isBalanced(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return true;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            if (abs(getDepth(node->left) - getDepth(node->right)) > 1) {
                return false;
            }
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return true;
    }
};
```

## 9.二叉树的所有路径

- 题目：257. Binary Tree Paths

  给定一个二叉树，返回所有从根节点到叶子节点的路径。

  说明: 叶子节点是指没有子节点的节点。

  ```
  Input: root = [1,2,3,null,5]
  Output: ["1->2->5","1->3"]
  ```

### 9.1 递归法

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      void findpath(TreeNode* root, vector<int>& path, vector<string>& result){
          path.push_back(root->val);	// 中，中为什么写在这里，因为最后一个节点也要加入到path中 
          if(root->left==NULL && root->right==NULL){
              string sPath;
              for(int i=0; i<path.size()-1;i++){
                  sPath += to_string(path[i]);
                  sPath += "->";
              }
              sPath += to_string(path[path.size()-1]);
              result.push_back(sPath);
              return;
          }
          // 回溯和递归是一一对应的，有一个递归，就要有一个回溯
          // 满足上面终止条件，path转到result后，回溯就是要把path的每个元素删除
          if(root->left) {	// 左 
              findpath(root->left, path, result);
              path.pop_back();// 回溯
          }
          if(root->right) {	// 右
              findpath(root->right, path, result);
              path.pop_back();// 回溯
          }
      }
      vector<string> binaryTreePaths(TreeNode* root) {
          vector<string> result;
          vector<int> path;
          if (root == NULL) return result;
          findpath(root,path,result);
          return result;
      }
  };
  ```

###   9.2 迭代法

区别于前面几题，只需要一个栈。这里除了模拟递归需要一个栈，同时还需要一个栈来存放对应的遍历路径。

```c++
class Solution {
public:
    vector<string> binaryTreePaths(TreeNode* root) {
        stack<TreeNode*> treeSt;// 保存树的遍历节点
        stack<string> pathSt;   // 保存遍历路径的节点
        vector<string> result;  // 保存最终路径集合
        if (root == NULL) return result;
        treeSt.push(root);
        pathSt.push(to_string(root->val));
        while (!treeSt.empty()) {
            TreeNode* node = treeSt.top(); treeSt.pop(); // 取出节点 中
            string path = pathSt.top();pathSt.pop();    // 取出该节点对应的路径
            if (node->left == NULL && node->right == NULL) { // 遇到叶子节点
                result.push_back(path);
            }
            if (node->right) { // 右
                treeSt.push(node->right);
                pathSt.push(path + "->" + to_string(node->right->val));
            }
            if (node->left) { // 左
                treeSt.push(node->left);
                pathSt.push(path + "->" + to_string(node->left->val));
            }
        }
        return result;
    }
};
```

## 10.左叶子之和

- 题目：404. Sum of Left Leaves

  计算给定二叉树的所有左叶子之和。

  左叶子定义：节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: 24
  Explanation: There are two left leaves in the binary tree, with values 9 and 15 respectively.
  ```

### 10.1 递归

```c++
class Solution {
public:
    // 1.确定递归函数的参数和返回值
    int sumOfLeftLeaves(TreeNode* root) {
        // 2.确定终止条件
        if (root == NULL) return 0;
		
        // 3.确定单层递归的逻辑
        int leftValue = sumOfLeftLeaves(root->left);    // 左
        if (root->left && !root->left->left && !root->left->right) { // 左子树就是一个左叶子的情况
            leftValue = root->left->val;
        }
        int rightValue = sumOfLeftLeaves(root->right);  // 右
        int sum = leftValue + rightValue;               // 中
        return sum;
    }
};
```

### 10.2 迭代

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root == NULL) 
            return 0;
        stack<TreeNode*> st;
        st.push(root);
        int result=0;
        while(!st.empty()){
            TreeNode* cur = st.top();
            st.pop();
            if(cur->left && !cur->left->left && !cur->left->right){
                result += cur->left->val;
            }
            if(cur->right) st.push(cur->right);
            if(cur->left) st.push(cur->left);
        }
        return result;
    }
};
```

## 11.找树左下角的值

给定一个二叉树，在树的最后一行找到最左边的值。

注意：**是最左边的值，不是左子节点的值**

```
Input: root = [1,2,3,4,null,5,6,null,null,7]
Output: 7

// 因为最后一行只有-1，所以最左边的值是-1
Input: root = [0, null, -1]
Output: -1
```

### 11.1 递归

```c++
class Solution {
public:
    int maxDepth = INT_MIN;	// 全局变量 记录最大深度
    int result;				// 全局变量 最大深度最左节点的数值
    void traversal(TreeNode* root, int depth){
        if(root->left==NULL && root->right==NULL){
            if(depth>maxDepth){
                maxDepth = depth;		 // 更新最大深度
                result = root->val;		 // 最大深度最左面的数值
            }
            return;
        }
        
        // 这里不需要处理：中
        
        if(root->left){	// 左
            depth++;
            traversal(root->left,depth);
            depth--;	// 回溯，深度减一
        }
        if(root->right){// 右
            depth++;
            traversal(root->right,depth);
            depth--;	// 回溯，深度减一
        }
        return;
    }
    int findBottomLeftValue(TreeNode* root) {
        traversal(root,0);
        return result;
    }
};
```

### 11.2 迭代

需要用层序遍历，因为

只需要记录最后一行第一个节点的数值就可以了。

```c++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> que;
        if(root!=NULL) que.push(root);
        int result=0;
        while(!que.empty()){
            int size = que.size();
            for(int i=0;i<size;i++){
                TreeNode* node = que.front();
                que.pop();
                // 只需要保存最后一行的第一个节点的数值
                if(i==0) result=node->val;
                if(node->left) que.push(node->left);
                if(node->right) que.push(node->right);
            }
        }
        return result;
    }
};
```

## 12.路径总和

- 题目:112. Path Sum

  给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

  说明: 叶子节点是指没有子节点的节点。

  示例: 给定如下二叉树，以及目标和 sum = 22，

  ```
  Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
  Output: true
  Explanation: The root-to-leaf path with the target sum is shown.
  ```

### 12.1 递归

```c++
class Solution {
public:
    // 1. 确定递归函数的参数和返回类型
    bool hasPathSum(TreeNode* root, int targetSum) {   
        if(root == NULL) return false;
        targetSum = targetSum - root->val;	// 递归，处理节点;
        // 2.确定终止条件
        if(!root->left && !root->right && targetSum==0) return true;
        if(!root->left && !root->right) return false;
		// 3.确定单层递归的逻辑
        if(root->left){
            if(hasPathSum(root->left,targetSum)) return true;
        }
        if(root->right){
            if(hasPathSum(root->right,targetSum)) return true;
        }
        targetSum += root->val;	// 回溯，撤销处理结果
        return false;
    }
};
```

### 12.2 迭代

**此时栈里一个元素不仅要记录该节点指针，还要记录从头结点到该节点的路径数值总和。**

c++就我们用pair结构来存放这个栈里的元素。

定义为：`pair<TreeNode*, int>` pair<节点指针，路径数值>

这个为栈里的一个元素。

```c++
class Solution {

public:
    bool hasPathSum(TreeNode* root, int sum) {
        if (root == NULL) return false;
        // 此时栈里要放的是pair<节点指针，路径数值>
        stack<pair<TreeNode*, int>> st;
        st.push(pair<TreeNode*, int>(root, root->val));
        while (!st.empty()) {
            pair<TreeNode*, int> node = st.top();
            st.pop();
            // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true
            if (!node.first->left && !node.first->right && sum == node.second) return true;

            // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->right) {
                st.push(pair<TreeNode*, int>(node.first->right, node.second + node.first->right->val));
            }

            // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来
            if (node.first->left) {
                st.push(pair<TreeNode*, int>(node.first->left, node.second + node.first->left->val));
            }
        }
        return false;
    }
};
```



### 12.3 113.路径总和ii

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

113.路径总和ii要遍历整个树，找到所有路径，所以递归函数不要返回值！

用迭代方式记录所有路径比较麻烦，也没有必要。所以用递归

```c++
class solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    // 递归函数不需要返回值，因为我们要遍历整个树
    void traversal(TreeNode* cur, int count) {
        if (!cur->left && !cur->right && count == 0) { // 遇到了叶子节点且找到了和为sum的路径
            result.push_back(path);
            return;
        }

        if (!cur->left && !cur->right) return ; // 遇到叶子节点而没有找到合适的边，直接返回

        if (cur->left) { // 左 （空节点不遍历）
            path.push_back(cur->left->val);
            count -= cur->left->val;
            traversal(cur->left, count);    // 递归
            count += cur->left->val;        // 回溯
            path.pop_back();                // 回溯
        }
        if (cur->right) { // 右 （空节点不遍历）
            path.push_back(cur->right->val);
            count -= cur->right->val;
            traversal(cur->right, count);   // 递归
            count += cur->right->val;       // 回溯
            path.pop_back();                // 回溯
        }
        return ;
    }

public:
    vector<vector<int>> pathSum(TreeNode* root, int sum) {
        result.clear();
        path.clear();
        if (root == NULL) return result;
        path.push_back(root->val); // 把根节点放进路径
        traversal(root, sum - root->val);
        return result;
    }
};
```

## 13.从中序与后序遍历序列构造二叉树

- 题目：106. Construct Binary Tree from Inorder and Postorder Traversal

  根据一棵树的中序遍历与后序遍历构造二叉树。

  注意: 你可以假设树中没有重复的元素。

  ```
  Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
  Output: [3,9,20,null,null,15,7]
  ```

- 解题：

  以 后序数组的最后一个元素为切割点，先切中序数组，根据中序数组，反过来再切后序数组，因为数组大小肯定是相同的。一层一层切下去，每次后序数组最后一个元素就是节点元素。

  说到一层一层切割，就应该想到了递归。

  - 第一步：如果数组大小为零的话，说明是空节点了。
  - 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
  - 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
  - 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
  - 第五步：切割后序数组，切成后序左数组和后序右数组
  - 第六步：递归处理左区间和右区间

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
          if (inorder.size() == 0 || postorder.size() == 0) return NULL;
          // 第一步：如果数组大小为零的话，说明是空节点了。
          if(postorder.size()==0) return NULL;
  		// 第二步：取后序数组最后一个元素作为节点元素。
          int rootvalue = postorder[postorder.size()-1];
          TreeNode* root = new TreeNode(rootvalue); // 末尾元素作为根节点
  		// 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
          int delimiter = 0;
          for(;delimiter<inorder.size();delimiter++){
              if(inorder[delimiter]==rootvalue) break;
          }
  		// 第四步：切割中序数组，得到 中序左数组和中序右数组
          vector<int> leftinorder(inorder.begin(),inorder.begin()+delimiter);  // 左闭右开区间：[0, delimiterIndex)
          vector<int> rightinorder(inorder.begin()+delimiter+1,inorder.end()); // [delimiterIndex + 1, end)
  		
          // 第五步：切割后序数组，得到 后序左数组和后序右数组
          postorder.resize(postorder.size()-1);	// postorder 舍弃末尾元素
          vector<int> leftpostorder(postorder.begin(),postorder.begin()+leftinorder.size());	// 左闭右开，注意这里使用了左中序数组大小作为切割点：[0, leftInorder.size)
          vector<int> rightpostorder(postorder.begin()+leftinorder.size(),postorder.end());	// [leftInorder.size(), end)
  		
          // 第六步：递归
          root->left = buildTree(leftinorder,leftpostorder);
          root->right = buildTree(rightinorder,rightpostorder);
  
          return root;
      }
  };
  ```

### 13.1 类似题：从前序与中序遍历序列构造二叉树

- 题目：105. Construct Binary Tree from Preorder and Inorder Traversal

  根据一棵树的前序遍历与中序遍历构造二叉树。

  注意: 你可以假设树中没有重复的元素。

  ```
  Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
  Output: [3,9,20,null,null,15,7]
  ```

- 解题

  思路和上面一致，只不过使用前序数组的第一个元素来做分割。

  ```c++
  class Solution {
  public:
      TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
          if(preorder.size()==0) return NULL;
          
          int rootvalue = preorder[0];
          TreeNode* root = new TreeNode(rootvalue);
  		
          // 用前序数组的第一个元素来分割
          int delimiter = 0;
          for(;delimiter<inorder.size();delimiter++){
              if(inorder[delimiter]==rootvalue) break;
          }
  
          vector<int> leftinorder(inorder.begin(),inorder.begin()+delimiter);
          vector<int> rightinorder(inorder.begin()+delimiter+1, inorder.end());
  
          vector<int> preorder_temp(preorder.begin()+1,preorder.end());
          vector<int> leftpreorder(preorder_temp.begin(), preorder_temp.begin()+leftinorder.size());
          vector<int> rightpreorder(preorder_temp.begin()+leftinorder.size(),preorder_temp.end());
  
          root->left = buildTree(leftpreorder,leftinorder);
          root->right = buildTree(rightpreorder,rightinorder);
  
          return root;
      }
  };
  ```

## 14.最大二叉树

- 题目：654. Maximum Binary Tree

  给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

  - 二叉树的根是数组中的最大元素。
  - 左子树是通过数组中最大值左边部分构造出的最大二叉树。
  - 右子树是通过数组中最大值右边部分构造出的最大二叉树。

  通过给定的数组构建最大二叉树，并且输出这个树的根节点。

  ```
  Input: nums = [3,2,1,6,0,5]
  Output: [6,3,5,null,2,0,null,null,1]
  Explanation: The recursive calls are as follow:
  ```

- 解题：

  ```c++
  class Solution {
  public:
      TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
          if(nums.size()==0) return NULL;
  
          // 找到分割点：最大值
          int max = INT_MIN;
          int index = 0;
          for(int i = 0;i<nums.size();i++){
              if(nums[i]>max){
                  max = nums[i];
                  index = i;
              }
          }
          // 中
          TreeNode* root = new TreeNode(max);
          // 划分数组
          vector<int> leftvector(nums.begin(),nums.begin()+index);
          vector<int> rightvector(nums.begin()+index+1,nums.end());
          // 递归
          root->left = constructMaximumBinaryTree(leftvector);
          root->right = constructMaximumBinaryTree(rightvector);
          return root;
      }
  };
  ```

## 15.合并二叉树

- 题目：617. Merge Two Binary Trees

  给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

  你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

  ```
  Input: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
  Output: [3,4,5,5,4,null,7]
  ```

- 解题

### 15.1 递归

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2; // 如果t1为空，合并之后就应该是t2
        if (t2 == NULL) return t1; // 如果t2为空，合并之后就应该是t1
        // 修改了t1的数值和结构
        t1->val += t2->val;                             // 中
        t1->left = mergeTrees(t1->left, t2->left);      // 左
        t1->right = mergeTrees(t1->right, t2->right);   // 右
        return t1;
    }
};
```

### 15.2 迭代

```c++
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
        if (t1 == NULL) return t2;
        if (t2 == NULL) return t1;
        queue<TreeNode*> que;
        que.push(t1);
        que.push(t2);
        while(!que.empty()) {
            TreeNode* node1 = que.front(); que.pop();
            TreeNode* node2 = que.front(); que.pop();
            // 此时两个节点一定不为空，val相加
            node1->val += node2->val;

            // 如果两棵树左节点都不为空，加入队列
            if (node1->left != NULL && node2->left != NULL) {
                que.push(node1->left);
                que.push(node2->left);
            }
            // 如果两棵树右节点都不为空，加入队列
            if (node1->right != NULL && node2->right != NULL) {
                que.push(node1->right);
                que.push(node2->right);
            }

            // 当t1的左节点 为空 t2左节点不为空，就赋值过去
            if (node1->left == NULL && node2->left != NULL) {
                node1->left = node2->left;
            }
            // 当t1的右节点 为空 t2右节点不为空，就赋值过去
            if (node1->right == NULL && node2->right != NULL) {
                node1->right = node2->right;
            }
        }
        return t1;
    }
};
```

## 16.二叉搜索树中的搜索

- 题目：700. Search in a Binary Search Tree

  给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

  ```
  Input: root = [4,2,7,1,3], val = 2
  Output: [2,1,3]
  ```

  二叉搜索树是一个有序树：

  - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  - 它的左、右子树也分别为二叉搜索树

### 16.1 递归

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if(root==NULL) return NULL;
        if(root->val==val) return root;
        TreeNode* result = NULL;
        if(root->val > val) result = searchBST(root->left,val);
        if(root->val < val) result = searchBST(root->right,val);
        return result;
    }
};
```

### 16.2 迭代

```c++
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
};
```

## 17.验证二叉搜索树

- 题目：98. Validate Binary Search Tree

  给定一个二叉树，判断其是否是一个有效的二叉搜索树。

  假设一个二叉搜索树具有如下特征：

  - 节点的左子树只包含小于当前节点的数。
  - 节点的右子树只包含大于当前节点的数。
  - 所有左子树和右子树自身必须也是二叉搜索树。

  ```
  Input: root = [5,1,4,null,null,3,6]
  Output: false
  Explanation: The root node's value is 5 but its right child's value is 4.
  ```

中序遍历下，输出的二叉搜索树节点的数值是有序序列。

有了这个特性，**验证二叉搜索树，就相当于变成了判断一个序列是不是递增的了。**

### 17.1 递归

```c++
class Solution {
public:
    // 先将二叉搜索树按中序遍历转换为有序数组
    vector<int> vec;
    void traversal(TreeNode* root) {
        if (root == NULL) return;
        traversal(root->left);
        vec.push_back(root->val);
        traversal(root->right);
    }
    bool isValidBST(TreeNode* root) {
        vec.clear(); // 不加这句在leetcode上也可以过，但最好加上
        traversal(root);
        for (int i = 1; i < vec.size(); i++) {
            // 注意要小于等于，搜索树里不能有相同元素
            if (vec[i] <= vec[i - 1]) return false;
        }
        return true;
    }
};
```

### 17.2 迭代

```c++
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        while(cur!=NULL || !st.empty()){
            if(cur!=NULL){
                st.push(cur);
                cur = cur->left;
            }else{
                cur = st.top();
                st.pop();
                if(pre!=NULL && cur->val <= pre->val)
                    return false;
                pre=cur;
                cur = cur->right;
            }
        }
        return true;
    }
};
```

## 18. 二叉搜索树的最小绝对差

- 题目：530. Minimum Absolute Difference in BST

  给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

  ```
  Input: root = [4,2,6,1,3]
  Output: 1
  ```

### 18.1 递归

那么二叉搜索树采用中序遍历，其实就是一个有序数组。在一个有序数组上求两个数最小差值，这是不是就是一道送分题了

```c++
class Solution {
private:
vector<int> vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root->left);
    vec.push_back(root->val); // 将二叉搜索树转换为有序数组
    traversal(root->right);
}
public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        if (vec.size() < 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i < vec.size(); i++) { // 统计有序数组的最小差值
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;
    }
};
```

### 18.2 迭代

```c++
class Solution {
public:
    int getMinimumDifference(TreeNode* root) {
        stack<TreeNode*> st;
        TreeNode* cur=root;
        TreeNode* pre=NULL;
        int min = INT_MAX;
        while(cur!=NULL || !st.empty()){
            if(cur!=NULL){
                st.push(cur);
                cur=cur->left;
            }else{
                cur=st.top();
                st.pop();
                if(pre!=NULL && (abs(pre->val-cur->val)<min))
                    min = abs(pre->val-cur->val);
                pre=cur;
                cur=cur->right;
            }
        }
        return min;
    }
};
```

## 19.二叉搜索树中的众数

- 题目：501. Find Mode in Binary Search Tree

  给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

  假定 BST 有如下定义：

  - 结点左子树中所含结点的值小于等于当前结点的值
  - 结点右子树中所含结点的值大于等于当前结点的值
  - 左子树和右子树都是二叉搜索树

  ```
  Input: root = [1,null,2,2]
  Output: [2]
  ```

### 19.1 递归

- 如果只是普通的二叉树

  最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合

  ```c++
  class Solution {
  private:
  
  // 1. 遍历整个树，并用map统计频率。任何形式的遍历都可以
  void searchBST(TreeNode* cur, unordered_map<int, int>& map) { // 前序遍历
      if (cur == NULL) return ;
      map[cur->val]++; // 统计元素频率
      searchBST(cur->left, map);
      searchBST(cur->right, map);
      return ;
  }
  bool static cmp (const pair<int, int>& a, const pair<int, int>& b) {
      return a.second > b.second;
  }
  public:
      vector<int> findMode(TreeNode* root) {
          unordered_map<int, int> map; // key:元素，value:出现频率
          vector<int> result;
          if (root == NULL) return result;
          searchBST(root, map);
          
          // 2. 把统计的出来的出现频率（即map中的value）排个序
          // C++中如果使用std::map或者std::multimap可以对key排序，但不能对value排序。所以要先把map转化成vector再排序
          vector<pair<int, int>> vec(map.begin(), map.end());
          // 当然vector里面放的也是pair<int, int>类型的数据，第一个int为元素，第二个int为出现频率。
          sort(vec.begin(), vec.end(), cmp); // 给频率排个序
          
          // 3.取前面高频的元素
          result.push_back(vec[0].first);
          for (int i = 1; i < vec.size(); i++) {
              // 取最高的放到result数组中
              if (vec[i].second == vec[0].second) result.push_back(vec[i].first);
              else break;
          }
          return result;
      }
  };
  ```

- 如果是二叉树

  搜索树，它中序遍历就是有序的。利用18二叉搜索树的最小绝对值提到的pre和cur指针来比较。

  ```c++
  class Solution {
  public:
      TreeNode* pre=NULL;
      vector<int> result;
      int max =INT_MIN;
      int count=0;
      void searchBST(TreeNode* cur){
          if(cur==NULL) return;
          searchBST(cur->left);    // 左
          //****** 中 开始******
          if(pre==NULL){
              count = 1;
          }else if(pre->val==cur->val){
              count++;
          }else{
              count = 1;
          }
          
          pre = cur;
          
          if(count > max){	// 如果计数大于最大值频率
              max = count;
              result.clear();
              result.push_back(cur->val);
          }else if(count == max){// 如果和最大值相同，放进result中
              result.push_back(cur->val);
          }
          //****** 中 结束******
          searchBST(cur->right);   // 右
          return;
      }
      vector<int> findMode(TreeNode* root) {
          searchBST(root);
          return result;
      }
  }
  ```

### 19.2 迭代

只要把中序遍历转成迭代，中间节点的处理逻辑完全一样

```c++
class Solution {
public:
    vector<int> findMode(TreeNode* root) {
        TreeNode* pre = NULL;
        TreeNode* cur = root;
        vector<int> result;
        int max =INT_MIN;
        int count=0;

        stack<TreeNode*> st;
        if(cur==NULL) return result;
        while(cur!=NULL || !st.empty()){
            if(cur!=NULL){
                st.push(cur);
                cur = cur->left;
            }else{
                cur=st.top();
                st.pop();
                if(pre==NULL){
                    count = 1;
                }else if(pre->val==cur->val){
                    count++;
                }else{
                    count = 1;
                }
                pre = cur;

                if(count==max)
                    result.push_back(cur->val);
                else if(count>max){
                    result.clear();
                    max = count;
                    result.push_back(cur->val);
                }
                cur = cur->right;
            }
        }
        return result;
    }
};
```



## 20. 二叉树的最近公共祖先

- 题目：236. Lowest Common Ancestor of a Binary Tree

  给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

  百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

  ```
  Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
  Output: 3
  Explanation: The LCA of nodes 5 and 1 is 3.
  
  Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
  Output: 5
  Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
  ```

- 思路：

  遇到这个题目首先想的是要是能自底向上查找就好了，这样就可以找到公共祖先了。

  那么二叉树如何可以自底向上查找呢？

  回溯啊，二叉树回溯的过程就是从低到上。

  后序遍历（左右中）就是天然的回溯过程，可以根据左右子树的返回值，来处理中节点的逻辑。

  **判断逻辑：**

  -  如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。
  - 对于节点本身p(q)，它拥有一个子孙节点q(p)

- 解题：

  ```c++
  class Solution {
  public:
      // 1. 确定递归参数和返回值
      TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {	
          // 2. 设置终止条件
          if(root==q || root==p || root==NULL) return root;   // 如果本身是目标节点，因为是自下向上搜索，所以告诉上面找到p/q了
  
          TreeNode* left = lowestCommonAncestor(root->left,p,q);
          TreeNode* right = lowestCommonAncestor(root->right,p,q);
  		
          // 3.确定单层递归逻辑
          if(left!=NULL && right!=NULL) return root;  // 如果左右子树的返回值都不为空，说明此时的中节点，一定是q和p的最近祖先。
          if(left==NULL && right!=NULL) return right; // 如果某一边子树为空，一边不为空，说明节点都在不为空的那一边，所以最近公共祖先属于不为空那一边，范围缩小到不为空那一边。
          else if(left!=NULL && right==NULL) return left;
          else return NULL;
      }
  };
  ```

## 21. 二叉搜索树的最近公共祖先

- 题目：235. Lowest Common Ancestor of a Binary Search Tree

  给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

  ```
  Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
  Output: 6
  Explanation: The LCA of nodes 2 and 8 is 6.
  ```

- 解题：

  因为搜索二叉树是有序的，所以只要从上到下去遍历，遇到 cur节点是数值在[p, q]区间中则一定可以说明该节点cur就是q 和 p的公共祖先

  - 递归

  ```c++
  class Solution {
  public:
      TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          if(root==NULL) return root;
  		
          // 如果中间最大，那就去比中间都小的左子节点
          if(root->val > p->val && root->val > q->val){
              TreeNode* left = lowestCommonAncestor(root->left,p,q);
              if(left) return left;
          }
          // 如果中间最小，那就去比中间都大的右子节点
          if(root->val < p->val && root->val < q->val){
              TreeNode* right = lowestCommonAncestor(root->right,p,q);
              if(right) return right;
          }
          // 如果中间是三个数中中等大小那个，说明它就是最近公共祖先
          return root;
      }
  };
  ```

  - 迭代

  ```c++
  class Solution {
  public:
      TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          while(root) {
              if (root->val > p->val && root->val > q->val) {
                  root = root->left;
              } else if (root->val < p->val && root->val < q->val) {
                  root = root->right;
              } else return root;
          }
          return NULL;
      }
  };
  ```


## 22.二叉搜索树中的插入操作

- 题目：701. Insert into a Binary Search Tree

  给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。

  注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。

  ```
  Input: root = [4,2,7,1,3], val = 5
  Output: [4,2,7,1,3,5]
  ```

- 原理：

  可以不考虑题目中提示所说的改变树的结构的插入方式。

  **只要按照二叉搜索树的规则去遍历，遇到空节点就插入节点就可以了。**

### 22.1 递归

```c++
class Solution {
public:
    // 1. 确定返回值和参数
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        // 2. 确定终止条件
        if(root==NULL){ // 遇到空节点就是要插入的位置
            TreeNode* node=new TreeNode(val);
            return node;
        }
        // 3. 单层遍历逻辑
        // 一路递归下去直到找到null节点
        if(root->val > val) root->left=insertIntoBST(root->left,val);
        if(root->val < val) root->right=insertIntoBST(root->right,val);
        return root;
    }
};
```

### 22.2 迭代

```c++
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        // 如果是空，就直接给val创个新节点返回
        if(root==NULL) {
            root = new TreeNode(val);
            return root;
        }
        TreeNode* pre=NULL;	// 用于记录找到的空节点的父节点
        TreeNode* cur=root;	// 用于找到空节点
        while(cur){
            if(cur->val > val) {
                pre = cur;
                cur=cur->left;
                if(cur==NULL) pre->left=new TreeNode(val);
            }
            else{
                pre = cur;
                cur=cur->right;
                if(cur==NULL) pre->right=new TreeNode(val);
            }
        }
        return root;
    }
};
```

## 23.删除二叉搜索树中的节点

- 题目：450. Delete Node in a BST

  给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

  ```
  Input: root = [5,3,6,2,4,null,7], key = 3
  Output: [5,4,6,2,null,null,7]
  ```

- 思路

  删除节点有5种情况：

  - 第一种情况：没找到删除的节点，遍历到空节点直接返回了
  - 找到删除的节点
    - 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
    - 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
    - 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
    - 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

### 23.1 递归

```c++
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了
        if (root->val == key) {
            // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
            if (root->left == nullptr && root->right == nullptr) {
                ///! 内存释放
                delete root;
                return nullptr;
            }
            // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
            else if (root->left == nullptr) {
                auto retNode = root->right;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
            else if (root->right == nullptr) {
                auto retNode = root->left;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            // 并返回删除节点右孩子为新的根节点。
            else {
                TreeNode* cur = root->right; // 找右子树最左面的节点
                while(cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置
                TreeNode* tmp = root;   // 把root节点保存一下，下面来删除
                root = root->right;     // 返回旧root的右孩子作为新root
                delete tmp;             // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
                return root;
            }
        }
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```

### 23.2 迭代

```c++
class Solution {
private:
    // 将目标节点（删除节点）的左子树放到 目标节点的右子树的最左面节点的左孩子位置上
    // 并返回目标节点右孩子为新的根节点
    // 是动画里模拟的过程
    TreeNode* deleteOneNode(TreeNode* target) {
        if (target == nullptr) return target;
        if (target->right == nullptr) return target->left;
        TreeNode* cur = target->right;
        while (cur->left) {
            cur = cur->left;
        }
        cur->left = target->left;
        return target->right;
    }
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root;
        TreeNode* cur = root;
        TreeNode* pre = nullptr; // 记录cur的父节点，用来删除cur
        while (cur) {
            if (cur->val == key) break;
            pre = cur;
            if (cur->val > key) cur = cur->left;
            else cur = cur->right;
        }
        if (pre == nullptr) { // 如果搜索树只有头结点
            return deleteOneNode(cur);
        }
        // pre 要知道是删左孩子还是右孩子
        if (pre->left && pre->left->val == key) {
            pre->left = deleteOneNode(cur);
        }
        if (pre->right && pre->right->val == key) {
            pre->right = deleteOneNode(cur);
        }
        return root;
    }
};
```

## 24.修剪二叉搜索树

- 题目：669. Trim a Binary Search Tree

  给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

- 思路：

  不停的递归，遇到不符合的，就把它的孩子传给它的父节点

  又因为是搜索树，所以如果

  - node > key,说明node->left都>key,只需要保留node->right
  - node < key,说明node->right都<key,只需要保留node->left

### 24.1 递归

```c++
class Solution {
public:
    TreeNode* pre = NULL;
    TreeNode* trimBST(TreeNode* 
                      root, int low, int high) {
        if (root == nullptr ) return nullptr;
        if (root->val < low) {
            TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点
            return right;
        }
        if (root->val > high) {
            TreeNode* left = trimBST(root->left, low, high); // 寻找符合区间[low, high]的节点
            return left;
        }
        root->left = trimBST(root->left, low, high); // root->left接入符合条件的左孩子
        root->right = trimBST(root->right, low, high); // root->right接入符合条件的右孩子
        return root;
    }
};
```

### 24.2 迭代

```c++
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int L, int R) {
        if (!root) return nullptr;

        // 处理头结点，让root移动到[L, R] 范围内，注意是左闭右闭
        while (root != nullptr && (root->val < L || root->val > R)) {
            if (root->val < L) root = root->right; // 小于L往右走
            else root = root->left; // 大于R往左走
        }
        TreeNode *cur = root;
        // 此时root已经在[L, R] 范围内，处理左孩子元素小于L的情况
        while (cur != nullptr) {
            while (cur->left && cur->left->val < L) {
                cur->left = cur->left->right;
            }
            cur = cur->left;
        }
        cur = root;

        // 此时root已经在[L, R] 范围内，处理右孩子大于R的情况
        while (cur != nullptr) {
            while (cur->right && cur->right->val > R) {
                cur->right = cur->right->left;
            }
            cur = cur->right;
        }
        return root;
    }
};
```

## 25.将有序数组转换为二叉搜索树

- 题目：Convert Sorted Array to Binary Search Tree

  将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

  一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

  ```
  Input: nums = [-10,-3,0,5,9]
  Output: [0,-3,9,-10,null,5]
  Explanation: [0,-10,5,null,-3,null,9]
  ```

- 思路:

  因为要每个节点都要高度平衡，所以没法建立一个＞样子的二叉搜索树

  **本题本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间**。

- 解题：

  ```c++
  class Solution {
  public:
      TreeNode* traversal(vector<int>& nums,int left, int right){
          // 2. 终止条件
          if(left > right) return NULL;
          // 3. 单层遍历逻辑
          // 从上往下，不断的找到中间的那个节点
          int mid = left + (right-left)/2;
          TreeNode* node = new TreeNode(nums[mid]);
  
          node->left = traversal(nums,left,mid-1);
          node->right = traversal(nums,mid+1,right);
          return node;
      }
      TreeNode* sortedArrayToBST(vector<int>& nums) {
          TreeNode* root = traversal(nums,0,nums.size()-1);
          return root;
      }
  };
  ```

## 26.把二叉搜索树转换为累加树

- 题目：538. Convert BST to Greater Tree

  给出二叉搜索树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

  ```
  Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
  Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
  ```

  ![538.把二叉搜索树转换为累加树](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202307022349307.png)

  从上图可以看出，如果按右中左的方式遍历，就是把之前遍历了的所有的值都给加起来，然后赋值给该节点。

- 递归：

  ```c++
  class Solution {
  public:
      void traversal(TreeNode* root,int &sum){
          if(root==NULL) return;
          traversal(root->right,sum);
          sum += root->val;
          root->val = sum;
          traversal(root->left,sum);
      }
      TreeNode* convertBST(TreeNode* root) {
          int sum=0;
          traversal(root,sum);
          return root;
      }
  };
  ```

- 迭代

  ```c++
  class Solution {
  public:
      TreeNode* convertBST(TreeNode* root) {
          stack<TreeNode*> st;
          if(root==NULL) return root;
          TreeNode* cur = root;
          int sum = 0;
          while(cur!=NULL || !st.empty()){
              if(cur!=NULL){
                  st.push(cur);	//右
                  cur=cur->right;
              }else{
                  cur = st.top();//中
                  st.pop();
                  sum += cur->val;
                  cur->val = sum;
                  cur = cur->left;//左
              }
          }
          return root;
      }
  };
  ```



# 八、回溯算法

## 1.理论基础

- 回溯算法也叫回溯搜索法，是递归的副产品，只要有递归就会有回溯。

  - 回溯的本质是穷举，琼剧所有的可能，然后选出想要的答案。所以效率不高。
  - **回溯函数也就是递归函数**，指的都是一个函数

- 回溯法，一般解决如下问题：

  - 组合问题：N个数里面按一定规则找出k个数的集合。组合无序
  - 切割问题：一个字符串按一定规则有几种切割方式
  - 子集问题：一个N个数的集合里有多少符合条件的子集
  - 排列问题：N个数按一定规则全排列，有几种排列方式。排列有序
  - 棋盘问题：N皇后，解数独等等

  所有回溯法的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

- 回溯函数做题模板：**回溯算法的三部曲**

  ```c++
  // 第一步：回溯函数模板返回值以及参数
  // 因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
  void backtracking(参数) {
      // 第二步：回溯函数终止条件
      // 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
      if (终止条件) {
          存放结果;
          return;
      }
  	
      // 第三步：回溯搜索的遍历过程
      // 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
      for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
          处理节点;
          backtracking(路径，选择列表); // 递归
          回溯，撤销处理结果
      }
  }
  ```
  

## 2.组合

- 题目：77. Combinations

  给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

  ```
  Input: n = 4, k = 2
  Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
  ```

- 思路:

  ![77.组合](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202307031710412.png)

  - 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。
  - 图中可以发现n相当于树的宽度，k相当于树的深度。
  - 图中每次搜索到了叶子节点，我们就找到了一个结果。
  - 遍历：
    - for循环：横向遍历
    - 递归：纵向遍历

- 解题

  ```c++
  class Solution {
  public:
      // 1. 确定参数和返回值
      vector<vector<int>> result; // 存放符合条件结果的集合
      vector<int> path; // 用来存放符合条件结果
      void backtracking(int n, int k, int startIndex){ //startIndex记录本层递归从哪里开始遍历，防止重复
          // 2. 终止条件
          // path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了
          if(path.size()==k){
              result.push_back(path);
              return;                     //保存到result后，终止本层递归
          }
          // 3. 单层搜索的过程
          for(int i=startIndex; i<=n;i++){// 循环：控制横向遍历
              path.push_back(i);          // 处理节点
              backtracking(n,k,i+1);      // 递归：控制纵向遍历
              path.pop_back();            // 回溯
          }
      }
      vector<vector<int>> combine(int n, int k) {
          backtracking(n,k,1);
          return result;
      }
  };
  ```

- 剪枝优化：

  ![77.组合4](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202307031735367.png)

  第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。

  **所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置**。

  **如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了**。

  ```c++
  class Solution {
  private:
      vector<vector<int>> result;
      vector<int> path;
      void backtracking(int n, int k, int startIndex) {
          if (path.size() == k) {
              result.push_back(path);
              return;
          }
          for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 优化的地方
              path.push_back(i); // 处理节点
              backtracking(n, k, i + 1);
              path.pop_back(); // 回溯，撤销处理的节点
          }
      }
  public:
  
      vector<vector<int>> combine(int n, int k) {
          backtracking(n, k, 1);
          return result;
      }
  };
  ```

## 3.组合总和

- 题目：216. Combination Sum III

  找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

  所有数字都是正整数。
  解集不能包含重复的组合。

  ```
  Input: k = 3, n = 7
  Output: [[1,2,4]]
  ```

- 思路：

  ![216.组合总和III](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202307031748889.png)

  - 相比2.组合，多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,...,9]。
  - 但思路是一致的

- 解题：

  ```c++
  class Solution {
  private:
      vector<vector<int>> result; // 存放结果集
      vector<int> path; // 符合条件的结果
      // targetSum：目标和，也就是题目中的n。
      // k：题目中要求k个数的集合。
      // sum：已经收集的元素的总和，也就是path里元素的总和。
      // startIndex：下一层for循环搜索的起始位置。
      void backtracking(int targetSum, int k, int sum, int startIndex) {
          if (sum > targetSum) { // 剪枝操作
              return; // 如果path.size() == k 但sum != targetSum 直接返回
          }
          if (path.size() == k) {
              if (sum == targetSum) result.push_back(path);
              return; // 如果path.size() == k 但sum != targetSum 直接返回
          }
          for (int i = startIndex; i <= 9 - (k - path.size()) + 1; i++) { // 剪枝
              sum += i; // 处理
              path.push_back(i); // 处理
              backtracking(targetSum, k, sum, i + 1); // 注意i+1调整startIndex
              sum -= i; // 回溯
              path.pop_back(); // 回溯
          }
      }
  
  public:
      vector<vector<int>> combinationSum3(int k, int n) {
          result.clear(); // 可以不加
          path.clear();   // 可以不加
          backtracking(n, k, 0, 1);
          return result;
      }
  };
  ```

## 4.电话号码的字母组合

- 题目：17. Letter Combinations of a Phone Number

  给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。

  给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

  ![img](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202307032239423.png)

  ```
  Input: digits = "23"
  Output: ["ad","ae","af","bd","be","bf","cd","ce","cf"]
  ```

- 思路

  ![17. 电话号码的字母组合](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202307032329698.png)

  - for循环：遍历每个数字代表的字母
  - 递归：遍历每个数字

- 解题：

  ```c++
  class Solution {
  private:
      const string letterMap[10] = {
          "", // 0
          "", // 1
          "abc", // 2
          "def", // 3
          "ghi", // 4
          "jkl", // 5
          "mno", // 6
          "pqrs", // 7
          "tuv", // 8
          "wxyz", // 9
      };
  public:
      vector<string> result;
      string s;
      void backtracking(const string& digits, int index) {
          if (index == digits.size()) {
              result.push_back(s);
              return;
          }
          int digit = digits[index] - '0';        // 将index指向的数字转为int
          string letters = letterMap[digit];      // 取数字对应的字符集
          for (int i = 0; i < letters.size(); i++) {
              s.push_back(letters[i]);            // 处理
              backtracking(digits, index + 1);    // 递归，注意index+1，一下层要处理下一个数字了
              s.pop_back();                       // 回溯
          }
      }
      vector<string> letterCombinations(string digits) {
          s.clear();
          result.clear();
          if (digits.size() == 0) {
              return result;
          }
          backtracking(digits, 0);
          return result;
      }
  };
  ```

# 九、贪心算法

## 1.理论基础

- **贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。
  - 贪心算法并没有固定的套路。所以唯一的难点就是如何通过局部最优，推出整体最优。
- 如何验证可不可以用贪心?
  - **最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**
  - 严谨的话需要数学证明
    - 数学归纳法
    - 反证法
- 一般截图步骤
  - 将问题分解为若干个子问题
  - 找出适合的贪心策略
  - 求解每一个子问题的最优解
  - 将局部最优解堆叠成全局最优解

  
  
# 十、动态规划

Dynamic Programming,简称dp

## 1.理论基础

### 1.1 基本思想

参考：https://www.zhihu.com/question/23995189

- **什么是DP？**

  将一个问题拆分成几个子问题，分别求解这些子问题的最优解，就可以得到总问题的最优解。

- **什么问题可以用DP来解决？**

  这个问题可以拆成几个小问题，且满足无后效性、最优子结构性质。

  - 无后效性：未来与过去无关，即如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。

    求得了f(n)就固定住了,f(n-1)...f(n-x)的值不管怎么样都对f(n)无影响了。

  - 最优子结构：大问题的最优解可以由小问题的最优解推出

- **DP为什么比暴力快**

  - 无论是DP还是暴力，我们的算法都是在可能解空间内，寻找最优解。

  - 暴力做法是枚举所有的可能解，这是最大的可能解空间。　

  - 而DP是枚举有希望成为答案的解，这个空间比暴力的小得多。

  - 比如用尽可能少的5,1,11来组成15：

    - 暴力会考虑：15 = 5+5+1+1+1+1+1
    - 而DP不会，因为这不可能是最优解

  - **DP的核心思想**：**尽量缩小可能解空间**

    一般来说，解空间越小，寻找解就越快。这样就完成了优化。

- **如何设计DP**

  - 第一步：设计状态：我是谁

  - 第二步：设计转移：有2种方式：
    1. 我从哪里来，又称pull型转移
    2. 我要到哪里去，又称push型转移

  **例子：用尽可能少的5,1,11元来组成15元：**

  - 第一步：设计状态

    用f(n)来表示凑出n所需的最少钞票数量

  - 第二步：设计转移，这里使用第一种方式，即我从哪里来

    - f(15)有三种情况：

      - 取11:f(15)=f(4)+1 =4+1=5
      - 取5: f(15)=f(10)+1=2+1=3
      - 取1: f(15)=f(14)+1=4+1=5

      显然我们要取cost最小的那个，即5.

    - 这就给了我们启示：f(n)只和f(n-1).f(n-5),f(n-11)有关

      也即我们的**转移方程**：$f(n)=min\{f(n-1),f(n-5),f(n-11) \}+1$

  - 利用上面的转移方程，我们要求出f(n)，只需要求出几个更小的f值：既然如此，我们从小到大把所有的f(x)求出来不就好了？

    ```c
    int f[105],i,n,cost;
    scanf("%d",&n);	// n是希望凑的数值，比如这里是15
    f[0]=0;			// 从最小的0开始网上凑，每一个i需要用到1，5，11的最小次数
    for(i=1;i<=n;i++){
        cost = INF;
        if(i-1>=0) cost = min(cost, f[i-1]+1);
        if(i-5>=0) cost = min(cost, f[i-5]+1);
        if(i-11>=0)cost = min(cost, f[i-11]+1);		// 之所以要用min,对应于转移方程，比如15在上个if就求出了更小的cost
        f[i] = cost;
    }
    ```

    

### 1.2 解题思路

- 如果某一问题有很多重叠子问题，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的.

- 解题步骤：**动态规划五部曲**
  1. 确定dp数组（dp table）以及下标的含义
  2. 确定递推公式
  3. dp数组如何初始化
  4. 确定遍历顺序
  5. 举例推导dp数组

- 动态规划如何debug

  - **做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

  - 然后再写代码，如果代码没通过就**打印dp数组**，看看是不是和自己预先推导的哪里不一样。

    - 如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。
    - 如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

  - 具体debug时问自己三个问题

    1. 这道题目我举例推导状态转移公式了么？
    2. 我打印dp数组的日志了么？
    3. 打印出来了dp数组和我想的一样么？




## 2.斐波那契数列

- 题目：509. Fibonacci Number

  斐波那契数，通常用 F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n > 1 给你n ，请计算 F(n) 。

  ```
  Input: n = 4
  Output: 3
  Explanation: F(4) = F(3) + F(2) = 2 + 1 = 3.
  ```

- 思路：动态规划五部曲

  1. **确定dp数组以及下标的含义**：

     dp[i]的定义为：第i个数的斐波那契数值是dp[i]

  2. **确定递推公式**

     为什么这是一道非常简单的入门题目呢？

     因为题目已经把递推公式直接给我们了：状态转移方程 dp[i] = dp[i - 1] + dp[i - 2];

  3. **dp数组如何初始化**

     题目中把如何初始化也直接给我们了，如下：

     ```
     dp[0] = 0;
     dp[1] = 1;
     ```

  4. **确定遍历顺序**

     从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序一定是从前到后遍历的

  5. **举例推导dp数组**

     按照这个递推公式dp[i] = dp[i - 1] + dp[i - 2]，我们来推导一下，当N为10的时候，dp数组应该是如下的数列：

     0 1 1 2 3 5 8 13 21 34 55

     如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。

- 代码

  ```c++
  class Solution {
  public:
      int fib(int n) {
          if(n<=1) return n;
          vector<int> dp(n+1);
          dp[0] = 0;
          dp[1] = 1;
          for(int i=2; i<=n ; i++){
              dp[i] = dp[i-1] + dp[i-2];
          }
          return dp[n];
      }
  };
  ```

  

## 3.爬楼梯

- 题目：70. Climbing Stairs

  假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

  每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

  注意：给定 n 是一个正整数

  ```
  Input: n = 2
  Output: 2
  Explanation: There are two ways to climb to the top.
  1. 1 step + 1 step
  2. 2 steps
  ```

- 思路：

  1. 确定dp数组（dp table）以及下标的含义

     dp[n]，形成n的所有可能性

  2. 确定递推公式

     dp[n]=dp[n-1]+ dp[n-2]

  3. dp数组如何初始化

     ```
     dp[1]=1
     dp[2]=2
     ```

  4. 确定遍历顺序

     从前向后遍历

  5. 举例推导dp数组 

     假设n=5

     ```         
     dp[1]:1
     dp[2]:2
     dp[3] = dp[1]+dp[2]=3
     dp[4] = dp[2]+dp[3]=5
     dp[5] = dp[3]+dp[4]=8
     ```

- 代码：

  ```c++
  class Solution {
  public:
      int climbStairs(int n) {
          if (n <= 1) return n; // 必须要有，否则当n=0创建dp(n+1)时，只能dp[0]，下面的dp[1]和dp[2]都超过了数组界限
          vector<int> dp(n+1);
          dp[1] = 1;
          dp[2] = 2;
          for(int i=3;i<=n;i++){
              dp[i] = dp[i-2]+dp[i-1];
          }
          return dp[n];
      }
  };
  ```

## 4.使用最小花费爬楼梯

- 题目：746.Min Cost Climbing Stairs

  给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

  你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

  请你计算并返回达到楼梯顶部的最低花费。

  ```
  Input: cost = [10,15,20]
  Output: 15
  Explanation: You will start at index 1.
  - Pay 15 and climb two steps to reach the top.
  The total cost is 15.
  ```
  
- 思路：

  1. 确定dp[i]的含义
  
     dp[i]：爬到i层的最低花费
  
  2. 确定递推公式:
  
     dp[i]=min{dp[i-1]+cost[i-1], dp[i-2]+cos[i-2]}
  
  3. dp数组初始化
  
     ```
     dp[0] = 0;
     dp[1] = 0;
     ```
  
  4. 遍历顺序
  
     从前向后
  
  5. 举例推导
  
     假设0,1,2,3,4层:cost=[10,15,20,10,20]
  
     ```
     dp[0] = 0
     dp[1] = 0
     dp[2] = min{dp[0]+cost[0],dp[1]+cost[1]}=min{10,15}=10
     dp[3] = min{dp[1]+cost[1],dp[2]+cost[2]}=min{15,30}=15
     dp[4] = min{dp[2]+cost[2],dp[3]+cost[3]}=min{30,25}=25
     ```
  
- 代码：

  ```c++
  class Solution {
  public:
      int minCostClimbingStairs(vector<int>& cost) {
          int n = cost.size();
          if(n<=1) return 0;
          vector<int> dp(n+1);
          dp[0] = 0;
          dp[1] = 0;
          for(int i=2;i<=n;i++){
              dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]);
          }
          return dp[n];
      }
  };
  ```


## 6. 不同路径

- 题目: [62. Unique Paths](https://leetcode.com/problems/unique-paths/)

  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

  机器人每次只能**向下或者向右移动一步**。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

  问总共有多少条不同的路径？

  ```
  Input: m = 3, n = 2
  Output: 3
  Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
  1. Right -> Down -> Down
  2. Down -> Down -> Right
  3. Down -> Right -> Down
  ```

- 解法1: 深度搜索(**时间复杂度高无法通过)**

  机器人每次只能向下或者向右移动一步，那么其实机器人走过的路径可以抽象为一棵二叉树，而叶子节点就是终点！

  ```c++
  class Solution {
  private:
      int dfs(int i, int j, int m, int n) {
          if (i > m || j > n) return 0; // 越界了
          if (i == m && j == n) return 1; // 找到一种方法，相当于找到了叶子节点
          return dfs(i + 1, j, m, n) + dfs(i, j + 1, m, n);
      }
  public:
      int uniquePaths(int m, int n) {
          return dfs(1, 1, m, n);
      }
  };
  ```

- 解法2: 动态规划

  1. 确定dp数组（dp table）以及下标的含义

     `dp[i][j]`: 表示从原点(0,0)出发,到(i,j)共有几种走法

  2. 确定递推公式

     `dp[i][j]=dp[i-1][j]+dp[i][j-1]`

  3. dp数组如何初始化

     ```c++
     // dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。
     for (int i = 0; i < m; i++) dp[i][0] = 1;
     for (int j = 0; j < n; j++) dp[0][j] = 1;
     ```

  4. 确定遍历顺序

     从左到右一层一层遍历就可以了。

  5. 举例推导dp数组

     ```
     m=3,n=7:
     1 1 1 1 1 1 1
     1 2 3 4 5 6 7
     1 3 6 10 15 21 28
     ```

- 代码:

  ```c++
  class Solution {
  public:
      int uniquePaths(int m, int n) {
          // 1. 确定dp数组（dp table）以及下标的含义
          vector<vector<int>> dp(m,vector<int>(n));
        	// 3. dp数组如何初始化  
          for(int i=0; i<m; i++) dp[i][0] = 1;
          for(int j=0; j<n; j++) dp[0][j] = 1;
  		
          // 4. 确定遍历顺序
          for(int i=1; i<m; i++){
              for(int j=1; j<n; j++){
                  // 2. 确定递推公式
                  dp[i][j] = dp[i-1][j] + dp[i][j-1];
              }
          }
          return dp[m-1][n-1];
      }
  };
  ```

## 7. 不同路径2

- 题目: [63. Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)

  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

  机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

  现在**考虑网格中有障碍物**。那么从左上角到右下角将会有多少条不同的路径？

  网格中的障碍物和空位置分别用 1 和 0 来表示。

  ```
  Input: obstacleGrid = [[0,1],[0,0]]
  Output: 1
  ```

- 我的思路

  1. dp数组的意义

     `dp[i][j]`: 从(0,0)出发到(i,j)的路线数, 被占就设为0

  2. 递推公式

     `dp[i][j]=dp[i-1][j]+dp[i][j-1]`

  3. 初始化

     遍历第一行第一列, 

     - 如果1后面所有的数字都设为-1
     - 如果0,设为1
  
   4. 遍历顺序
  
      从左往右
  
   5. 举例
  
      ```
      0 1 0    1 -1 -1    1 -1 -1
      0 0 0 => 1  0  0 => 1  1  1
      1 0 0   -1  0  0   -1  1  2
      ```
  
  - 代码:
  
    ```c++
    class Solution {
    public:
        int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
            int m = obstacleGrid.size();
            int n = obstacleGrid[0].size();
        
            // 3. 初始化>>>>>>>>>>>>>>>>>>>>>>>>
            int flag = 0; // 用于判断是否第一列/行遇到障碍物,那么后面的数字全部直接设为-1
            // 初始化列:
            for(int i=0; i<m; i++){
                if(flag == 0){
                    if(obstacleGrid[i][0]==0)
                        obstacleGrid[i][0] = 1;
                    else if(obstacleGrid[i][0]==1)
                        flag =1;
                }
                if(flag == 1){
                    obstacleGrid[i][0]=-1;
                }
            }
            flag = 0;
            // 初始化行:
            for(int j=1; j<n; j++){	// 从j=1开始,因为如果(0,0)没障碍物在初始化列的时候会被设置为1, 那么现在再判断会误判为有障碍物
                if(flag == 0){
                    if(obstacleGrid[0][j]==0)
                        obstacleGrid[0][j] = 1;
                    else if(obstacleGrid[0][j]==1)
                        flag =1;
                    if(obstacleGrid[0][0]==-1)	// 如果(0,0)有障碍物, 那么列和行都可以直接全设为-1了
                        flag =1;
                }
                if(flag == 1){
                    obstacleGrid[0][j]=-1;
                }
            }
            // 3. 初始化<<<<<<<<<<<<<<<<<<<<<<<<
            
            for(int i=1; i<m; i++){
                for(int j=1; j<n; j++){
                    // 2. 递推
                    if(obstacleGrid[i][j]==1){		//如果有障碍物,设为-1
                        obstacleGrid[i][j] = -1;
                    }
                    // 如果左和自己都没有障碍, 那么会加上左的值
                    if(obstacleGrid[i][j] != -1 && obstacleGrid[i][j-1] !=-1){
                        obstacleGrid[i][j] += obstacleGrid[i][j-1];
                    }
                    // 如果上和自己都没有障碍, 那么会加上上的值
                    if(obstacleGrid[i][j] != -1 && obstacleGrid[i-1][j] != -1){
                        obstacleGrid[i][j] += obstacleGrid[i-1][j];
                    }
                    // 如果什么都没加,还是0,说明上和左都是有障碍物的,那么自己也是就不可能到达了,所以设置为-1
                    if(obstacleGrid[i][j] == 0){
                        obstacleGrid[i][j] = -1;
                    }
                }
            }
            if(obstacleGrid[m-1][n-1] == -1 ) obstacleGrid[m-1][n-1] = 0;
            return obstacleGrid[m-1][n-1];
        }
    };
    ```
  
- 改善的代码
  
  相比于上面自己想的思路直接修改obstacleGrid数组, 这里利用额外的dp数组来保存状态, 就不用额外的一个-1来表示状态了.
  
  - 直接修改obstacleGrid数组,需要
  
    1. 修改0为x, 用来表示走到这一格有x种方法
    2. 修改1为-1,用来表示有障碍物
    3. 初始化时又将第一行第一列的0改成了1
  
    因此,`obstacleGrid[i][j]`有了2种含义:1. 有障碍物 2. 走到这一个的路线数. 
  
    2种含义就要增加额外的判断
  
  - 利用额外的dp数组,需要
  
    1. 初始化时,将可以走通的格子对应的dp值设为1, 表示走到这一格的路线数为1
    2. 障碍物对应的dp值全都设为0, 表示走到这一格的路线数为0
  
    因此,`dp`数组只有一种含义: 走到这一格的路线数. 递推时直接相加就可以了,不用再判断
  
  ```c++
  class Solution {
  public:
      int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
          int m = obstacleGrid.size();
          int n = obstacleGrid[0].size();
  		if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) //如果在起点或终点出现了障碍，直接返回0
              return 0;
          vector<vector<int>> dp(m, vector<int>(n, 0));
          // 3.初始化: 将第一行一列没有被占的格子的dp值设为1; 如果遇到障碍物就退出循环
          for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
          for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
          for (int i = 1; i < m; i++) {
              for (int j = 1; j < n; j++) {
                  if (obstacleGrid[i][j] == 1) continue;	// 如果遇到障碍物就跳过,这格保持为0
                  dp[i][j] = dp[i - 1][j] + dp[i][j - 1];	// 障碍物都是0,直接加也没事
              }
          }
          return dp[m - 1][n - 1];
      }
  };
  ```
  
## 8. 整数拆分

- 题目: [343. Integer Break](https://leetcode.com/problems/integer-break/)

  给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

  ```
  Input: n = 10
  Output: 36
  Explanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.
  ```

- 思路

  1. dp数组的意义

     `dp[i]`代表i可以获得的最大乘积

  2. 递推公式
  
     - `j*(i-j)`: 代表把i分成了2个整数
     - `j*dp[i-j]`:代表把i分成n个整数
  
     ```c++
     dp[i] = 0;
     for(int j=1; j<i;j++ ){
         dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]));
     }
     ```
  
  3. 初始化
  
     `dp[1] = 1`
  
     `dp[2] = 1`
  
  4. 遍历顺序
  
     从左往右
  
  5. 举例证明
  
     取i=3
  
     ```
     第一步: j = 1
     dp[i] = 0
     j*(i-j) = 1*2 = 2
     j*dp[i-j] = 1*1 = 1		=> dp[i] = 2
     
     第二步: j = 2
     dp[i] = 2
     j*(i-j) = 2*1 = 2
     j*dp[i-j] = 2*1 = 2  	=> dp[i] = 2	
     ```
  
- 代码
  
  ```c++
  class Solution {
  public:
      int integerBreak(int n) {
          if(n < 3) return 1;
          vector<int> dp(n+1,0);	// 因为从1开始到n,所以0不用,多加一个位置n+1		
          // 3. 初始化
          dp[1] = 1;
          dp[2] = 1;
          // 2. 递推公式
          for(int i=3; i<=n; i++){
              for(int j=1; j<i; j++){
                  dp[i] = max(dp[i],max(j*(i-j),j*dp[i-j]));
              }
          }
          return dp[n];
          // return 0;
      }
  };
  ```
  
   
  

## 9. 不同的二叉搜索树

- 题目：[96. Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)

  给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

  ```
  Input: n = 3
  Output: 5
  ```

- 思路

  因为求不同树的数量，并不用把搜索树都列出来，所以不用关心其具体数值的差异。又因为是搜索树所以根节点肯定大于左子结点，所以天然的当J为根节点时左子树有j-1个节点，右子树有i-j个节点。因此以1到i分别为根节点，求他们能组成的二叉搜索树个数。

  1. dq数组的意义

     dp[i] ： i个不同元素节点组成的二叉搜索树的个数为dp[i] 

  2. 递推公式

     从j=1开始遍历到i：`dp[i]=dp[j-1]dp[i-j]`

     - `dp[j-1]`：以j为头节点，左子树j-1个子结点可以组成的二叉搜索树个数
     - `dp[i-j]`：以j为头节点，右子树i-j个子结点可以组成的二叉搜索树个数

  3. 初始化

     dp[0]=1: 空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。

  4. 遍历顺序

     从0到i

  5. 举例

     dp[1] = dp[0]dp[0] = 1

     dp[2] = dp[0]dp[1] + dp[1]dp[0] = 2

- 代码

  ```c++
  class Solution {
  public:
      int numTrees(int n) {
          vector<int> dp(n+1);
          dp[0] = 1;
          for(int i=1; i<=n;i++){
              for(int j=1; j<=i; j++){
                  dp[i] += dp[j-1]*dp[i-j];
              }
          }
          return dp[n];
      }
  };
  ```

## 10. !!! 0-1背包理论基础 !!!

### 10.1 问题

- **背包问题的种类**

  ![416.分割等和子集1](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%A7%8D%E7%B1%BB.png)

  - 秋招只要掌握01背包和完全背包就够用了。
  - leetcode上没有纯01背包的问题，都是01背包应用方面的题目，也就是需要转化为01背包问题。
  - 通俗来讲
    - **一个商品如果可以重复多次放入是完全背包**
    - **只能放入一次是01背包**

- **标准背包问题：**

  有n件物品和一个最多能背重量为w 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

  **例题**：  背包最大重量为4。

  物品为：

  |       | 重量 | 价值 |
  | ----- | ---- | ---- |
  | 物品0 | 1    | 15   |
  | 物品1 | 3    | 20   |
  | 物品2 | 4    | 30   |

  问背包能背的物品最大价值是多少？

- 暴力解法：

  每一件物品其实只有两个状态，取或者不取，所以可以使用回溯法搜索出所有的情况，那么时间复杂度就是$o(2^n)$，这里的n表示物品数量。

  **所以暴力的解法是指数级别的时间复杂度。进而才需要动态规划的解法来进行优化！**

### 10.2 二维数组表示dp

- DP解法：

  1. dp数组的意义

     对于背包问题，有一种写法， 是使用二维数组，即**`dp[i][j]` 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少**。

     上面物品有3个，所以i从0-2；

     上面背包重量为4，所以j从0-4

  2. 递推公式

     可以有两个方向推出来`dp[i][j]`，

     - 不放物品i：由`dp[i - 1][j]`推出，即背包容量为j，里面不放物品i的最大价值，此时`dp[i][j]`就是`dp[i - 1][j]`。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以背包内的价值依然和前面相同。)
     - 放物品i：由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]] `为背包容量为j - weight[i]的时候不放物品i的最大价值，那么`dp[i - 1][j - weight[i]] + value[i]` （物品i的价值），就是背包放物品i得到的最大价值
     - 所以递归公式： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`

  3. 初始化

     1. 预先将dp数组都设为0
     2. 如果背包容量j=0，那么选不了任何东西，所以`dp[i][0]=0`
     3. 根据递推公式可知，`dp[0][j]`是一定要初始化的，能放下的0号物品的背包初始化为value[0]，否则初始化为0

     ```c++
     // 初始化为都是0的dp数组
     vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));
     
     // 正序遍历
     for (int j = weight[0]; j <= bagweight; j++) {
         dp[0][j] = value[0]; //因为j从weight[0]开始，所以此后的背包肯定都放的下0号物品
     }
     ```

  4. 遍历顺序

     二维dp数组的两个for遍历的先后循序是无所谓的。

     先遍历物品再遍历背包：

     ```c++
     // weight数组的大小 就是物品个数
     for(int i = 1; i < weight.size(); i++) { // 遍历物品,物品0已经在初始化的时候放入dp数组了
         for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
             if (j < weight[i]) dp[i][j] = dp[i - 1][j];
             else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
     
         }
     }
     ```

  5. 举例

- 代码

  ```c++
  void test_2_wei_bag_problem1() {
      vector<int> weight = {1, 3, 4};		// 注意重量是递增的，不是就排序一下
      vector<int> value = {15, 20, 30};	
      int bagweight = 4;
  
      // 二维数组
      vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));
  
      // 初始化
      for (int j = weight[0]; j <= bagweight; j++) {
          dp[0][j] = value[0];
      }
  
      // weight数组的大小 就是物品个数
      for(int i = 1; i < weight.size(); i++) { // 遍历物品
          for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
              if (j < weight[i]) dp[i][j] = dp[i - 1][j];
              else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
  
          }
      }
  
      cout << dp[weight.size() - 1][bagweight] << endl;
  }
  
  int main() {
      test_2_wei_bag_problem1();
  }
  
  ```


### 10.3 滚动数组表示dp(推荐)

相比于上面的二维数组，滚动数组就是把二维dp降为一维dp

- 思路：

  1. dp数组的定义：

     dp[j]： 容量为j的背包，可以装物品的最大价值

  2. dp数组的递推公式：

     从1到i遍历物品，有两种情况

     1. 不放物品i，还是dp[j]
     2. 放物品i，`dp[j]=dp[j-weight[i]]+value[i]`

  3. 初始化

     从dp[j]的定义来看，首先dp[0]一定是0。

     如果题目给的价值都是正整数那么非0下标都初始化为0就可以了，如果题目给的价值有负数，那么非0下标就要初始化为负无穷。

     **这样才能让dp数组在递推的过程中取得最大的价值，而不是被初始值覆盖了**。

  4. 遍历顺序

     先遍历物品再遍历背包，

     - 与二维数组不同，遍历背包时要从大到小: **倒序遍历是为了保证物品i只被放入一次**,如果正序遍历，那么物品0就会被重复加入多次！比如weight[0]=1, value[0]=15,那么

       dp[1] = dp[1 - weight[0]] + value[0] = 15

       dp[2] = dp[2 - weight[0]] + value[0] = 30

       此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

     - 之所以二维数组可以正序遍历，是因为对于二维dp，`dp[i][j]`都是通过上一层即`dp[i - 1][j]`计算而来，本层的`dp[i][j]`并不会被覆盖

     ```c++
     for(int i = 0; i < weight.size(); i++) { // 遍历物品
         for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
             dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
     
         }
     }
     ```

  5. 举例

- 代码

  ```c++
  void test_1_wei_bag_problem() {
      vector<int> weight = {1, 3, 4};
      vector<int> value = {15, 20, 30};
      int bagWeight = 4;
  
      // 初始化
      vector<int> dp(bagWeight + 1, 0);
      for(int i = 0; i < weight.size(); i++) { // 遍历物品
          for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
              dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
          }
      }
      cout << dp[bagWeight] << endl;
  }
  
  int main() {
      test_1_wei_bag_problem();
  }
  ```

## 11. 分割等和子集

- 题目: [416. Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)

  给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

  注意: 每个数组中的元素不会超过 100 数组的大小不会超过 200

  ```
  Input: nums = [1,5,11,5]
  Output: true
  Explanation: The array can be partitioned as [1, 5, 5] and [11].
  ```

- 思路

  - 首先想到：先排序再一个个放进去,总和=sum/2就对了

    但1，1，2，2这种就不行了

    所以还是得用背包

  - 确定使用什么背包
  
    本题中我们要使用的是01背包，因为元素我们只能用一次。
  
  - 转化为01背包问题
  
    - 背包的体积为sum / 2，因为本题要求集合里能否出现总和为 sum / 2 的子集
    - 背包要放入的商品（集合里的元素）重量为 元素的数值，价值也为元素的数值
    - 背包如果正好装满，说明找到了总和为 sum / 2 的子集。
    - 背包中每一个元素是不可重复放入。

  1. dp数组及下标含义
  
     dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]。
  
     如果dp[target]==target==sum/2就装满了
  
  2. 递推公式
  
     01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
  
     本题，相当于背包里放入第0-i个数值，那么物品i的重量是nums[i]，其价值也是nums[i]。
  
     所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
  
  3. 初始化
  
     根据10.3的理论，这里都是正整数，所以dp数组全部初始化为0
  
     ```c++
     // 因为： 1 <= nums.length <= 200
     //       1 <= nums[i] <= 100
     // 所以：总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
     vector<int> dp(10001, 0);
     ```
  
  4. 遍历顺序
  
     使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！
  
     ```c++
     // 开始 01背包
     for(int i = 0; i < nums.size(); i++) {
         for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
             dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
         }
     }
     ```
  
  5. 举例
  
     **如果dp[j] == j 说明，集合中的子集总和正好可以凑成总和j，理解这一点很重要。**
  
- 代码

  ```c++
  class Solution {
  public:
      bool canPartition(vector<int>& nums) {
          int sum = 0;
  
          // dp[i]中的i表示背包内总和
          // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
          // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
          vector<int> dp(10001, 0);
          for (int i = 0; i < nums.size(); i++) {
              sum += nums[i];
          }
          // 也可以使用库函数一步求和
          // int sum = accumulate(nums.begin(), nums.end(), 0);
          if (sum % 2 == 1) return false;
          int target = sum / 2;
  
          // 开始 01背包
          for(int i = 0; i < nums.size(); i++) {
              for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
                  dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
              }
          }
          // 集合中的元素正好可以凑成总和target
          if (dp[target] == target) return true;
          return false;
      }
  };
  ```
  

## 12. 最后一块石头的重量II

- 题目：[1049. Last Stone Weight II](https://leetcode.com/problems/last-stone-weight-ii/)

  有一堆石头，每块石头的重量都是正整数。

  每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

  如果 x == y，那么两块石头都会被完全粉碎；

  如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

  最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0

  ```
  Input: stones = [2,7,4,1,8,1]
  Output: 1
  Explanation:
  We can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,
  we can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,
  we can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,
  we can combine 1 and 1 to get 0, so the array converts to [1], then that's the optimal value.
  ```

- 思路

  可以理解为，分成两堆，是他们之间的重量差值最小。

  每个石头只能用1次，所以是0-1背包

  1. dp数组的意义

     dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]。

  2. 递推公式

     01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

     本题则是：dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);

  3. 初始化

     初始化dp[j]时，创建j=所有石头重量的一半+1的vector

     因为石头重量没有负数，所以初始值全部为0

  4. 遍历顺序

     如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！

  5. 举例

- 代码

  ```c++
  class Solution {
  public:
      int lastStoneWeightII(vector<int>& stones) {
          vector<int> dp(15001, 0);
          int sum = 0;
          for (int i = 0; i < stones.size(); i++) sum += stones[i];
          int target = sum / 2;
          for (int i = 0; i < stones.size(); i++) { // 遍历物品
              for (int j = target; j >= stones[i]; j--) { // 遍历背包
                  dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
              }
          }
          return sum - dp[target] - dp[target];
      }
  };
  
  ```

## 13. 目标和

**问题可以转化为，装满容量为x的背包，有几种方法**

- 题目：[494. Target Sum](https://leetcode.com/problems/target-sum/)

  给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

  返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

  ```
  Input: nums = [1,1,1,1,1], target = 3
  Output: 5
  Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.
  -1 + 1 + 1 + 1 + 1 = 3
  +1 - 1 + 1 + 1 + 1 = 3
  +1 + 1 - 1 + 1 + 1 = 3
  +1 + 1 + 1 - 1 + 1 = 3
  +1 + 1 + 1 + 1 - 1 = 3
  ```

- 思路

  既然为target，那么就一定有 left组合 - right组合 = target。

  left + right = sum，而sum是固定的。right = sum - left

  公式来了， left - (sum - left) = target 推导出 left = (target + sum)/2 。

  target是固定的，sum是固定的，left就可以求出来。

  **此时问题转化成了集合nums中找出和为left的组合。**

  

  又因为每个元素只能取一次，所以是0-1包问题

  1. **dp数组**

     dp[j]表示组合为j的有dp[j]种方法

  2. **递推公式**

     在已有nums[i]时，凑成dp[j]就有dp[j - nums[i]] 种方法。

     例如：dp[j]，j 为5，

     - 已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。
     - 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。
     - 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包
     - 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包
     - 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包

     那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。

     在求装满背包有几种方法的情况下，递推公式一般为

     ```text
     dp[j] += dp[j - nums[i]]
     ```

  3. **初始化**

     从递推公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递推结果将都是0。

     其余值都初始化为0

  4. **遍历顺序**

     01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。

  5. 举例

- 代码

  ```c++
  class Solution {
  public:
      int findTargetSumWays(vector<int>& nums, int S) {
          int sum = 0;
          for (int i = 0; i < nums.size(); i++) sum += nums[i];
          if (abs(S) > sum) return 0; 		// 此时没有方案
          if ((S + sum) % 2 == 1) return 0; 	// 此时没有方案
          int bagSize = (S + sum) / 2;
          vector<int> dp(bagSize + 1, 0);
          dp[0] = 1;
          for (int i = 0; i < nums.size(); i++) {
              for (int j = bagSize; j >= nums[i]; j--) {
                  dp[j] += dp[j - nums[i]];
              }
          }
          return dp[bagSize];
      }
  };
  ```


## 14. 一和零

- 题目：[474. Ones and Zeroes](https://leetcode.com/problems/ones-and-zeroes/)

  给你一个二进制字符串数组 strs 和两个整数 m 和 n 。

  请你找出并返回 strs 的最大子集的大小，该子集中 最多 有 m 个 0 和 n 个 1 。

  如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 

- 思路：

  本题的m和n相当于是一个背包(2个维度的背包)，所以还是01背包问题

  1. dp数组的意义

     `dp[i][j]`：有i个0和j个1的最大子集的大小

  2. 递推公式

     `dp[i][j]=max(dp[i][j],dp[i-zeronum][j-onenum]+1)`

     - 字符串的zeroNum和oneNum相当于物品的重量（weight[i]）
     - 字符串本身的个数相当于物品的价值（value[i]）。

  3. 初始化

     因为物品价值不会是负数，初始为0，保证递推的时候dp[i][j]不会被初始值覆盖。

  4. 遍历顺序

     外层遍历外围物品，即各个字符串

     内层遍历背包容量，且必须从后向前遍历

  5. 举例

- 代码

  ```c++
  class Solution {
  public:
      int findMaxForm(vector<string>& strs, int m, int n) {
          vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
          for (string str : strs) { // 遍历物品
              int oneNum = 0, zeroNum = 0;
              for (char c : str) {
                  if (c == '0') zeroNum++;
                  else oneNum++;
              }
              for (int i = m; i >= zeroNum; i--) { // 遍历背包容量且从后向前遍历！先遍历哪个都可以，因为ij是同一个背包的两个维度
                  for (int j = n; j >= oneNum; j--) {
                      dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
                  }
              }
          }
          return dp[m][n];
      }
  };
  ```


## 15. !!! 完全背包理论基础 !!!

- 完全背包问题：

  有N件物品和一个最多能背重量为W的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品都有无限个（也就是可以放入背包多次）**，求解将哪些物品装入背包里物品价值总和最大。

  **完全背包和01背包问题唯一不同的地方就是，每种物品有无限件**。

- 一个例子：

  背包最大重量为4。

  物品为：

  |       | 重量 | 价值 |
  | ----- | ---- | ---- |
  | 物品0 | 1    | 15   |
  | 物品1 | 3    | 20   |
  | 物品2 | 4    | 30   |

  **每件商品都有无限个！**

  问背包能背的物品最大价值是多少？

- **01背包和完全背包唯一不同就是体现在遍历顺序上**

  dp[j]的定义两者一致：容量为j的背包可以装物品的最大价值

  - 01背包

    ```c++
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        // 01背包是倒序，为了保证每个物品仅被添加一次
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    ```

  - 完全背包

    ```cpp
    // 先遍历物品，再遍历背包
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        // 完全背包是正序，因为完全背包的物品是可以添加多次
        for(int j = weight[i]; j <= bagWeight ; j++) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    
        }
    }
    ```
    

- **为什么遍历物品在外层循环，遍历背包容量在内层循环？**

  - 对于01背包：
  
    二维dp数组的两个for遍历的先后循序是可以颠倒了，一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。
  
  - 对于完全背包
  
    **一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！**
  
    因为dp[j] 是根据 下标j之前所对应的dp[j]计算出来的。 只要保证下标j之前的dp[j]都是经过计算的就可以了。
  
    ```c++
    // 先遍历背包，再遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
        for(int i = 0; i < weight.size(); i++) { // 遍历物品
            if (j - weight[i] >= 0) dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
        cout << endl;
    }
    ```
  
- 例子的答案
  
  ```c++
  // 先遍历物品，在遍历背包
  void test_CompletePack() {
      vector<int> weight = {1, 3, 4};
      vector<int> value = {15, 20, 30};
      int bagWeight = 4;
      vector<int> dp(bagWeight + 1, 0);
      for(int i = 0; i < weight.size(); i++) { // 遍历物品
          for(int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
              dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
          }
      }
      cout << dp[bagWeight] << endl;
  }
  int main() {
      test_CompletePack();
  }
  ```
  
  
  
  

## 43. 最长重复子数组

- 题目：[718. Maximum Length of Repeated Subarray](https://leetcode.com/problems/maximum-length-of-repeated-subarray/)

  给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

  ```
  Input: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
  Output: 3
  Explanation: The repeated subarray with maximum length is [3,2,1].
  ```

- 思路：

  基本思路就是2个指针遍历2个数组找出第一个数组每一个元素开始对应的最长重复子数组，储存的方式借dp的思想表现了出来

  1. dp数组的意义

     `dp[i][j] `：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，**最长重复子数组长度**为`dp[i][j]。 `

     - i,j都从1开始算

     - 下标i - 1为结尾的A就是`A[i-1]`为结尾的字符串，

     - 比如字符串A=[1,2,3,2,1] B=[3,2,1,4,7]

       那么`dp[3][1]`就是A=[1,2,3]和B=[3]的最长重复子数组长度, 为1

       而`dp[4][2]`就是A=[1,2,3,2]和B=[3,2]的最长重复子数组长度，为2

  2. 递推公式

     当`A[i - 1]` 和`B[j - 1]`相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1`;

     上面这个例子中：`dp[4][2]=dp[3][1]+1=2`

  3. 初始化

     根据`dp[i][j]`的定义，`dp[i][0]` 和`dp[0][j]`其实都是没有意义的！

     但`dp[i][0] `和`dp[0][j]`要初始值，因为 为了方便递归公式`dp[i][j] = dp[i - 1][j - 1] + 1`;

     所以`dp[i][0] `和`dp[0][j]`初始化为0。

     举个例子A[0]如果和B[0]相同的话，`dp[1][1] = dp[0][0] + 1`，只有`dp[0][0]`初始为0，正好符合递推公式逐步累加起来。

  4. 确定遍历顺序

     外层for循环遍历A，内层for循环遍历B。

  5. 推导dp数组

- 代码：

  ```c++
  class Solution {
  public:
      int findLength(vector<int>& nums1, vector<int>& nums2) {
          int size1 = nums1.size();
          int size2 = nums2.size();
          vector<vector<int>> dp(size1+1,vector<int>(size2+1,0));
          int result = 0;
          for(int i=1; i<=size1; i++){
              for(int j=1; j<=size2; j++){
                  if(nums1[i-1]==nums2[j-1]){
                      dp[i][j] = dp[i-1][j-1] + 1;
                  }
                  if(dp[i][j]>result) result = dp[i][j];
              }
          }
          return result;
      }
  };
  ```

  

## 44. 最长公共子序列

- 题目: [1143. Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)

  给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

  一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

  例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。

  若这两个字符串没有公共子序列，则返回 0。

  ```
  Input: text1 = "abcde", text2 = "ace" 
  Output: 3  
  Explanation: The longest common subsequence is "ace" and its length is 3.
  ```

- 思路：

  和上面的43相比，这里不要求是连续的了，但要有相对顺序。所以不像上面元素相等的情况如果断了就重新计数，这边断了是继续计数下去的

  1. dp数组的意义

     `dp[i][j]`表示[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列

  2. 递推公式
  
     - 如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以`dp[i][j] = dp[i - 1][j - 1] + 1`;
  
     - 如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。即：`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`;
  
  3. 初始化
  
     全部初始化为0
  
  4. 遍历顺序
  
     外层for循环遍历text1，内层for循环遍历text2。
  
  5. 验证
  
- 代码：

  ```c++
  class Solution {
  public:
      int longestCommonSubsequence(string text1, string text2) {
          int size1 = text1.size();
          int size2 = text2.size();
          vector<vector<int>> dp(size1+1,vector<int>(size2+1,0));
          for(int i=1; i<=size1; i++){
              for(int j=1; j<=size2; j++){
                  if(text1[i-1]==text2[j-1]){	// 注意这里字符串索引始终比dp索引小1，要-1
                      dp[i][j]=dp[i-1][j-1]+1;
                  }else{
                      dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
                  }
              }
          }
          return dp[size1][size2];
      }
  };
  ```

  

## 49. 两个字符串的删除操作

-  题目：[583. Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)

  给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

  ```
  Input: word1 = "sea", word2 = "eat"
  Output: 2
  Explanation: You need one step to make "sea" to "ea" and another step to make "eat" to "ea".
  ```

- 思路

  类似于上面的44，找到2个单词的最大公共子序列，然后他们的长度相减就是要删除的单词个数

  1. dp数组的意义

     `dp[i][j]`代表[0,i-1]的word1和[0,j-1]的word2的最大公共子序列

  2. 递推公式

     i,j从1开始

     - 如果w1[i-1]=w2[j-1]，那么`dp[i][j]=dp[i-1][j-1]+1`
     - 如果w1[i-1]!=w2[j-1]，那么`dp[i][j]=max(dp[i][j-1],dp[i-1][j])`

  3. 初始化

     都为0

  4. 遍历顺序

     外围for遍历w1,内for遍历w2

  5. 验证

- 代码

  ```c++
  class Solution {
  public:
      int minDistance(string word1, string word2) {
          int size1 = word1.size();
          int size2 = word2.size();
          vector<vector<int>> dp(size1+1,vector<int>(size2+1,0));
          for(int i=1; i<=size1; i++){
              for(int j=1; j<=size2; j++){
                  if(word1[i-1]==word2[j-1]){
                      dp[i][j] = dp[i-1][j-1] + 1;
                  }else{
                      dp[i][j] = max(dp[i][j-1],dp[i-1][j]);
                  }
              }
          }
          int result = size1 + size2 - 2*dp[size1][size2];
          return result;
      }
  };
  ```

## *1. 两个字符串的最小ASCII删除和

- 题目：[712. Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/)

  给定两个字符串`s1` 和 `s2`，返回 *使两个字符串相等所需删除字符的 **ASCII** 值的最小和* 。

  ```
  Input: s1 = "sea", s2 = "eat"
  Output: 231
  Explanation: Deleting "s" from "sea" adds the ASCII value of "s" (115) to the sum.
  Deleting "t" from "eat" adds 116 to the sum.
  At the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.
  ```

- 思路

  49题的变种。

  1. dp数组的意义

     `dp[i][j]`：[0,i-1]的s1和[0,j-1]s2最小ASCII删除和

  2. 递推公式

     - 如果s1[i-1]=s2[j-1]那么，`dp[i][j]=dp[i-1][j-1]`

     - 如果不等，那么取s1,s2删除各自的-1项后的较小项：

       `dp[i][j]=min(dp[i-1][j]+s1[i-1]，dp[i][j-1]+s2[j-1])`

  3. 初始化

     不能像49一样都设为0，因为

     - `dp[i][0] ` 表示[0,i-1]的s1和[]的s2的最小删除和，所以[0,i-1]的s1的所有元素都要删除
     - 同理`dp[0][j]`也是

     ```c++
     for(int i=1; i<=size1; i++){
         dp[i][0] = dp[i-1][0] + s1[i-1];
     }
     for(int j=1; j<=size2; j++){   
         dp[0][j] = dp[0][j-1] + s2[j-1];
     }
     ```

  4. 遍历顺序

     外for遍历s1,内for遍历s2

  5. 验证

- 代码

  ```c++
  class Solution {
  public:
      int minimumDeleteSum(string s1, string s2) {
          int size1 = s1.size();
          int size2 = s2.size();
          vector<vector<int>> dp(size1+1,vector<int>(size2+1,0));
          for(int i=1; i<=size1; i++){
              dp[i][0] = dp[i-1][0] + s1[i-1];
          }
          for(int j=1; j<=size2; j++){   
              dp[0][j] = dp[0][j-1] + s2[j-1];
          }
          for(int i=1; i<=size1; i++){
              for(int j=1; j<=size2; j++){
                  if(s1[i-1]==s2[j-1]){
                      dp[i][j] = dp[i-1][j-1];
                  }else{
                      dp[i][j] = min(dp[i][j-1]+s2[j-1], dp[i-1][j]+s1[i-1]);
                  }
              }
          }
          return dp[size1][size2];
      }
  };
  ```

  

# 十一、单调栈

# 十二、图论

## *1. 最长同值路径

- 题目：[687. Longest Univalue Path](https://leetcode.com/problems/longest-univalue-path/)

  给定一个二叉树的 `root` ，返回 *最长的路径的长度* ，这个路径中的 *每个节点具有相同值* 。 这条路径可以经过也可以不经过根节点。

  **两个节点之间的路径长度** 由它们之间的边数表示。

  ```
  输入：root = [5,4,5,1,1,5]
  输出：2
  ```

- 思路：深度优先搜索

  最长同值路径长度必定为某一节点的左最长同值有向路径长度与右最长同值有向路径长度之和

  因此对左右同时深度优先，计算出当前节点的左/右最长值

- 代码：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      int res = 0;
  
      int dfs(TreeNode* node){
          if(node==NULL) return 0;
          int left_all = dfs(node->left);
          int right_all = dfs(node->right);
          int left=0, right=0;
          if(node->left && node->val==node->left->val){
              left = left_all + 1;
          }
          if(node->right && node->val == node->right->val){
              right = right_all + 1;
          }
          res = max(res,right+left);
          return max(left,right);
      }
  
      int longestUnivaluePath(TreeNode* root) {
          dfs(root);
          return res;
      }
  };
  ```

  

# 笔试

## 各种输入

### 1. 读取指定长度的数组

```c++
/*
输入格式：
3
1
2
3
*/
#include <iostream>
#include <vector>
// #include <sstream>
using namespace std;

int main()
{
    int n;
    cin >> n;
    vector<int> nums(n);
    for (int i = 0; i < n; ++i){
        cin >> nums[i];
    }
 
    for (int i = 0;i < nums.size();i++)
    {
        cout << nums[i];
    }
    cout << endl;
    system("pause");
    return 0;
}
```

### 2. 从键盘读入任意长度的数组

```c++
/*
输入格式：
1 2 3 4
*/
vector<int> nums;
int num;
// 读取数字
while(cin>>num){
    nums.push_back(num);
    // 读取空格或分割符号
    if(getchar() == '\n')
        break;
}
```

### 3. 读取指定长度且有分隔的数组

```c++
/*
输入格式：
3
1,2,3
*/
int n;
cin >> n;
char sep;
vector<int> vec(n);

for(int i=0;i<n-1;i++){
    cin >> vec[i] >> sep;
}
cin >> vec[n-1];
```

### 4. 输入字符串[1,2,3]

```c++
#include <iostream>
#include <vector>
#include <sstream>

int main() {
    std::string input;
    std::cout << "请输入形如 [1,2,3] 的数字序列：" << std::endl;
    std::getline(std::cin, input);

    // 去除字符串中的 "[" 和 "]" 字符
    input = input.substr(1, input.length() - 2);

    // 将去除 "[" 和 "]" 后的字符串初始化为 stringstream 对象
    std::stringstream ss(input);  

    std::vector<double> vec;
    std::string num_str;
    
    // 以','为分界获得每一个字符串
    while(getline(ss,num_str,',')){
        vec.push_back(std::stod(num_str));
    }

    for (double n : vec) {
        std::cout << n << " ";
    }
    return 0;
}

```

### 5. 输入字符串aa bb cc

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
    string str;
    vector<string> strs;
    while (cin >> str){
        strs.push_back(str);
        if (getchar() == '\n'){     
            break;
        }
    }

    for (auto& str : strs) {
        cout << "当前单词："<< str << " ";
    }
    return 0;
}
```



## 2023.08.19小红书后端

### 1. 背单词

- 题目:

  小红在背单词,如果现在她已经记住了i个单词,那么下一个单词就需要背i+1次.

  现在直到小红背单词的顺序,求小红今天记住了几个单词.

  - 输入:

    第一行:整数n,表示一共背了n个单词

    接下来n行:每行一个字符串,表示单词

  - 输出:

    输出一个整数,表示记住了多少单词

  - 例子

    ```
    # 输入:
    5
    you
    thank
    queue
    queue
    thank
    
    # 输出:
    2
    ```

    因为先记住了you,又因为了背了2次queue所以也记住了queue,最后thank需要出现3次才能记住

- 解题:

  第一题用一个哈希表存每个单词对应的次数，维护一个count变量记录当前所需次数，只要当前单词次数大于count，count自增，然后用set将该单词记录避免重复统计，最后输出count

  ```c++
  #include<iostream>
  #include<string>
  #include<vector>
  #include<unordered_map>
  #include<unordered_set>
  using namespace std; 
  
  int main(){
  	int n;
  	cin>>n;
  	string s;
  	int count = 1;
  	unordered_map<string, int> map;	// 存每个单词出现的个数
  	unordered_set<string> isRemember;	// 存记住的单词
  	for(int i=0;i<n;i++){
  		cin>>s;
  		map[s]++;
          // 单词出现的次数大于当前要求的次数count,就是记住了
  		if(map[s]>=count){
              // 判断该单词是否已经记住,如果set里没这个单词,说明之前没记住过是新背出的单词
  			if(isRemember.count(s)==0){
  				isRemember.emplace(s);
  				count++;
  			}
  		}
  	}
  	cout<<count-1<<endl;
  }
  ```

### 2. 回文串

- 题目:

  - 有一个字符串,可以对他进行如下操作

    - 拆分:w->v,v   m->n,n

    - 轴对称:b->d, p->q,反之亦然

    - 翻转:b->q, d->p, n->u,反之亦然

      求经过若干如此操作后,这个字符串是否是回文串

  - 输入:

    第一行:整数n,表示有几个字符串

    接下来n行:n个需要判断的字符串

  - 输出

    输出n行,每行输出YES或者NO,表示是否可以变成回文串

  - 例子:

    ```
    # 输入
    5
    wovv
    bod
    pdd
    moom
    lalalai
    
    #输出
    YES             # 因为可以变成vvovv
    YES				# 因为可以变成bob
    YES				# 因为可以变成pdp
    YES				# 因为本身就是回文
    NO
    ```

- 代码:

  先统一把字符串里的w和m展开成vv和nn;

  然后再去判断

  ```c++
  #include<iostream>
  #include<string>
  #include<vector>
  #include<unordered_map>
  #include<unordered_set>
  using namespace std; 
  
  void check(string s){
  	int l = 0, r = s.size() - 1;
  	while(l < r){
  		if(s[l]==s[r]){
  			l++;r--;
  		}
  		else if(s[l]=='b'||s[l]=='p'||s[l]=='q'||s[l]=='d'){
  			if(s[r]=='b'||s[r]=='p'||s[r]=='q'||s[r]=='d'){
  				l++;r--;
  			}
  			else{
  				cout<<"NO"<<endl;
  				return;
  			}
  		}
  		else if(s[l]=='n'||s[l]=='u'){
  			if(s[r]=='n'||s[r]=='u'){
  				l++;r--;
  			}
  			else{
  				cout<<"NO"<<endl;
  				return;
  			}
  		}
  		else{
  			cout<<"NO"<<endl;
  			return;
  		}
  	}
  	cout<<"YES"<<endl;
  }
  
  int main(){
  	int n;
  	cin>>n;
  	string s;
  	for(int i=0;i<n;i++){
  		cin>>s;
  		string str = "";
  		for(char ch:s){
              // 1. 先统一把字符串s里的w和m展开成vv和nn,并存到str中去;
  			if(ch=='w'){
  				str += "vv";
  			}
  			else if(ch=='m'){
  				str += "nn";
  			}
  			else str.push_back(ch);
  		}
          // 2.然后再去判断
  		check(str);
  	}
  }
  
  ```
### 3. 旅游攻略

- 题目:

  有**n**个景点,**m**条路线,每个景点的价值为a,每个景点游览时间**h**,不同景点之间的交通时间为**w**.

  小红要选择**3**个相邻的景点然后按顺序将景点写入攻略,需要保证每个景点的游览时间+景点之间的交通时间<=**k**,并要求3个景点的价值**a之和**尽可能大

  - 输入:

    第一行: 三个整数,分别表示n,m,k

    第二行: n个整数表示n个景点的价值a

    第三行: n个整数表示n个景点的游览时间h

    接下来的m行: 每行3个整数: u,v,w. 表示将点u和v之间的交通时间w

  - 输出:

    一个整数,表示攻略可以达到的最大价值

- 解题

  只能经过三个城市，暴力dfs即可

  ```c++
  #include<iostream>
  #include<string>
  #include<vector>
  #include<unordered_map>
  #include<unordered_set>
  using namespace std; 
  
  int main(){
  	int n,m;
  	long long k;
  	int a,b,c;
  	cin>>n>>m>>k;
  	vector<int>sites(n+1);					// 存储n个景点的价值
  	for(int i=1;i<=n;i++) cin>>sites[i];
  	vector<int>times(n+1);					// 存储n个景点的游览时间
  	for(int i=1;i<=n;i++) cin>>times[i];
  	
  	unordered_map<int,vector<pair<int,int>>> roads; // 存储m条2个景点之间的时间花销
  	for(int i=0;i<m;i++){
  		cin>>a>>b>>c;
  		roads[a].push_back({b,c});
  		roads[b].push_back({a,c});
  	}
  	long long maxvalue = 0; 	// 目标找到价值最大的那3个景点组合
      
      // 遍历每一个景点,连续去剩下的2个景点,找到价值最大的那条
  	for(int i=1;i<=n;i++){
  		if(times[i]>k) continue;	// 时间花销要<=k
  		maxvalue = max(maxvalue, (long long)sites[i]);	// 保存并对比 第一个景点的价值 和 当前价值最大值
  		// 第一步 从景点i出发,遍历所有连接的景点j
  		vector<pair<int,int>> next = roads[i];
  		for(pair<int,int> p:next){
  			long long time = times[i];		// 第i个景点的游览时间
  			long long value = sites[i];		// 第i个景点的价值
  			int j = p.first;				// 与i所连接的景点j
  			int road = p.second;			// i到j的路程时间
  			
  			if(i!=j){
  				time += (times[j] + road);	// 要求: 游览时间 + 路程时间 < k
  				if(time>k) continue;
  				value += sites[j];			// 保存并对比 前2个景点的价值 和 当前价值最大值
  				maxvalue = max(maxvalue, value);
  				/// 第二步 从景点j出发 ,遍历所有连接的景点x
  				vector<pair<int,int>> next1 = roads[j];
  				for(pair<int,int> q:next1){
  					long long time2 = time;		// 第j个景点的游览时间
  					long long value2 = value;	// 第j个景点的价值
  					int x = q.first;			// 与j所连接的景点x
  					int road1 = q.second;		// j到x的路程时间
  					
  					if(x!=j&&x!=i){
  						time2 += (times[x] + road1);	// 要求: 游览时间 + 路程时间 < k
  						if(time2>k) continue;
  						value2 += sites[x];				// 保存并对比 前3个景点的价值 和 当前价值最大值
  						maxvalue = max(maxvalue, value2); 
  					}
  				}
  			}
  		} 
  	}
  	cout<<maxvalue<<endl;
  }
  ```

  

## 2023.09.02美团后端

### 1. 找子序列

- 题目：

  在n行m列的本子上写了许多字母，她会在每一行中找出一个字母，然后组成一个字符串。

  想知道，组成的字符串中是否存在至少一个字符串包含 "meituan" 子序列。

  - 输入：

    第一行输入2个整数n,m(1<=n,m<=1000) 。

    接下来n行，每行输入一个长度为m的字符串表示小美写下的字母。

  - 输出

    若存在至少一个字符串包含 "meituan" 子序列，则输出 "YES"，否则输出 "NO"。
    
  - 示例
  
    ```shell
    # 输入：
    8 2
    nm
    ex
    it
    td
    ul
    qu
    ac
    nt
    # 输出
    YES
    ```
    
    第1行选择第2个字母。
    第2行选择第1个字母。
    第3行选择第1个字母。
    第4行选择第1个字母。
    第5行选择第2个字母。
    第6行选择第2个字母。
    第7行选择第1个字母。
    第8行选择第1个字母。
    组成字符串"meitluan"，其中存在"meituan"子序列。
    当然，第6行选第1个字母且第5行选第1个字母组成的字符串"meituqan"中也存在"meituan"子序列。
  
- 思路

  1. dp数组的意义

     用0~6代表meituan七个字母

     用`ext[i][j]`记录字母i是否存在第j行

     `dp[i][j]`表示前i行是否存在合法的字母0~j组成的字串

  2. 递推公式

     若第i行存在字母j，则`dp[i][j]=dp[i-1][j]||dp[i-1][j-1]`（不使用第i行的字母j||使用第i行的字母j）

     否则`dp[i][j]=dp[i-1][j]`（不使用第i行的字母j）。

  3. 初始化

     全部设为false

  4. 遍历顺序

     先遍历i行字符串，再遍历j个字母

  5. 举例

- 代码
  
  ```c++
  #include <bits/stdc++.h>
  
  using namespace std;
  
  #define MAXN 1005
  
  int n, m, t;
  string s;
  bool ext[7][MAXN] = {false};
  
  bool dp[MAXN][7] = {false};
  
  // 用0-6代表meituan7个字母
  int decode(char c) {
      switch (c) {
          case 'm':
              return 0;
          case 'e':
              return 1;
          case 'i':
              return 2;
          case 't':
              return 3;
          case 'u':
              return 4;
          case 'a':
              return 5;
          case 'n':
              return 6;
      }
      return -1;
  }
  
  int main() {
      cin >> n >> m;
      // 读入n个字符串
      for (int i = 1; i <= n; ++i) {
          cin >> s;
          // 判断当前字符串包含哪些目标字符
          for (int j = 1; j <= m; ++j)
              if ((t = decode(s[j - 1])) >= 0)
                  ext[t][i] = true;   // 第i行字符串有第t个目标字符，比如第一行字符为m时t=0：ext[0][1]=true
      }
      // 遍历每一行字符串
      for (int i = 1; i <= n; ++i) {
          // 遍历每一个目标字母
          for (int j = 0; j < 7; ++j) {
              // 遍历每一行开始前，初始化一下
              if (j == 0) {   
                  if (ext[j][i]) 
                      dp[i][j] = true;    // 前i行不存在j=0即字符"m"
                  else 
                      dp[i][j] = false;
                  continue;
              }
              
              // 只有前一行至少有了前0到j-1个目标字符，才会将true传递下去
              if (ext[j][i])  // 若第i行存在字母j
                  dp[i][j] = dp[i - 1][j] || dp[i - 1][j - 1];    // 不使用第i行的字母j || 使用第i行的字母j
              else
                  dp[i][j] = dp[i - 1][j];    // 不使用第i行的字母j
  
          }
      }
      cout << (dp[n][6] ? "YES\n" : "NO\n");
  }
  
  ```
  
  
### 2. 元素删除

- 题目：

  小美有一个数组，她希望删除k个元素，使得剩余的元素两两之间互为倍数关系。你能告诉小美有多少种删除方案吗？由于答案过大，请对10^9+7模。

  - 输入：

    第一行输入两个整数n,k(1<=k<=n<=10^3)表示数组长度，删除的元素数量。

    第二行输入n,k个整数表示数组a(1<=ai<=10^9)。

    保证给定的数组中不存在两个相等元素。

  - 输出：

    输出一个整数x表示有x种删除方案。

  - 示例：

    ```shell
    # 输入
    6 4
    1 4 2 3 6 7
    # 输出
    8
    ```

    方案1：删除1,4,2,7。

    方案2：删除1,4,3,7。

    方案3：删除1,3,6,7。

    方案4：删除4,2,3,6。

    方案5：删除4,2,3,7。

    方案6：删除4,2,6,7。

    方案7：删除4,3,6,7。

    方案8：删除2,3,6,7。

- 思路

  - 整体的逻辑是：在一个升序数组`a[n]=[1,2,5,6,12]`中，

    - 首先依次记录当前数`a[i]`（i在0到n之间）和第0到i的数的互为倍数的可能组合。

      如此知道了数组`a[i]`每个元素之间哪两个之间有倍数关系：

      ```
      2-1;
      5-1;
      6-1;	6-2
      12-1;	12-2; 	12-6
      ```

    - 接着想要在3个数之间找两两倍数关系，只需要在上面得到倍数关系中取找就行了。

      当前数的可能性就是，当前数所有约数的倍数可能性之和

      ```
      当前数为2： 2找到它的约数1，但1没有更小的约数了，所以不成立所以组合数=0
      
      5： 5->1, 1->nothing, 0
      6： 6->1, 1->nothing, 0
      	6->2, 2->1, 	  1		=> 0+1 = 1种可能性
      12: 12->1,1->nothing, 0
      	12->2,2->1,		  1
      	12->6,6->2,
      		  6->1,		  2		=> 0+1+2 = 3种可能性
      ```

    - **所以要在n个数之间找两两倍数，只要在已有n-1个数的 两两倍数可能性 基础上去找就可以**

  1. dp数组的意义

     将数组从小到大排序存在a[i]中

     用yueshu[i]这个vector容器记录所有a[i]约数的index，该过程时间复杂度为 O(nlogn+n^2)

     `dp[i][j]`，有一个有j个数的数组，这个数组中包含数组a中第1到第i个数。dp表示这个数组中两两有倍数关系的子数组个数。

     `dp[i][j]`为所有`dp[i][j-1]`的约数索引之和，该过程时间复杂度最大为 O(n(n-k)*(平均约数个数))

  2. 递推公式

     `dp[i][j] = (dp[i][j] + dp[p][j - 1]`

  3. 初始化

     `dp[i][1] = 1`：数组只有一个1个数时，只有这个数i本身，没有两两倍数关系的数组组合，但为了遍历方便设为1。

  4. 遍历顺序

  5. 举例

- 代码

  ```c++
  #include <bits/stdc++.h>
  
  using namespace std;
  
  #define MAXN 1005
  #define ll long long
  #define MOD int(1e9+7)
  
  int n, k, m, a[MAXN];
  ll dp[MAXN][MAXN] = {0};
  vector<int> yueshu[MAXN];
  
  int main() {
      cin >> n >> k;  // 一共有n个数，从中删除k个数
      m = n - k;      // m为剩下的数字个数
      for (int i = 1; i <= n; ++i)cin >> a[i];    // 注意这里从索引1开始存
      sort(a + 1, a + 1 + n);                     // 将数组a从小到大排序
      
      // 从第i=2个数开始，在数组中比它小的数整中找能把它整除的数
      for (int i = 2; i <= n; ++i)      // 第2个开始，因为第1个是最小的不需要判断
          for (int j = 1; j < i; ++j)   // 在数组中比它小的数整中找
              if (a[i] % a[j] == 0) yueshu[i].push_back(j);   // 能把第i个数整除的数索引都放入vector中
      
      for (int i = 1; i <= n; ++i) dp[i][1] = 1;  // 数组只有一个1个数时，初始化为1，即每个数自身就是一种排列方式
      
      // *****dp部分
      // 外层遍历：从第个2数开始遍历数组a的每个元素
      for (int i = 2; i <= n; ++i) {      
          // 内层遍历：遍历需要选择的整数数量j，从2到m（m为剩下的数字个数）。
          for (int j = 2; j <= m; ++j) { 
              // 对于每个元素a[i]，遍历其约数列表yueshu[i]
              for (auto p: yueshu[i]) {
                  // 累加所有a[i]的约数p，在去除i后的有j-1个数的数组中的组合数
                  dp[i][j] = (dp[i][j] + dp[p][j - 1]) % MOD; // 除模是因为题目要求的
              }
          }
      }
      ll ans = 0;
      // 最后的答案就是所有dp[i] [n-k]之和
      for (int i = 1; i <= n; ++i){
          ans = (ans + dp[i][m]) % MOD;
          cout << dp[i][m] << ",";
      }
      cout << ans << endl;
  }
  
  ```
  
  

### 3. 彩虹糖

- 题目：

  小美有很多的彩虹糖，每颗彩虹糖都有一个颜色，她每天可以吃两颗彩虹糖，如果今天吃的彩虹糖组合是之前没吃过的组合，则小美今天会很高兴。

  例如，小美有 6 颗彩虹糖，颜色分别是 ![[1,1,4,5,1,4]]。

  小红第一天吃一组颜色为 1 和 4 的彩虹糖，小美会很高兴；

  第二天吃一组颜色为 4 和 1 的彩虹糖，小美不会很高兴；

  第三天小美吃一组颜色为 1 和 5 的彩虹糖，小美会很高兴，此时小美共有 2 天很高兴。

  小美想知道，她最多有几天会很高兴。

  - 输入：

    第一行输入一个整数n(1<=n<=10^5)表示彩虹糖数量。

    第二行输入n个整数表示彩虹糖颜色a(1<=ai<=10^9)。

  - 输出：

    输出一个整数表示答案。

  - 实例

    ```shell
    # 输入
    6
    1 1 4 5 1 4
    # 输出
    3
    ```

    第1天吃一组颜色为1，4的彩虹糖。

    第2天吃一组颜色为4，5的彩虹糖。

    第3天吃一组颜色为1，1的彩虹糖。

    小美3天都会很高兴。

- 思路：

  先统计每个颜色的数量，把颜色加入优先队列。s每次取出数量最少的那种颜色c，然后从队列里取min(c的数量，队列长度)个颜色，依次数量减一，ans加一，如果取出的颜色的数量不为0就再放回队列。

  如果最后c的数量仍然大于等于2，ans再加一。

  队列为空时输出ans。

- 代码：

  ```c++
  public static void main(String[] args) {
      Scanner sc = new Scanner(System.in) ;
      int n = sc.nextInt();
      Map<Integer, Integer> map = new HashMap<>();
      int [] a = new int[n];
      for (int i = 0; i < n; i++) {
           a[i] = sc.nextInt();
           map.put(a[i], map.getOrDefault(a[i], 0) + 1);
      }
      int ans = 0;
      PriorityQueue<Integer> queue = new PriorityQueue<>(new Comparator<Integer>() {
          @Override
          public int compare(Integer o1, Integer o2) {
              return map.get(o1).compareTo(map.get(o2));
          }
      });
      for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
          queue.add(entry.getKey());
      }
      while (!queue.isEmpty()) {
          int c = queue.poll();
          while (!queue.isEmpty()) {
              int p = queue.poll();
              map.put(p, map.get(p) - 1);
              map.put(c, map.get(c) - 1);
              ans++;
              if (map.get(p) != 0) {
                  queue.add(p);
              }
              if (map.get(c) == 0) break;
          }
          if (map.get(c) >= 2) {
              ans++;
          }
      }
      System.out.println(ans);
  }
  ```

  

​    
