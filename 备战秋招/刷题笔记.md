# 一、数组

## 1.理论基础

- 数组是存放在连续内存空间上的相同类型数据的集合
  - 数组下标都是从0开始的。
  - 数组内存空间的地址是连续的
  - 数组的元素是不能删的，只能覆盖！
    - 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）
  
- 二分法：
  - **循环不变量原则**，只有在循环中坚持对区间的定义
  
- 双指针法：
  - 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作
  
- 滑动窗口
  - 滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。
  
- 总结图：

  <img src="https://github.com/Fernweh-yang/Reading-Notes/blob/main/%E7%AC%94%E8%AE%B0%E9%85%8D%E5%A5%97%E5%9B%BE%E7%89%87/Algorithm/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png?raw=true"  />

## 2.二分查找

### 2.1 题目：704 Binary Search

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 `nums` 中的所有元素是不重复的。

示例

```
示例1：
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例2：
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

### 2.2 暴力搜索

#### 2.2.1 C++

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        for(vector<int>::iterator iter = nums.begin(); iter!=nums.end(); iter++){
            # 读取迭代器的值，用指针
            if(*iter==target)
                # 返回迭代器的下标
                return distance(nums.begin(),iter);
        }
        return -1;
    }
};
```

#### 2.2.2 python

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        for i in nums:
            if i == target:
                return nums.index(i)
        return -1
```

### 2.2 解题：二分法

- **这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，这些都是使用二分法的前提条件。

- **循环不变量规则**：**区间的定义是不变量**，在while寻找中每一次边界的处理都要坚持根据区间的定义来操作。二分法，区间的定义一般为两种：

  1. 左闭右闭即[left, right]
  2. 左闭右开即[left, right)

- 第一种解法：左闭右闭[left, right]

  区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

  - while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
  - if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int left = 0;
          int right = nums.size()-1;	//2种写法的区别
          int middle
          while(left <= right){
              middle = left + ((right - left) / 2);
              if(nums[middle]>target){
                  right = middle - 1;	//2种写法的区别
              }
              else if(nums[middle]<target){
                  left = middle + 1;
              }
              else
                  return middle;
          }
          return -1;
  
      }
  };
  ```
  ```python
  class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)-1
        while left <= right:
            middle = int(left + (right - right)/2)
            if nums[middle] == target:
                return middle
            elif nums[middle] < target:
                left = middle+1
            else:
                right = middle -1
        return -1 
  ```

- 第二种解法：左闭右开[left, right)

  有如下两点：

  - while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的，即right代表的那个数是不考虑在内的。
  - if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int left = 0;
          int right = nums.size(); 	//2种写法的区别
          int middle
          while(left < right){
              middle = left + ((right - left) / 2);
              if(nums[middle]>target){
                  right = middle ;	//2种写法的区别
              }
              else if(nums[middle]<target){
                  left = middle + 1;
              }
              else
                  return middle;
          }
          return -1;
  
      }
  };
  ```
  ```python
  class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            middle = int(left + (right - right)/2)
            if nums[middle] == target:
                return middle
            elif nums[middle] < target:
                left = middle+1
            else:
                right = middle 
        return -1 
  ```

### 2.3 相似题：

- 35.搜索插入位置-Search Insert Position
- 34.在排序数组中查找元素的第一个和最后一个位置-Find First and Last Position of Element in Sorted Array
- 69.x 的平方根-Sqrt(x)
- 367.有效的完全平方数-Valid Perfect Square

## 3.移除元素

### 3.1 题目：27 Remove Element

给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

- 说明：

  为什么返回数值是整数，但输出的答案是数组呢?

  请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

  你可以想象内部操作如下:

  ```
  // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
  int len = removeElement(nums, val);
  
  // 在函数里修改输入数组对于调用者是可见的。
  // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
  for (int i = 0; i < len; i++) {
      print(nums[i]);
  }
  ```

- 示例

  ```
  输入：nums = [3,2,2,3], val = 3
  输出：2, nums = [2,2]
  解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
  
  输入：nums = [0,1,2,2,3,0,4,2], val = 2
  输出：5, nums = [0,1,4,0,3]
  解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
  ```

### 3.2 解题：双指针

- 第一种解法：暴力解法

  用两层for循环，第一层便利数组元素，第二层更新数组

  时间复杂度O(n^2)

- 第二种解法：双指针法（快慢指针）

  **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

  - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
  - 慢指针：指向更新新数组下标的位置(即目标元素的位置)

  ```c++
  class Solution {
  public:
      int removeElement(vector<int>& nums, int val) {
          int slowIndex=0;
          for(int fastIndex=0;fastIndex<nums.size();fastIndex++){
              if(nums[fastIndex]!=val){
                  nums[slowIndex++]=nums[fastIndex];
              }
          }
          return slowIndex;
      }
  };
  ```
  ```python
  class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast = 0
        slow = 0
        while fast < len(nums):
            if nums[fast]!= val:
                nums[slow] = nums[fast]
                slow +=1
            fast +=1
        return slow 
  ```
- 第三种解法:双指针(两端向中间)
  - 左指针：找要删除的值
  - 右指针：找不删除的值，然后两者交换
  ```c++
  class Solution {
  public:
      int removeElement(vector<int>& nums, int val) {
          int left =0;
          int right = nums.size()-1;
          while(left<=right){
              if(nums[right]==val)
                  right--;
              else{
                  if(nums[left]==val){
                      nums[left] = nums[right];
                      left++;
                      right--;
                  }else{
                      left++;
                  }
              }
          }
          return left;
      }
  };
  ```
  ```python
  class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        left = 0
        right = len(nums)-1
        while left <= right:
            if nums[right] == val:
                right = right -1
            elif nums[left] == val:
                nums[left] = nums[right]
                left = left + 1
                right = right -1
            else:
                left = left + 1
        return left
            
  ```

### 3.3 相似题：

- 26.删除排序数组中的重复项
- 283.移动零
- 844.比较含退格的字符串
- 977.有序数组的平方



## 4.有序数组的平方

### 4.1 题目：977 Squares of a Sorted Array

给你一个按 **非递减顺序non-decreasing** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

- 示例

  ```
  输入：nums = [-4,-1,0,3,10]
  输出：[0,1,9,16,100]
  解释：平方后，数组变为 [16,1,0,9,100]
  排序后，数组变为 [0,1,9,16,100
  
  输入：nums = [-7,-3,2,3,11]
  输出：[4,9,9,49,121]
  ```

### 4.2 解题：双指针

- 第一种解法：暴力解法

  每个数平方后，再排序

  ```c++
  class Solution {
  public:
      vector<int> sortedSquares(vector<int>& nums) {
          for(int i=0;i<nums.size();i++){
              nums[i]*=nums[i];
          }
          sort(nums.begin(),nums.end()); #快速排序
          return nums;
      }
  };
  ```

  时间复杂度：O(n+log(n))

- 第二种解法：双指针法

  数组其实是有序的， 只不过负数平方之后可能成为最大数了。

  那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

  此时可以考虑双指针法了，left指向起始位置，right指向终止位置。

  定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

  如果`A[left] * A[left] < A[right] * A[right]` 那么`result[k--] = A[right] * A[right];` 。

  如果`A[left] * A[left] >= A[right] * A[right]` 那么`result[k--] = A[left] * A[left];` 。

  ```c++
  class Solution {
  public:
      vector<int> sortedSquares(vector<int>& nums) {
          int k = nums.size()-1;
          vector<int> results(nums.size(),0);
          for(int left=0,right=nums.size()-1; left<=right; ){
              if(nums[left]*nums[left]<=nums[right]*nums[right]){
                  results[k--]=nums[right]*nums[right];
                  right--;
              }
              else{
                  results[k--]=nums[left]*nums[left];
                  left++;
              }
          }
          return results;
      }
  };
  ```
  ```python
  class Solution:
      def sortedSquares(self, nums: List[int]) -> List[int]:
          i = len(nums)-1
          temp = [0] * (i+1)
          left = 0
          right = i
          while left <= right:
              if nums[left]*nums[left] <= nums[right]*nums[right]:
                  temp[i] = nums[right]*nums[right]
                  i -=1
                  right -=1
              else:
                  temp[i] = nums[left]*nums[left]
                  i-=1
                  left+=1
          return temp
  ```

## 5.长度最小的子数组

### 5.1 题目：209 Minimum Size Subarray Sum

给定一个含有 n 个正整数的数组和一个正整数(positive integer) target 。

找出该数组中满足其和 ≥ target 的长度最小的连续子数组(contiguous subarray) [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

- 示例

  ```
  输入：target = 7, nums = [2,3,1,2,4,3]
  输出：2
  解释：子数组 [4,3] 是该条件下的长度最小的子数组。
  
  输入：target = 4, nums = [1,4,4]
  输出：1
  
  输入：target = 11, nums = [1,1,1,1,1,1,1,1]
  输出：0
  ```

### 5.2 解题：滑动窗口

- 第一种解法：暴力解法：用2个for循环，不断寻找符合条件的子序列

  时间复杂度O(n^2)

  ```c++
  class Solution {
  public:
      int minSubArrayLen(int s, vector<int>& nums) {
          int result = INT32_MAX; // 最终的结果
          int sum = 0; // 子序列的数值之和
          int subLength = 0; // 子序列的长度
          for (int i = 0; i < nums.size(); i++) { // 设置子序列起点为i
              sum = 0;
              for (int j = i; j < nums.size(); j++) { // 设置子序列终止位置为j
                  sum += nums[j];
                  if (sum >= s) { // 一旦发现子序列和超过了s，更新result
                      subLength = j - i + 1; // 取子序列的长度
                      result = result < subLength ? result : subLength;
                      break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break
                  }
              }
          }
          // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
          return result == INT32_MAX ? 0 : result;
      }
  };
  ```

- 第二种解法：滑动窗口

  所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。滑动窗口也可以理解为双指针法的一种。只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

  如果只用一个for循环来表示滑动窗口的起始位置，那么此时难免再次陷入暴力解法的怪圈。

  所以只用一个for循环，那么这个循环的索引，一定是表示滑动窗口的终止位置。

  在本题中实现滑动窗口，主要确定如下三点：

  - 窗口内是什么？

    窗口就是满足其和 ≥ s 的长度最小的连续子数组。

  - 如何移动窗口的起始位置？

    窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

  - 如何移动窗口的结束位置？

    窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

  **滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

  ```c++
  class Solution {
  public:
      int minSubArrayLen(int s, vector<int>& nums) {
          int result = INT32_MAX;
          int sum = 0; // 滑动窗口数值之和
          int i = 0; // 滑动窗口起始位置
          int subLength = 0; // 滑动窗口的长度
          for (int j = 0; j < nums.size(); j++) {
              sum += nums[j];
              // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
              // 虽然for里放了一个while，但看元素被操作的次数是一进一出2次，所以是2n即o(n)
              while (sum >= s) {
                  subLength = (j - i + 1); // 取子序列的长度
                  result = result < subLength ? result : subLength;
                  sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
              }
          }
          // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
          return result == INT32_MAX ? 0 : result;
      }
  };
  ```

### 5.3 相似题：

- 904.水果成篮
- 76.最小覆盖子串

## 6.螺旋矩阵2

### 6.1 题目：59 Spiral Matrix II

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

- 示例：

  ```
  输入：n = 3
  输出：[[1,2,3],[8,9,4],[7,6,5]]
  
  输入：n = 1
  输出：[[1]]
  ```

### 6.2 解题：

本题并不涉及到什么算法，就是模拟过程。

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。

和二分法一样，本题要坚持**循环不变量**的原则。即我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的**左闭右开，或者左开右闭**的原则，这样这一圈才能按照统一的规则画下来。

按**左闭右开**的原则即处理到每一个拐角时：拐角处让给新的一条边来继续画。

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j = starty; j < n - offset; j++) {
                res[startx][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i = startx; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

### 6.3 相似题

- 54.螺旋矩阵
- 剑指Offer 29.顺时针打印矩阵



## 7.总结：

- **数组是存放在连续内存空间上的相同类型数据的集合。**

  - 一维数组的地址是连续的
  - 二维数组的地址不一定连续。
    - 矩阵每行上的元素地址是连续的
    - 但是行与行之间的地址不一定连续

- **数组的元素是不能删的，只能覆盖。**

  - 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。

- 上面总共列举了四种数组题目

  1. 二分法(2)

     **循环不变量原则**，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。

  2. 双指针法(3,4)

     **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

  3. 滑动窗口(5)

     **滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

  4. 模拟行为(6)

     不涉及到什么算法，就是单纯的模拟。要遵守**循环不变量原则**

# 二、链表

## 1.理论基础

- 链表类型

  1. 单链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）
     - 链接的入口节点称为链表的头结点也就是head。

  2. 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。
     - 双链表既可以向前查询也可以向后查询。

  3. 循环链表：链表首尾相连。
     - 循环链表可以用来解决约瑟夫环问题。

- 链表的存储方式

  链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

- 链表的定义

  ```c++
  struct ListNode {
      int val;  // 节点上存储的元素
      ListNode *next;  // 指向下一个节点的指针
      ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
  };
  ```

- 性能分析

  | 时间复杂度 | 插入/删除 | 查询 | 适用场景                         |
  | ---------- | --------- | ---- | -------------------------------- |
  | 数组       | O(n)      | O(1) | 数据量固定，频繁查询，较少增删   |
  | 链表       | O(1)      | O(n) | 数据量不固定，频繁增删，较少查询 |

  - 数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

  - 链表的长度可以是不固定的，并且可以动态增删， 

- 总结图

  ![](https://github.com/Fernweh-yang/Reading-Notes/blob/main/%E7%AC%94%E8%AE%B0%E9%85%8D%E5%A5%97%E5%9B%BE%E7%89%87/Algorithm/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png?raw=true)

## 2.移除链表元素

- 题目：203：Remove Linked List Elements

  给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
  
  示例：
  
  ```
  示例1：
  输入：head = [1,2,6,3,4,5,6], val = 6
  输出：[1,2,3,4,5]
  
  示例2：
  输入：head = [], val = 1
  输出：[]
  
  示例3：
  输入：head = [7,7,7,7], val = 7
  输出：[]
  ```
  
- 解题：

  - 设立一个虚拟头节点来保证，处理任何节点都是同一个思路。会比直接操作原链表更方便

    ```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    // 第一种做法：直接操作原链表
    class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            // 需要单独处理头节点
            while(head!=NULL && head->val == val){
                ListNode* tmp = head;
                head = head->next;
                delete tmp;
            }
            // 然后再处理后面的节点
            ListNode* cur = head;
            while(cur!=NULL && cur->next!=NULL){
                if(cur->next->val==val){
                    ListNode* tmp = cur->next;
                    cur->next = cur->next->next;
                    delete tmp;
                }
                else
                    cur = cur->next;
            }
            return head;
        }
    };
    
    // 第二种做法：设疑一个虚拟头节点
    class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
            dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
            ListNode* cur = dummyHead;
            while (cur->next != NULL) {
                if(cur->next->val == val) {
                    ListNode* tmp = cur->next;
                    cur->next = cur->next->next;
                    // malloc/free->new/delete。delete不仅可以释放内存，还可以在对对象时自动调用析构函数
                    delete tmp;
                } else {
                    cur = cur->next;
                }
            }
            head = dummyHead->next;
            delete dummyHead;
            return head;
        }
    };
    ```
    

## 3.设计链表

- 题目：707.Design Linked List

  设计一个自己的链表类，它有如下方法：

  - `MyLinkedList()` Initializes the `MyLinkedList` object.
  - `int get(int index)` Get the value of the `indexth` node in the linked list. If the index is invalid, return `-1`.
  - `void addAtHead(int val)` Add a node of value `val` before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
  - `void addAtTail(int val)` Append a node of value `val` as the last element of the linked list.
  - `void addAtIndex(int index, int val)` Add a node of value `val` before the `indexth` node in the linked list. If `index` equals the length of the linked list, the node will be appended to the end of the linked list. If `index` is greater than the length, the node **will not be inserted**.
  - `void deleteAtIndex(int index)` Delete the `indexth` node in the linked list, if the index is valid.

- 解题：

  ```c++
  class MyLinkedList {
  public:
      struct ListNode{    //用结构体来实现链表
          int val;
          ListNode *next;
          ListNode(int x):val(x),next(nullptr){}
      };
  
      MyLinkedList() {
          _dummyHead = new ListNode(0);   // 头节点使用虚拟节点有助于统一每个节点的操作
          _size=0;  						// 用于判断访问的index是否合法
      }
      
      int get(int index) {				// 注意index是从0开始的，第0个节点就是头结点
          if(index < _size && index >=0){
              ListNode* cur = _dummyHead->next; // 所以从虚拟节点的next开始
              while(index--){
                  cur = cur->next;
              }
              return cur->val;
          }
          else
              return -1;
      }
      
      void addAtHead(int val) {			
          ListNode* newHead = new ListNode(val);
          newHead->next = _dummyHead->next; //这里就体现了虚拟头节点的好处, 不用用一个中间节点来删减头节点的方式转换头节点。
          _dummyHead->next = newHead;
          _size++;
      }
      
      void addAtTail(int val) {
          ListNode* cur = _dummyHead;
          while(cur->next!=nullptr){		  // 一路找到最后那个节点先
              cur = cur->next;
          }
          ListNode* newTail = new ListNode(val);
          cur->next = newTail;
          _size++;
      }
      
      void addAtIndex(int index, int val) {	// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
          if(index <0 || index>_size){
              return;
          }
          ListNode* cur = _dummyHead;
          ListNode* newNode = new ListNode(val);
          while(index--){				// 一路找到index对应的节点先
              cur = cur->next;
          }
          newNode->next = cur->next;
          cur->next = newNode;
          _size++;
      }
      
      void deleteAtIndex(int index) {	// 注意index是从0开始的
          if(index <0 || index>=_size){
              return;
          }
          ListNode* cur = _dummyHead;
          while(index--){			    // 一路找到index对应的节点先
              cur = cur->next;
          }
          ListNode* temp = cur->next;
          cur->next = cur->next->next;
          delete temp;
          _size--;
      }
  private:    //类方法用到的变量都定义在私有域里
      int _size;  
      ListNode* _dummyHead;
  };
  
  /**
   * Your MyLinkedList object will be instantiated and called as such:
   * MyLinkedList* obj = new MyLinkedList();
   * int param_1 = obj->get(index);
   * obj->addAtHead(val);
   * obj->addAtTail(val);
   * obj->addAtIndex(index,val);
   * obj->deleteAtIndex(index);
   */
  ```

  

## 4.反转链表

- 题目：206.Reverse Linked List

  给予一个链表，反转它

  ```
  Input: head = [1,2,3,4,5]： 1->2->3->4->5
  Output: [5,4,3,2,1]:        5->4->3->2->1
  ```

- 解题：

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
  public:	
      ListNode* reverseList(ListNode* head) {	//用三个指针交替保存各自数据，实现链表反转。
          ListNode* temp ;
          ListNode* pre = nullptr;
          ListNode* cur = head;
          while(cur != nullptr){
              temp = cur->next;
              cur->next = pre;
              pre = cur;
              cur = temp;
          }
          return pre;
      }
  };
  ```

## 5.两两交换链表中的节点

- 题目：24.Swap Nodes in Pairs

  每两个节点之间改变位置：

  ```
  Input: head = [1,2,3,4]
  Output: [2,1,4,3]
  
  Input: head = []
  Output: []
  
  Input: head = [1]
  Output: [1]
  ```

- 解题：

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
  public:
      ListNode* swapPairs(ListNode* head) {
          ListNode* virtualHead = new ListNode(0,head);
          ListNode* cur = virtualHead;
          // 使用虚拟头节点来统一操作
          while(cur->next != nullptr && cur->next->next != nullptr){	//如果下/下下一个为空什么都不操作保持原样就可以
              ListNode* first = cur->next;
              ListNode* second = cur->next->next;
  
              cur->next = second;
              first->next = second->next;
              second->next = first;
  
              cur = cur->next->next;
          }
          return virtualHead->next;	//注意这里return head就不对了，因为18，23行已经把first(head)->next的关系变动了.
      
      }
  };
  ```

## 6.删除链表的倒数第N个节点

- 题目：19. Remove Nth Node From End of List

  给予一个链表，删除从它尾部数起的第n个节点

  ```
  Input: head = [1,2,3,4,5], n = 2
  Output: [1,2,3,5]
  ```

- 解题：

  - 笨办法：
  
    1. 先遍历一遍，有多少个节点
    2. 然后找到要操作的那个节点
  
    ```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
            ListNode* fakeHead = new ListNode(0,head);
            ListNode* cur = fakeHead;
            int i = 0;
            while(cur->next != nullptr){
                i++;
                cur = cur->next;
            }
            cur = fakeHead;
            for(int j=0;j<i-n;j++){
                cur = cur->next;
            }
            ListNode* temp = cur->next;
            cur->next = cur->next->next;
            delete temp;
            return fakeHead->next;
        }
    };
    ```
  
  - 双指针：
  
    1. 如果要删除倒数第n个节点，让fast移动n步，
    2. 然后让fast和slow同时移动，直到fast指向链表末尾。
    3. 删掉slow所指向的节点就可以了。
  
    ```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
            ListNode* fakeHead = new ListNode(0,head);
            ListNode* fast = fakeHead;
            ListNode* low = fakeHead;
            while(n-- && fast!=nullptr){	// 1. 如果要删除倒数第n个节点，让fast移动n步，
                fast = fast->next;
            }
            fast = fast ->next;
            while(fast != nullptr){			// 2. 然后让fast和slow同时移动，直到fast指向链表末尾。
                fast = fast->next;
                low = low->next;
            }
            ListNode* temp = low->next;		// 3. 删掉slow所指向的节点就可以了。
            low->next = low->next->next;	
            delete temp;
            return fakeHead->next;
        }
    };
    ```
  
## 7.链表相交

- 题目：Intersection of Two Linked Lists

  给定两个链表，找到链表中地址相同的节点

- 解题：

  1. 求出两个链表的长度，并求出两个链表长度的差值
  2. 然后让短的移动到，和长的那个列表末尾对齐的位置
  3. 比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
          ListNode* curA = headA;
          ListNode* curB = headB;
          int a=0,b=0;
          
          while(curA !=nullptr){		// 1. 求出两个链表的长度，并求出两个链表长度的差值
              curA = curA->next;
              a++;
          }
          while(curB !=nullptr){
              curB = curB->next;
              b++;
          }
          curA = headA;
          curB = headB;
          
          if(a>=b){					// 2. 然后让短的移动到，和长的那个列表末尾对齐的位置
              int i = a-b;
              while(i-- && curA->next!=nullptr){
                  curA = curA->next;
              }
          }
          else{
              int i = b-a;
              while(i-- && curB->next!=nullptr){
                  curB = curB->next;
              }
          }
          
          while(curA!=nullptr){		// 3. 比较curA和curB是否相同
              if(curA==curB)
                  return curA;
              curA = curA->next;
              curB = curB->next;
          }
          return NULL;
      }
  };
  ```

  

## 8.环形链表

- 题目：Linked List Cycle II

  给定一个链表，如果存在环形结构（即尾节点不指向null，而是指向某一中间节点），找到这个环境结构的起始点（中间节点）,否则返回NULL。

  ```
  Input: head = [3,2,0,-4], pos = 1
  Output: tail connects to node index 1
  Explanation: There is a cycle in the linked list, where tail connects to the second node.
  ```

- 解题:

  1. 首先用快慢指针判断是否有环

     - 快指针：从头结点出发，每次走两步
     - 慢指针：从头节点出发，每次走一步
     - 如果他们相遇，就说明有环。
     - **相对于slow来说，fast是一个节点一个节点的靠近slow的**，所以fast一定可以和slow重合。

  2. 找到入口：

     - 假设相遇时slow走了`x+y`,fast走了`x+y+n(y+z)`

       - x为头节点到环入口点的节点数
       - y为环形入口节点到 fast指针与slow指针相遇节点的节点数
       - z为相遇节点再到环形入口节点节点数
       - n为fast走了多少圈后和slow相遇，n至少1，因为快指针至少饶了一圈才能遇到slow

     - 因为fast速度是slow的两倍，所以有公式：`2(x+y)=x+y+n(y+z)`

     - 整理得到`x = (n - 1) (y + z) + z`

       - 当n=1时，x=z,说明

         **从头结点出发一个指针index1，从相遇节点也出发一个指针index2，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

       - 当n>1时，和n=1一样，

         只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode *detectCycle(ListNode *head) {
          ListNode* slow = head;
          ListNode* fast = head;
          while(fast!=nullptr && fast->next!=nullptr){	// 1. 用快慢指针判断是否有环
              slow = slow->next;
              fast = fast->next->next;
              
              if(slow == fast){							// 2. 如果有环，就去找到入口
                  ListNode* index1 = head;
                  ListNode* index2 = fast;
                  while(index1 != index2){
                      index1 = index1->next;
                      index2 = index2->next;
                  }
                  return index1;
              }
          }
          return NULL;
      }
  };
  ```

## 9.总结

- 主要要理解：
  - 链表的种类主要为：单链表，双链表，循环链表
  - 链表的存储方式：链表的节点在内存中是分散存储的，通过指针连在一起。
  - 链表是如何进行增删改查的。(3.设计链表)
  - 数组和链表在不同场景下的性能分析
- **虚拟头节点**：每次对应头结点的情况都要单独处理时，添加虚拟头节点，统一每个节点的操作。

# 三、哈希表

## 1.理论基础

- 什么是哈希表？

  - 哈希表Hash table，也叫散列表，是根据关键码的值而直接进行访问的数据结构

  - 数组就是一个哈希表：关键码就是数组的索引下标，然后通过下标**直接**访问数组中的元素

- 哈希表能解决什么问题

  - 快速判断一个元素是否出现集合里。
  - 需要查询一个元素是否出现过

- 什么是哈希函数：

  - 哈希函数hash function描述了元素和索引之间的关系。

    哈希函数通过hashCode把元素值转化为哈希表上的索引。

  - 如果hashCode得到的数值大于哈希表的大小了，即索引大过了哈希表的体积，怎么办？

    - 对数值做一个取模操作（即两数相除取余数），得到一个更小的数，就肯定可以映射到哈希表上了

- 什么是哈希碰撞：

  元素的数量大于哈希表的大小，多个元素映射到了同一个索引下。

- 解决哈希碰撞的2种方法

  1. 拉链法Chaining：把散列到同一槽中的所有元素放在一个链表中，而将此链表的头指针放在哈希表T[0…m-1]中
  2. 开放寻址Open Adressing：将所有结点均存放在哈希表T[0…m-1]中.
     - 有线性探测、二次探测以及双重探测。三种技术
     - 即去找一个空位来放置冲突的元素，因此要求哈希表的tableSize必须大于datasize

- 想要哈希法解决问题，常用下面三种数据结构：

  1. 数组

     本身就是可看作是哈希表。

  2. set集合

     c++提供了3种set数据结构

     | 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
     | std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
     | std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

     - 红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。
     - 优先使用[unordered_set](http://c.biancheng.net/view/7250.html)，因为它的查询和增删效率最优。

       如果要求集合有序，就用set。

       如果要求集合有序且有重复数据，就用multiset。
     - set这一大类的数据结构，所有的元素只有key，没有value, key即value

  3. map映射

     c++提供了3种map数据结构

     | 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
     | std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
     | std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

     - 所有的元素都是key :value
       - 所以当题目不仅要找到那个元素，还要直到下标时，用map而不用set。
     - map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

- 哈希法可以快速判断元素是否在集合里，但它**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找

## 2.有效的字母异位词

- 题目：242.Valid Anagram字谜

  给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

  注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

  示例：

  ```
  输入: s = "anagram", t = "nagaram"
  输出: true
  
  输入: s = "rat", t = "car"
  输出: false
  ```

- 解题：

  - 暴力的解法，两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。

  - 利用哈希表来做：

    **数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组record，来记录字符串s里字符出现的次数。**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**

    - 遍历 s 时：**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。**
    - 遍历 t 时：，对t中出现的字符映射哈希表索引上的数值再做-1的操作。
    - 最后检查record数组是否所有元素都为0，如果不是那就说明s和t不是字母异位词。

    ```c++
    class Solution {
    public:
        bool isAnagram(string s, string t) {
            vector<int> record(26,0);
            for (int i = 0; i < s.size(); i++) {
                // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
                record[s[i] - 'a']++;
            }
            for (int i = 0; i < t.size(); i++) {
                record[t[i] - 'a']--;
            }
            for (int i = 0; i < 26; i++) {
                if (record[i] != 0) {
                    // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                    return false;
                }
            }
            // record数组所有元素都为零0，说明字符串s和t是字母异位词
            return true;
        }
    };
    ```


## 3.两个数组的交集

- 题目：349.Intersection of Two Arrays

  给定2个数组，求数组中都有哪些相同的值(值范围是`0 <= nums1[i], nums2[i] <= 1000`)

  ```
  Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
  Output: [9,4]
  Explanation: [4,9] is also accepted.
  ```

- 解题

  - **用数组的做法**：

    1. 记录nums1中出现的值，每个值只记录一次
    2. 记录nums2中出现的值，每个值只记录一次
    3. 最后record中值为2的，就是两个数组中都有的值。

    ```c++
    class Solution {
    public:
        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
            vector<int> record(1000,0);
            for(int i=0; i <nums1.size(); i++){	// 1. 记录nums1中出现的值，每个值只记录一次
                if(record[nums1[i]]==0)
                    record[nums1[i]]++;
            }
            for(int i=0; i<nums2.size(); i++){	// 2. 记录nums2中出现的值，每个值只记录一次
                if(record[nums2[i]]==1)
                    record[nums2[i]]++;
            }
            vector<int> ans;
            for(int i=0; i<1000;i++){			// 3. 最后record中值为2的，就是两个数组中都有的值。
                if(record[i]==2)
                    ans.push_back(i);
            }
            return ans;
        }
    };
    ```

  - **用集合set的做法**：

    - 相比于数组，set解决了如下问题：

      1. 如果值得范围没有限制，我们就无法给定一个确定范围的record
      2. 如果数据集分布的很散，会浪费大量的数组空间

    - 根据1中理论可知，unordered_set 读写效率是最高的，并不需要对数据进行排序

      而本题不需要排序数据，且数据不重复，所以使用unordered_set

    ```c++
    class Solution {
    public:
        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
            unordered_set<int> result;		// 空集合，用于记录要填充的数字
            unordered_set<int> record(nums1.begin(),nums1.end());	// nums1.begin()返回头迭代器，nums1.end()返回尾迭代器。如此把nums1所有的值放入无序集合record里
            
            for(int nums:nums2){	// 冒号:是c++11中新加的用法，对可迭代对象，方便循环。
                if(record.find(nums) != record.end()){	//set.find(xx)如果没找到xx会返回指向尾节点的迭代器，否则返回指向xx的迭代器
                    result.emplace(nums);	//将数值加入到record集合中去
                }
            }
            return vector<int>(result.begin(),result.end());
        }
    };
    ```

    - 相比于数组，set不仅占用空间比数组大，而且速度更慢，set把数值映射到key上都要做hash计算的。

  - **结构数组和set去重的特性**

    ```c++
    class Solution {
    public:
        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
            unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
            int hash[1005] = {0}; // 默认数值为0
            for (int num : nums1) { // nums1中出现的字母在hash数组中做记录
                hash[num] = 1;
            }
            for (int num : nums2) { // nums2中出现话，result记录
                if (hash[num] == 1) {
                    result_set.insert(num);
                }
            }
            return vector<int>(result_set.begin(), result_set.end());
        }
    };
    ```


## 4.快乐数

- 题目：202.Happy Number

  - 编写一个算法来判断一个数 n 是不是快乐数。
  - 快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。

  - 如果 n 是快乐数就返回 True ；不是，则返回 False 

  ```c++
  Input: n = 19
  Output: true
  Explanation:
  12 + 92 = 82
  82 + 22 = 68
  62 + 82 = 100
  12 + 02 + 02 = 1
  ```

- 解题：

  - 找不到1时会无限循环，即sum会重复。

    所以我们就可以用哈希法快速判断一个元素是否出现在集合里

    ```c++
    class Solution {
    public:
        int getSum(int n){			// 求1个数每一位的平方和
            int sum = 0;
            while(n){
                sum +=(n%10)*(n%10);
                n /= 10;
            }
            return sum;
        }
        bool isHappy(int n) {
            unordered_set<int> record;
            if(n==1) return true;
            while(n!=1){
                n = getSum(n);
                if(record.find(n)==record.end()){	//判断是否重复，如果不重复则继续求和，直到找到1
                    record.emplace(n);
                }
                else{
                    return false;
                }
            }
            return true;
        }
    };
    ```

## 5.两数之和

- 题目：Two Sum

  给定一个包含各个数字的数组 和 一个目标数，求数组中哪些组合的和为目标数

  这里每一个目标，只有唯一解。

  ```
  Input: nums = [2,7,11,15], target = 9
  Output: [0,1]
  Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
  ```

- 解题：

  - 暴力法：两层for

    复杂度为$o(n^2)$

  - 用哈希法

    - 为什么用哈希法？

      因为是两数之和，所以只要1.在遍历数组时，2.找一下那个数对应的数在不在集合里就行了。而查看数是否出现过，显然是哈希法的应用场景。

    - 为什么用map来实现哈希法？

      - 数组：数组大小受限，如果元素很少而值很大时，会浪费大量空间

        因为哈希法时，元素值对应的是数组的下标。

      - set: 题目要求返回数组中那2个数的下标。

        显然set的值就是其key，无法返回下标

      - map:是一种key value的存储结构，符合题目要求。

        - key：存数组下标
        - value:存该下标对应的数组值

    ```c++
    class Solution {
    public:
        vector<int> twoSum(vector<int>& nums, int target) {
            unordered_map<int,int> map;
            vector<int> ans;
            for(int i =0;i<nums.size();i++){ 		// 1. 遍历数组 
                int j = target - nums[i];
                if(map.find(j) != map.end()){		// 2. 找一下那个数对应的数在不在集合里
                    return{map.find(j)->second,i};	// 如果在就找到了，返回索引
                }
                map.emplace(pair<int, int>(nums[i], i));	// 不在就加入到map里去
            }
            return {};
        }
    };
    ```

    



# 四、字符串

## 1.理论基础

- 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组

## 2. 反转字符串

- 题目：344:Reverse String

  编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

  不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

  示例：

  ```
  输入：s = ["h","e","l","l","o"]
  输出：["o","l","l","e","h"]
  
  输入：s = ["H","a","n","n","a","h"]
  输出：["h","a","n","n","a","H"]
  ```

- 题解

  使用库函数的原则：**如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。**

  - 使用reverse库函数：

    ```c++
    class Solution {
    public:
        void reverseString(vector<char>& s) {
            reverse(s.begin(),s.end());
        }
    };
    ```

  - 使用swap库函数

    ```c++
    class Solution {
    public:
        void reverseString(vector<char>& s) {
            for(int i=0,j=s.size()-1;i<s.size()/2;i++,j--){
                swap(s[i],s[j]);
            }
        }
    };
    
    // swap()实现的两种原理：
    //1. 中间值
    int tmp = s[i];
    s[i] = s[j];
    s[j] = tmp;
    //2. 位运算：异或
    s[i] ^= s[j];
    s[j] ^= s[i];
    s[i] ^= s[j];
    ```

    

# 五、双指针法

## 1.理论基础

- 双指针法并不隶属于某一种数据结构，但数组，链表，字符串都会用到双指针法

## 2. 移除元素

- 题目：27:Remove Element

  给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

  不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

  元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

  示例：

  ```
  输入：nums = [3,2,2,3], val = 3
  输出：2, nums = [2,2]
  解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
  
  输入：nums = [0,1,2,2,3,0,4,2], val = 2
  输出：5, nums = [0,1,4,0,3]
  解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
  ```

- 题解

  - 暴力方法：
  
    用2个for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。将val值移到数组的最后面。
  
    时间复杂度：O(n^2)
  
    ```c++
    class Solution {
    public:
        int removeElement(vector<int>& nums, int val) {
            int size = nums.size();
            for(int i=0;i<size;i++){
                if(nums[i]==val){
                    for(int j=i;j<size;j++){
                        nums[i]=nums[j];
                    }
                    i--;	// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                    size--;	// 此时数组的大小-1
                }
            }
            return size;
        }
    };
    ```
  
  - 双指针法：
  
    通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。
  
    核心思想就是：慢指针指向要处理的val值。快指针遍历整个数组，将不是val的值覆盖掉慢指针指向的val值。
  
    时间复杂度：O(n)。空间复杂度：O(1)
  
    ```c++
    class Solution {
    public:
        int removeElement(vector<int>& nums, int val) {
            int slowindex = 0;
            for(int fastindex=0;fastindex < nums.size(); fastindex++){
                // 如果不是val值，两个指针会一起往前进。
    			// 如果是val值，快指针移到下一个，慢指针仍指向val值。
                // 直到快指针移到下一个不是val值的地方，然后慢指针指向的val值会被该值覆盖掉。
                // 最后2个指针再往前移动处理下一个val值。
                if(val != nums[fastindex]){
                    nums[slowindex++]=nums[fastindex];
                }
            }
            return slowindex;
        }
    };
    ```
  
  - 类似题：
  
    - 26.删除排序数组中的重复项
    - 283.移动零
    - 844.比较含退格的字符串
    - 977.有序数组的平方
  
  

# 六、栈与队列

## 1.理论基础

- 队列是先进先出，栈是先进后出。
- **栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**
  - 栈的底层实现可以是vector，deque，list 
  - 栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。
  - 所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）
  - 我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构
  - deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。
  - 指定其他底层实现：
    - 指定vector为栈的底层实现：`std::stack<int, std::vector<int> > third;`
    - 指定list 为队列的底层实现：`std::queue<int, std::list<int>> third; `
- **SGI STL中 队列底层实现缺省情况下一样使用deque实现的。**
  - 同样不允许有遍历行为，不提供迭代器

## 2.用栈实现队列

- 题目 232:Implement Queue using Stacks

  实现 MyQueue 类：

  - void push(int x) 将元素 x 推到队列的末尾
    int pop() 从队列的开头移除并返回元素
    int peek() 返回队列开头的元素
    boolean empty() 如果队列为空，返回 true ；否则，返回 false

  示例

  ```
  输入：
  ["MyQueue", "push", "push", "peek", "pop", "empty"]
  [[], [1], [2], [], [], []]
  输出：
  [null, null, null, 1, 1, false]
  ```

- 题解

  用一个栈来模拟队列的功能是不现实的，必须用1个输入栈1个输出栈来模拟。

  ```c++
  class MyQueue {
  private:
      stack<int> stIn;
      stack<int> stOut;
  public:
      MyQueue() {
  
      }
      //在push数据的时候，只要数据放进输入栈就好
      void push(int x) {
          stIn.push(x);
      }
      //输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。
      int pop() {
          if(stOut.empty()){
              while(!stIn.empty()){
                  stOut.push(stIn.top());           
                  stIn.pop();
              }
          }
          int result = stOut.top();
          stOut.pop();
          return result;
      }
      // 区别于pop就是头元素不删除
      int peek() {
          if(stOut.empty()){
              while(!stIn.empty()){
                  stOut.push(stIn.top());           
                  stIn.pop();
              }
          }
          int result = stOut.top();
          return result;
      }
      // 2个栈都是空的，那队列就是空的
      bool empty() {
          if(stOut.empty()&&stIn.empty())
              return true;
          else
              return false;
      }
  };
  
  ```
  
  
  
  
  
  
  
  

# 七、二叉树

## 1.理论基础

- 二叉树的种类
  - 满二叉树：如果一棵二叉树只有度为0的结点（国外定义，国内度必须是2）和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
    - 度：即有几个子节点
    - 深度为k，有2^k-1个节点
  - 完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层**最左边**的若干位置。
    - 堆就是一棵完全二叉树，同时保证父子节点的顺序关系
  - 二叉搜索树：二叉搜索树是一个有有序数值的有序树
    - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
    - 它的左、右子树也分别为二叉排序树
  - 平衡二叉树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
    - C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树。所以map、set的增删操作时间时间复杂度是logn
      - unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。

- 二叉树的存储方式

  - 二叉树可以链式存储，也可以顺序存储。链式存储方式就用指针， 顺序存储的方式就是用数组。
  - 如果用数组来存储：如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2
  - 一般使用链式存储二叉树

- 二叉树的遍历方式

  - 深度优先遍历：使用递归的方式或借助栈使用非递归的方式来实现

    **这里前中后，其实指的就是中间节点的遍历顺序**

    - 前序遍历（递归法，迭代法）中间节点的顺序：中左右
    - 中序遍历（递归法，迭代法）中间节点的顺序：左中右
    - 后序遍历（递归法，迭代法）中间节点的顺序：左右中

  - 广度优先遍历：使用队列来实现

    - 层次遍历（迭代法）

- 二叉树的定义：

  ```c++
  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };
  ```

  

# 八、回溯算法

## 1.理论基础

- 回溯算法也叫回溯搜索法，是递归的副产品。

  - 回溯的本质是穷举，琼剧所有的可能，然后选出想要的答案。所以效率不高。

- 回溯法，一般解决如下问题：

  - 组合问题：N个数里面按一定规则找出k个数的集合。组合无序
  - 切割问题：一个字符串按一定规则有几种切割方式
  - 子集问题：一个N个数的集合里有多少符合条件的子集
  - 排列问题：N个数按一定规则全排列，有几种排列方式。排列有序
  - 棋盘问题：N皇后，解数独等等

  所有回溯法的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

- 回溯函数做题模板

  ```c++
  // 第一步：回溯函数模板返回值以及参数
  // 因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
  void backtracking(参数) {
      // 第二步：回溯函数终止条件
      // 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
      if (终止条件) {
          存放结果;
          return;
      }
  	
      // 第三步：回溯搜索的遍历过程
      // 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
      for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
          处理节点;
          backtracking(路径，选择列表); // 递归
          回溯，撤销处理结果
      }
  }
  ```
  
  
  

# 九、贪心算法

## 1.理论基础

- **贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。
  - 贪心算法并没有固定的套路。所以唯一的难点就是如何通过局部最优，推出整体最优。
- 如何验证可不可以用贪心?
  - **最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**
  - 严谨的话需要数学证明
    - 数学归纳法
    - 反证法
- 一般截图步骤
  - 将问题分解为若干个子问题
  - 找出适合的贪心策略
  - 求解每一个子问题的最优解
  - 将局部最优解堆叠成全局最优解

  
  
# 十、动态规划

Dynamic Programming,简称dp

## 1.理论基础

### 1.1 基本思想

参考：https://www.zhihu.com/question/23995189

- **什么是DP？**

  将一个问题拆分成几个子问题，分别求解这些子问题的最优解，就可以得到总问题的最优解。

- **什么问题可以用DP来解决？**

  这个问题可以拆成几个小问题，且满足无后效性、最优子结构性质。

  - 无后效性：未来与过去无关，即如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。

    求得了f(n)就固定住了,f(n-1)...f(n-x)的值不管怎么样都对f(n)无影响了。

  - 最优子结构：大问题的最优解可以由小问题的最优解推出

- **DP为什么比暴力快**

  - 无论是DP还是暴力，我们的算法都是在可能解空间内，寻找最优解。

  - 暴力做法是枚举所有的可能解，这是最大的可能解空间。　

  - 而DP是枚举有希望成为答案的解，这个空间比暴力的小得多。

  - 比如用尽可能少的5,1,11来组成15：

    - 暴力会考虑：15 = 5+5+1+1+1+1+1
    - 而DP不会，因为这不可能是最优解

  - **DP的核心思想**：**尽量缩小可能解空间**

    一般来说，解空间越小，寻找解就越快。这样就完成了优化。

- **如何设计DP**

  - 第一步：设计状态：我是谁

  - 第二步：设计转移：有2种方式：
    1. 我从哪里来，又称pull型转移
    2. 我要到哪里去，又称push型转移

  **例子：用尽可能少的5,1,11元来组成15元：**

  - 第一步：设计状态

    用f(n)来表示凑出n所需的最少钞票数量

  - 第二步：设计转移，这里使用第一种方式，即我从哪里来

    - f(15)有三种情况：

      - 取11:f(15)=f(4)+1 =4+1=5
      - 取5: f(15)=f(10)+1=2+1=3
      - 取1: f(15)=f(14)+1=4+1=5

      显然我们要取cost最小的那个，即5.

    - 这就给了我们启示：f(n)只和f(n-1).f(n-5),f(n-11)有关

      也即我们的**转移方程**：$f(n)=min\{f(n-1),f(n-5),f(n-11) \}+1$

  - 利用上面的转移方程，我们要求出f(n)，只需要求出几个更小的f值：既然如此，我们从小到大把所有的f(x)求出来不就好了？

    ```c
    int f[105],i,n,cost;
    scanf("%d",&n);	// n是希望凑的数值，比如这里是15
    f[0]=0;			// 从最小的0开始网上凑，每一个i需要用到1，5，11的最小次数
    for(i=1;i<=n;i++){
        cost = INF;
        if(i-1>=0) cost = min(cost, f[i-1]+1);
        if(i-5>=0) cost = min(cost, f[i-5]+1);
        if(i-11>=0)cost = min(cost, f[i-11]+1);		// 之所以要用min,对应于转移方程，比如15在上个if就求出了更小的cost
        f[i] = cost;
    }
    ```

    

### 1.2 解题思路

- 如果某一问题有很多重叠子问题，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的.

- 解题步骤
  1. 确定dp数组（dp table）以及下标的含义
  2. 确定递推公式
  3. dp数组如何初始化
  4. 确定遍历顺序
  5. 举例推导dp数组

- 动态规划如何debug

  - **做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

  - 然后再写代码，如果代码没通过就**打印dp数组**，看看是不是和自己预先推导的哪里不一样。

    - 如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。
    - 如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

  - 具体debug时问自己三个问题

    1. 这道题目我举例推导状态转移公式了么？
    2. 我打印dp数组的日志了么？
    3. 打印出来了dp数组和我想的一样么？

    
