# 零、学习资源汇总

- 主体：[代码随想录](https://www.programmercarl.com/)

## 一些重要概念的索引

- KMP：见第四章(字符串)的7
- 递归：见第七章(二叉树)的2

# 一、数组

## 1.理论基础

- 数组是存放在连续内存空间上的相同类型数据的集合
  - 数组下标都是从0开始的。
  - 数组内存空间的地址是连续的
  - 数组的元素是不能删的，只能覆盖！
    - 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）
  
- 二分法：
  - **循环不变量原则**，只有在循环中坚持对区间的定义
  
- 双指针法：
  - 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作
  
- 滑动窗口
  - 滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。
  
- 总结图：

  <img src="https://github.com/Fernweh-yang/Reading-Notes/blob/main/%E7%AC%94%E8%AE%B0%E9%85%8D%E5%A5%97%E5%9B%BE%E7%89%87/Algorithm/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png?raw=true"  />

## 2.二分查找

### 2.1 题目：704 Binary Search

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 `nums` 中的所有元素是不重复的。

示例

```
示例1：
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4

示例2：
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

### 2.2 暴力搜索

#### 2.2.1 C++

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        for(vector<int>::iterator iter = nums.begin(); iter!=nums.end(); iter++){
            # 读取迭代器的值，用指针
            if(*iter==target)
                # 返回迭代器的下标
                return distance(nums.begin(),iter);
        }
        return -1;
    }
};
```

#### 2.2.2 python

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        for i in nums:
            if i == target:
                return nums.index(i)
        return -1
```

### 2.2 解题：二分法

- **这道题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，这些都是使用二分法的前提条件。

- **循环不变量规则**：**区间的定义是不变量**，在while寻找中每一次边界的处理都要坚持根据区间的定义来操作。二分法，区间的定义一般为两种：

  1. 左闭右闭即[left, right]
  2. 左闭右开即[left, right)

- 第一种解法：左闭右闭[left, right]

  区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

  - while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
  - if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int left = 0;
          int right = nums.size()-1;	//2种写法的区别
          int middle
          while(left <= right){
              middle = left + ((right - left) / 2);
              if(nums[middle]>target){
                  right = middle - 1;	//2种写法的区别
              }
              else if(nums[middle]<target){
                  left = middle + 1;
              }
              else
                  return middle;
          }
          return -1;
  
      }
  };
  ```
  ```python
  class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)-1
        while left <= right:
            middle = int(left + (right - right)/2)
            if nums[middle] == target:
                return middle
            elif nums[middle] < target:
                left = middle+1
            else:
                right = middle -1
        return -1 
  ```

- 第二种解法：左闭右开[left, right)

  有如下两点：

  - while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的，即right代表的那个数是不考虑在内的。
  - if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

  ```c++
  class Solution {
  public:
      int search(vector<int>& nums, int target) {
          int left = 0;
          int right = nums.size(); 	//2种写法的区别
          int middle
          while(left < right){
              middle = left + ((right - left) / 2);
              if(nums[middle]>target){
                  right = middle ;	//2种写法的区别
              }
              else if(nums[middle]<target){
                  left = middle + 1;
              }
              else
                  return middle;
          }
          return -1;
  
      }
  };
  ```
  ```python
  class Solution:
    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        while left < right:
            middle = int(left + (right - right)/2)
            if nums[middle] == target:
                return middle
            elif nums[middle] < target:
                left = middle+1
            else:
                right = middle 
        return -1 
  ```

### 2.3 相似题：

- 35.搜索插入位置-Search Insert Position
- 34.在排序数组中查找元素的第一个和最后一个位置-Find First and Last Position of Element in Sorted Array
- 69.x 的平方根-Sqrt(x)
- 367.有效的完全平方数-Valid Perfect Square

## 3.移除元素

### 3.1 题目：27 Remove Element

给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

- 说明：

  为什么返回数值是整数，但输出的答案是数组呢?

  请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

  你可以想象内部操作如下:

  ```
  // nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
  int len = removeElement(nums, val);
  
  // 在函数里修改输入数组对于调用者是可见的。
  // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
  for (int i = 0; i < len; i++) {
      print(nums[i]);
  }
  ```

- 示例

  ```
  输入：nums = [3,2,2,3], val = 3
  输出：2, nums = [2,2]
  解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
  
  输入：nums = [0,1,2,2,3,0,4,2], val = 2
  输出：5, nums = [0,1,4,0,3]
  解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
  ```

### 3.2 解题：双指针

- 第一种解法：暴力解法

  用两层for循环，第一层便利数组元素，第二层更新数组

  时间复杂度O(n^2)

- 第二种解法：双指针法（快慢指针）

  **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

  - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
  - 慢指针：指向更新新数组下标的位置(即目标元素的位置)

  ```c++
  class Solution {
  public:
      int removeElement(vector<int>& nums, int val) {
          int slowIndex=0;
          for(int fastIndex=0;fastIndex<nums.size();fastIndex++){
              if(nums[fastIndex]!=val){
                  nums[slowIndex++]=nums[fastIndex];
              }
          }
          return slowIndex;
      }
  };
  ```
  ```python
  class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        fast = 0
        slow = 0
        while fast < len(nums):
            if nums[fast]!= val:
                nums[slow] = nums[fast]
                slow +=1
            fast +=1
        return slow 
  ```
- 第三种解法:双指针(两端向中间)
  - 左指针：找要删除的值
  - 右指针：找不删除的值，然后两者交换
  ```c++
  class Solution {
  public:
      int removeElement(vector<int>& nums, int val) {
          int left =0;
          int right = nums.size()-1;
          while(left<=right){
              if(nums[right]==val)
                  right--;
              else{
                  if(nums[left]==val){
                      nums[left] = nums[right];
                      left++;
                      right--;
                  }else{
                      left++;
                  }
              }
          }
          return left;
      }
  };
  ```
  ```python
  class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        left = 0
        right = len(nums)-1
        while left <= right:
            if nums[right] == val:
                right = right -1
            elif nums[left] == val:
                nums[left] = nums[right]
                left = left + 1
                right = right -1
            else:
                left = left + 1
        return left
            
  ```

### 3.3 相似题：

- 26.删除排序数组中的重复项
- 283.移动零
- 844.比较含退格的字符串
- 977.有序数组的平方



## 4.有序数组的平方

### 4.1 题目：977 Squares of a Sorted Array

给你一个按 **非递减顺序non-decreasing** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

- 示例

  ```
  输入：nums = [-4,-1,0,3,10]
  输出：[0,1,9,16,100]
  解释：平方后，数组变为 [16,1,0,9,100]
  排序后，数组变为 [0,1,9,16,100
  
  输入：nums = [-7,-3,2,3,11]
  输出：[4,9,9,49,121]
  ```

### 4.2 解题：双指针

- 第一种解法：暴力解法

  每个数平方后，再排序

  ```c++
  class Solution {
  public:
      vector<int> sortedSquares(vector<int>& nums) {
          for(int i=0;i<nums.size();i++){
              nums[i]*=nums[i];
          }
          sort(nums.begin(),nums.end()); #快速排序
          return nums;
      }
  };
  ```

  时间复杂度：O(n+log(n))

- 第二种解法：双指针法

  数组其实是有序的， 只不过负数平方之后可能成为最大数了。

  那么数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

  此时可以考虑双指针法了，left指向起始位置，right指向终止位置。

  定义一个新数组result，和A数组一样的大小，让k指向result数组终止位置。

  如果`A[left] * A[left] < A[right] * A[right]` 那么`result[k--] = A[right] * A[right];` 。

  如果`A[left] * A[left] >= A[right] * A[right]` 那么`result[k--] = A[left] * A[left];` 。

  ```c++
  class Solution {
  public:
      vector<int> sortedSquares(vector<int>& nums) {
          int k = nums.size()-1;
          vector<int> results(nums.size(),0);
          for(int left=0,right=nums.size()-1; left<=right; ){
              if(nums[left]*nums[left]<=nums[right]*nums[right]){
                  results[k--]=nums[right]*nums[right];
                  right--;
              }
              else{
                  results[k--]=nums[left]*nums[left];
                  left++;
              }
          }
          return results;
      }
  };
  ```
  ```python
  class Solution:
      def sortedSquares(self, nums: List[int]) -> List[int]:
          i = len(nums)-1
          temp = [0] * (i+1)
          left = 0
          right = i
          while left <= right:
              if nums[left]*nums[left] <= nums[right]*nums[right]:
                  temp[i] = nums[right]*nums[right]
                  i -=1
                  right -=1
              else:
                  temp[i] = nums[left]*nums[left]
                  i-=1
                  left+=1
          return temp
  ```

## 5.长度最小的子数组

### 5.1 题目：209 Minimum Size Subarray Sum

给定一个含有 n 个正整数的数组和一个正整数(positive integer) target 。

找出该数组中满足其和 ≥ target 的长度最小的连续子数组(contiguous subarray) [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

- 示例

  ```
  输入：target = 7, nums = [2,3,1,2,4,3]
  输出：2
  解释：子数组 [4,3] 是该条件下的长度最小的子数组。
  
  输入：target = 4, nums = [1,4,4]
  输出：1
  
  输入：target = 11, nums = [1,1,1,1,1,1,1,1]
  输出：0
  ```

### 5.2 解题：滑动窗口

- 第一种解法：暴力解法：用2个for循环，不断寻找符合条件的子序列

  时间复杂度O(n^2)

  ```c++
  class Solution {
  public:
      int minSubArrayLen(int s, vector<int>& nums) {
          int result = INT32_MAX; // 最终的结果
          int sum = 0; // 子序列的数值之和
          int subLength = 0; // 子序列的长度
          for (int i = 0; i < nums.size(); i++) { // 设置子序列起点为i
              sum = 0;
              for (int j = i; j < nums.size(); j++) { // 设置子序列终止位置为j
                  sum += nums[j];
                  if (sum >= s) { // 一旦发现子序列和超过了s，更新result
                      subLength = j - i + 1; // 取子序列的长度
                      result = result < subLength ? result : subLength;
                      break; // 因为我们是找符合条件最短的子序列，所以一旦符合条件就break
                  }
              }
          }
          // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
          return result == INT32_MAX ? 0 : result;
      }
  };
  ```

- 第二种解法：滑动窗口

  所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。滑动窗口也可以理解为双指针法的一种。只不过这种解法更像是一个窗口的移动，所以叫做滑动窗口更适合一些。

  如果只用一个for循环来表示滑动窗口的起始位置，那么此时难免再次陷入暴力解法的怪圈。

  所以只用一个for循环，那么这个循环的索引，一定是表示滑动窗口的终止位置。

  在本题中实现滑动窗口，主要确定如下三点：

  - 窗口内是什么？

    窗口就是满足其和 ≥ s 的长度最小的连续子数组。

  - 如何移动窗口的起始位置？

    窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

  - 如何移动窗口的结束位置？

    窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

  **滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)暴力解法降为O(n)。**

  ```c++
  class Solution {
  public:
      int minSubArrayLen(int s, vector<int>& nums) {
          int result = INT32_MAX;
          int sum = 0; // 滑动窗口数值之和
          int i = 0; // 滑动窗口起始位置
          int subLength = 0; // 滑动窗口的长度
          for (int j = 0; j < nums.size(); j++) {
              sum += nums[j];
              // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
              // 虽然for里放了一个while，但看元素被操作的次数是一进一出2次，所以是2n即o(n)
              while (sum >= s) {
                  subLength = (j - i + 1); // 取子序列的长度
                  result = result < subLength ? result : subLength;
                  sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
              }
          }
          // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
          return result == INT32_MAX ? 0 : result;
      }
  };
  ```

### 5.3 相似题：

- 904.水果成篮
- 76.最小覆盖子串

## 6.螺旋矩阵2

### 6.1 题目：59 Spiral Matrix II

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

- 示例：

  ```
  输入：n = 3
  输出：[[1,2,3],[8,9,4],[7,6,5]]
  
  输入：n = 1
  输出：[[1]]
  ```

### 6.2 解题：

本题并不涉及到什么算法，就是模拟过程。

模拟顺时针画矩阵的过程:

- 填充上行从左到右
- 填充右列从上到下
- 填充下行从右到左
- 填充左列从下到上

由外向内一圈一圈这么画下去。

和二分法一样，本题要坚持**循环不变量**的原则。即我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的**左闭右开，或者左开右闭**的原则，这样这一圈才能按照统一的规则画下来。

按**左闭右开**的原则即处理到每一个拐角时：拐角处让给新的一条边来继续画。

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j = starty; j < n - offset; j++) {
                res[startx][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i = startx; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

### 6.3 相似题

- 54.螺旋矩阵
- 剑指Offer 29.顺时针打印矩阵



## 7.总结：

- **数组是存放在连续内存空间上的相同类型数据的集合。**

  - 一维数组的地址是连续的
  - 二维数组的地址不一定连续。
    - 矩阵每行上的元素地址是连续的
    - 但是行与行之间的地址不一定连续

- **数组的元素是不能删的，只能覆盖。**

  - 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）。

- 上面总共列举了四种数组题目

  1. 二分法(2)

     **循环不变量原则**，只有在循环中坚持对区间的定义，才能清楚的把握循环中的各种细节。

  2. 双指针法(3,4)

     **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

  3. 滑动窗口(5)

     **滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。**

  4. 模拟行为(6)

     不涉及到什么算法，就是单纯的模拟。要遵守**循环不变量原则**

# 二、链表

## 1.理论基础

- 链表类型

  1. 单链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）
     - 链接的入口节点称为链表的头结点也就是head。

  2. 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。
     - 双链表既可以向前查询也可以向后查询。

  3. 循环链表：链表首尾相连。
     - 循环链表可以用来解决约瑟夫环问题。

- 链表的存储方式

  链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

- 链表的定义

  ```c++
  struct ListNode {
      int val;  // 节点上存储的元素
      ListNode *next;  // 指向下一个节点的指针
      ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
  };
  ```

- 性能分析

  | 时间复杂度 | 插入/删除 | 查询 | 适用场景                         |
  | ---------- | --------- | ---- | -------------------------------- |
  | 数组       | O(n)      | O(1) | 数据量固定，频繁查询，较少增删   |
  | 链表       | O(1)      | O(n) | 数据量不固定，频繁增删，较少查询 |

  - 数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

  - 链表的长度可以是不固定的，并且可以动态增删， 

- 总结图

  ![](https://github.com/Fernweh-yang/Reading-Notes/blob/main/%E7%AC%94%E8%AE%B0%E9%85%8D%E5%A5%97%E5%9B%BE%E7%89%87/Algorithm/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png?raw=true)

## 2.移除链表元素

- 题目：203：Remove Linked List Elements

  给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
  
  示例：
  
  ```
  示例1：
  输入：head = [1,2,6,3,4,5,6], val = 6
  输出：[1,2,3,4,5]
  
  示例2：
  输入：head = [], val = 1
  输出：[]
  
  示例3：
  输入：head = [7,7,7,7], val = 7
  输出：[]
  ```
  
- 解题：

  - 设立一个虚拟头节点来保证，处理任何节点都是同一个思路。会比直接操作原链表更方便

    ```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    // 第一种做法：直接操作原链表
    class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            // 需要单独处理头节点
            while(head!=NULL && head->val == val){
                ListNode* tmp = head;
                head = head->next;
                delete tmp;
            }
            // 然后再处理后面的节点
            ListNode* cur = head;
            while(cur!=NULL && cur->next!=NULL){
                if(cur->next->val==val){
                    ListNode* tmp = cur->next;
                    cur->next = cur->next->next;
                    delete tmp;
                }
                else
                    cur = cur->next;
            }
            return head;
        }
    };
    
    // 第二种做法：设疑一个虚拟头节点
    class Solution {
    public:
        ListNode* removeElements(ListNode* head, int val) {
            ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
            dummyHead->next = head; // 将虚拟头结点指向head，这样方面后面做删除操作
            ListNode* cur = dummyHead;
            while (cur->next != NULL) {
                if(cur->next->val == val) {
                    ListNode* tmp = cur->next;
                    cur->next = cur->next->next;
                    // malloc/free->new/delete。delete不仅可以释放内存，还可以在对对象时自动调用析构函数
                    delete tmp;
                } else {
                    cur = cur->next;
                }
            }
            head = dummyHead->next;
            delete dummyHead;
            return head;
        }
    };
    ```
    

## 3.设计链表

- 题目：707.Design Linked List

  设计一个自己的链表类，它有如下方法：

  - `MyLinkedList()` Initializes the `MyLinkedList` object.
  - `int get(int index)` Get the value of the `indexth` node in the linked list. If the index is invalid, return `-1`.
  - `void addAtHead(int val)` Add a node of value `val` before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
  - `void addAtTail(int val)` Append a node of value `val` as the last element of the linked list.
  - `void addAtIndex(int index, int val)` Add a node of value `val` before the `indexth` node in the linked list. If `index` equals the length of the linked list, the node will be appended to the end of the linked list. If `index` is greater than the length, the node **will not be inserted**.
  - `void deleteAtIndex(int index)` Delete the `indexth` node in the linked list, if the index is valid.

- 解题：

  ```c++
  class MyLinkedList {
  public:
      struct ListNode{    //用结构体来实现链表
          int val;
          ListNode *next;
          ListNode(int x):val(x),next(nullptr){}
      };
  
      MyLinkedList() {
          _dummyHead = new ListNode(0);   // 头节点使用虚拟节点有助于统一每个节点的操作
          _size=0;  						// 用于判断访问的index是否合法
      }
      
      int get(int index) {				// 注意index是从0开始的，第0个节点就是头结点
          if(index < _size && index >=0){
              ListNode* cur = _dummyHead->next; // 所以从虚拟节点的next开始
              while(index--){
                  cur = cur->next;
              }
              return cur->val;
          }
          else
              return -1;
      }
      
      void addAtHead(int val) {			
          ListNode* newHead = new ListNode(val);
          newHead->next = _dummyHead->next; //这里就体现了虚拟头节点的好处, 不用用一个中间节点来删减头节点的方式转换头节点。
          _dummyHead->next = newHead;
          _size++;
      }
      
      void addAtTail(int val) {
          ListNode* cur = _dummyHead;
          while(cur->next!=nullptr){		  // 一路找到最后那个节点先
              cur = cur->next;
          }
          ListNode* newTail = new ListNode(val);
          cur->next = newTail;
          _size++;
      }
      
      void addAtIndex(int index, int val) {	// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
          if(index <0 || index>_size){
              return;
          }
          ListNode* cur = _dummyHead;
          ListNode* newNode = new ListNode(val);
          while(index--){				// 一路找到index对应的节点先
              cur = cur->next;
          }
          newNode->next = cur->next;
          cur->next = newNode;
          _size++;
      }
      
      void deleteAtIndex(int index) {	// 注意index是从0开始的
          if(index <0 || index>=_size){
              return;
          }
          ListNode* cur = _dummyHead;
          while(index--){			    // 一路找到index对应的节点先
              cur = cur->next;
          }
          ListNode* temp = cur->next;
          cur->next = cur->next->next;
          delete temp;
          _size--;
      }
  private:    //类方法用到的变量都定义在私有域里
      int _size;  
      ListNode* _dummyHead;
  };
  
  /**
   * Your MyLinkedList object will be instantiated and called as such:
   * MyLinkedList* obj = new MyLinkedList();
   * int param_1 = obj->get(index);
   * obj->addAtHead(val);
   * obj->addAtTail(val);
   * obj->addAtIndex(index,val);
   * obj->deleteAtIndex(index);
   */
  ```

  

## 4.反转链表

- 题目：206.Reverse Linked List

  给予一个链表，反转它

  ```
  Input: head = [1,2,3,4,5]： 1->2->3->4->5
  Output: [5,4,3,2,1]:        5->4->3->2->1
  ```

- 解题：

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
  public:	
      ListNode* reverseList(ListNode* head) {	//用三个指针交替保存各自数据，实现链表反转。
          ListNode* temp ;
          ListNode* pre = nullptr;
          ListNode* cur = head;
          while(cur != nullptr){
              temp = cur->next;
              cur->next = pre;
              pre = cur;
              cur = temp;
          }
          return pre;
      }
  };
  ```

## 5.两两交换链表中的节点

- 题目：24.Swap Nodes in Pairs

  每两个节点之间改变位置：

  ```
  Input: head = [1,2,3,4]
  Output: [2,1,4,3]
  
  Input: head = []
  Output: []
  
  Input: head = [1]
  Output: [1]
  ```

- 解题：

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
  public:
      ListNode* swapPairs(ListNode* head) {
          ListNode* virtualHead = new ListNode(0,head);
          ListNode* cur = virtualHead;
          // 使用虚拟头节点来统一操作
          while(cur->next != nullptr && cur->next->next != nullptr){	//如果下/下下一个为空什么都不操作保持原样就可以
              ListNode* first = cur->next;
              ListNode* second = cur->next->next;
  
              cur->next = second;
              first->next = second->next;
              second->next = first;
  
              cur = cur->next->next;
          }
          return virtualHead->next;	//注意这里return head就不对了，因为18，23行已经把first(head)->next的关系变动了.
      
      }
  };
  ```

## 6.删除链表的倒数第N个节点

- 题目：19. Remove Nth Node From End of List

  给予一个链表，删除从它尾部数起的第n个节点

  ```
  Input: head = [1,2,3,4,5], n = 2
  Output: [1,2,3,5]
  ```

- 解题：

  - 笨办法：
  
    1. 先遍历一遍，有多少个节点
    2. 然后找到要操作的那个节点
  
    ```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
            ListNode* fakeHead = new ListNode(0,head);
            ListNode* cur = fakeHead;
            int i = 0;
            while(cur->next != nullptr){
                i++;
                cur = cur->next;
            }
            cur = fakeHead;
            for(int j=0;j<i-n;j++){
                cur = cur->next;
            }
            ListNode* temp = cur->next;
            cur->next = cur->next->next;
            delete temp;
            return fakeHead->next;
        }
    };
    ```
  
  - 双指针：
  
    1. 如果要删除倒数第n个节点，让fast移动n步，
    2. 然后让fast和slow同时移动，直到fast指向链表末尾。
    3. 删掉slow所指向的节点就可以了。
  
    ```c++
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
            ListNode* fakeHead = new ListNode(0,head);
            ListNode* fast = fakeHead;
            ListNode* low = fakeHead;
            while(n-- && fast!=nullptr){	// 1. 如果要删除倒数第n个节点，让fast移动n步，
                fast = fast->next;
            }
            fast = fast ->next;
            while(fast != nullptr){			// 2. 然后让fast和slow同时移动，直到fast指向链表末尾。
                fast = fast->next;
                low = low->next;
            }
            ListNode* temp = low->next;		// 3. 删掉slow所指向的节点就可以了。
            low->next = low->next->next;	
            delete temp;
            return fakeHead->next;
        }
    };
    ```
  
## 7.链表相交

- 题目：Intersection of Two Linked Lists

  给定两个链表，找到链表中地址相同的节点

- 解题：

  1. 求出两个链表的长度，并求出两个链表长度的差值
  2. 然后让短的移动到，和长的那个列表末尾对齐的位置
  3. 比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
          ListNode* curA = headA;
          ListNode* curB = headB;
          int a=0,b=0;
          
          while(curA !=nullptr){		// 1. 求出两个链表的长度，并求出两个链表长度的差值
              curA = curA->next;
              a++;
          }
          while(curB !=nullptr){
              curB = curB->next;
              b++;
          }
          curA = headA;
          curB = headB;
          
          if(a>=b){					// 2. 然后让短的移动到，和长的那个列表末尾对齐的位置
              int i = a-b;
              while(i-- && curA->next!=nullptr){
                  curA = curA->next;
              }
          }
          else{
              int i = b-a;
              while(i-- && curB->next!=nullptr){
                  curB = curB->next;
              }
          }
          
          while(curA!=nullptr){		// 3. 比较curA和curB是否相同
              if(curA==curB)
                  return curA;
              curA = curA->next;
              curB = curB->next;
          }
          return NULL;
      }
  };
  ```

  

## 8.环形链表

- 题目：Linked List Cycle II

  给定一个链表，如果存在环形结构（即尾节点不指向null，而是指向某一中间节点），找到这个环境结构的起始点（中间节点）,否则返回NULL。

  ```
  Input: head = [3,2,0,-4], pos = 1
  Output: tail connects to node index 1
  Explanation: There is a cycle in the linked list, where tail connects to the second node.
  ```

- 解题:

  1. 首先用快慢指针判断是否有环

     - 快指针：从头结点出发，每次走两步
     - 慢指针：从头节点出发，每次走一步
     - 如果他们相遇，就说明有环。
     - **相对于slow来说，fast是一个节点一个节点的靠近slow的**，所以fast一定可以和slow重合。

  2. 找到入口：

     - 假设相遇时slow走了`x+y`,fast走了`x+y+n(y+z)`

       - x为头节点到环入口点的节点数
       - y为环形入口节点到 fast指针与slow指针相遇节点的节点数
       - z为相遇节点再到环形入口节点节点数
       - n为fast走了多少圈后和slow相遇，n至少1，因为快指针至少饶了一圈才能遇到slow

     - 因为fast速度是slow的两倍，所以有公式：`2(x+y)=x+y+n(y+z)`

     - 整理得到`x = (n - 1) (y + z) + z`

       - 当n=1时，x=z,说明

         **从头结点出发一个指针index1，从相遇节点也出发一个指针index2，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点**。

       - 当n>1时，和n=1一样，

         只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。

  ```c++
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode(int x) : val(x), next(NULL) {}
   * };
   */
  class Solution {
  public:
      ListNode *detectCycle(ListNode *head) {
          ListNode* slow = head;
          ListNode* fast = head;
          while(fast!=nullptr && fast->next!=nullptr){	// 1. 用快慢指针判断是否有环
              slow = slow->next;
              fast = fast->next->next;
              
              if(slow == fast){							// 2. 如果有环，就去找到入口
                  ListNode* index1 = head;
                  ListNode* index2 = fast;
                  while(index1 != index2){
                      index1 = index1->next;
                      index2 = index2->next;
                  }
                  return index1;
              }
          }
          return NULL;
      }
  };
  ```

## 9.总结

- 主要要理解：
  - 链表的种类主要为：单链表，双链表，循环链表
  - 链表的存储方式：链表的节点在内存中是分散存储的，通过指针连在一起。
  - 链表是如何进行增删改查的。(3.设计链表)
  - 数组和链表在不同场景下的性能分析
- **虚拟头节点**：每次对应头结点的情况都要单独处理时，添加虚拟头节点，统一每个节点的操作。

# 三、哈希表

## 1.理论基础

- 什么是哈希表？

  - 哈希表Hash table，也叫散列表，是根据关键码的值而直接进行访问的数据结构

  - 数组就是一个哈希表：关键码就是数组的索引下标，然后通过下标**直接**访问数组中的元素

- 哈希表能解决什么问题

  - 快速判断一个元素是否出现集合里。
  - 需要查询一个元素是否出现过

- 什么是哈希函数：

  - 哈希函数hash function描述了元素和索引之间的关系。

    哈希函数通过hashCode把元素值转化为哈希表上的索引。

  - 如果hashCode得到的数值大于哈希表的大小了，即索引大过了哈希表的体积，怎么办？

    - 对数值做一个取模操作（即两数相除取余数），得到一个更小的数，就肯定可以映射到哈希表上了

- 什么是哈希碰撞：

  元素的数量大于哈希表的大小，多个元素映射到了同一个索引下。

- 解决哈希碰撞的2种方法

  1. 拉链法Chaining：把散列到同一槽中的所有元素放在一个链表中，而将此链表的头指针放在哈希表T[0…m-1]中
  2. 开放寻址Open Adressing：将所有结点均存放在哈希表T[0…m-1]中.
     - 有线性探测、二次探测以及双重探测。三种技术
     - 即去找一个空位来放置冲突的元素，因此要求哈希表的tableSize必须大于datasize

- 想要哈希法解决问题，常用下面三种数据结构：

  1. 数组

     本身就是可看作是哈希表。

  2. set集合

     c++提供了3种set数据结构

     | 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
     | std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
     | std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

     - 红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。
     - 优先使用[unordered_set](http://c.biancheng.net/view/7250.html)，因为它的查询和增删效率最优。

       如果要求集合有序，就用set。

       如果要求集合有序且有重复数据，就用multiset。
     - set这一大类的数据结构，所有的元素只有key，没有value, key即value

  3. map映射

     c++提供了3种map数据结构

     | 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
     | std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
     | std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

     - 所有的元素都是key :value
       - 所以当题目不仅要找到那个元素，还要直到下标时，用map而不用set。
     - map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

- 哈希法可以快速判断元素是否在集合里，但它**牺牲了空间换取了时间**，因为我们要使用额外的数组，set或者是map来存放数据，才能实现快速的查找

## 2.有效的字母异位词

- 题目：242.Valid Anagram字谜

  给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

  注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

  示例：

  ```
  输入: s = "anagram", t = "nagaram"
  输出: true
  
  输入: s = "rat", t = "car"
  输出: false
  ```

- 解题：

  - 暴力的解法，两层for循环，同时还要记录字符是否重复出现，很明显时间复杂度是 O(n^2)。

  - 利用哈希表来做：

    **数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组record，来记录字符串s里字符出现的次数。**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**

    - 遍历 s 时：**只需要将 s[i] - ‘a’ 所在的元素做+1 操作即可，并不需要记住字符a的ASCII，只要求出一个相对数值就可以了。**
    - 遍历 t 时：，对t中出现的字符映射哈希表索引上的数值再做-1的操作。
    - 最后检查record数组是否所有元素都为0，如果不是那就说明s和t不是字母异位词。

    ```c++
    class Solution {
    public:
        bool isAnagram(string s, string t) {
            vector<int> record(26,0);
            for (int i = 0; i < s.size(); i++) {
                // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了
                record[s[i] - 'a']++;
            }
            for (int i = 0; i < t.size(); i++) {
                record[t[i] - 'a']--;
            }
            for (int i = 0; i < 26; i++) {
                if (record[i] != 0) {
                    // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。
                    return false;
                }
            }
            // record数组所有元素都为零0，说明字符串s和t是字母异位词
            return true;
        }
    };
    ```


## 3.两个数组的交集

- 题目：349.Intersection of Two Arrays

  给定2个数组，求数组中都有哪些相同的值(值范围是`0 <= nums1[i], nums2[i] <= 1000`)

  ```
  Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
  Output: [9,4]
  Explanation: [4,9] is also accepted.
  ```

- 解题

  - **用数组的做法**：

    1. 记录nums1中出现的值，每个值只记录一次
    2. 记录nums2中出现的值，每个值只记录一次
    3. 最后record中值为2的，就是两个数组中都有的值。

    ```c++
    class Solution {
    public:
        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
            vector<int> record(1000,0);
            for(int i=0; i <nums1.size(); i++){	// 1. 记录nums1中出现的值，每个值只记录一次
                if(record[nums1[i]]==0)
                    record[nums1[i]]++;
            }
            for(int i=0; i<nums2.size(); i++){	// 2. 记录nums2中出现的值，每个值只记录一次
                if(record[nums2[i]]==1)
                    record[nums2[i]]++;
            }
            vector<int> ans;
            for(int i=0; i<1000;i++){			// 3. 最后record中值为2的，就是两个数组中都有的值。
                if(record[i]==2)
                    ans.push_back(i);
            }
            return ans;
        }
    };
    ```

  - **用集合set的做法**：

    - 相比于数组，set解决了如下问题：

      1. 如果值得范围没有限制，我们就无法给定一个确定范围的record
      2. 如果数据集分布的很散，会浪费大量的数组空间

    - 根据1中理论可知，unordered_set 读写效率是最高的，并不需要对数据进行排序

      而本题不需要排序数据，且数据不重复，所以使用unordered_set

    ```c++
    class Solution {
    public:
        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
            unordered_set<int> result;		// 空集合，用于记录要填充的数字
            unordered_set<int> record(nums1.begin(),nums1.end());	// nums1.begin()返回头迭代器，nums1.end()返回尾迭代器。如此把nums1所有的值放入无序集合record里
            
            for(int nums:nums2){	// 冒号:是c++11中新加的用法，对可迭代对象，方便循环。
                if(record.find(nums) != record.end()){	//set.find(xx)如果没找到xx会返回指向尾节点的迭代器，否则返回指向xx的迭代器
                    result.emplace(nums);	//将数值加入到record集合中去
                }
            }
            return vector<int>(result.begin(),result.end());
        }
    };
    ```

    - 相比于数组，set不仅占用空间比数组大，而且速度更慢，set把数值映射到key上都要做hash计算的。

  - **结构数组和set去重的特性**

    ```c++
    class Solution {
    public:
        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
            unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
            int hash[1005] = {0}; // 默认数值为0
            for (int num : nums1) { // nums1中出现的字母在hash数组中做记录
                hash[num] = 1;
            }
            for (int num : nums2) { // nums2中出现话，result记录
                if (hash[num] == 1) {
                    result_set.insert(num);
                }
            }
            return vector<int>(result_set.begin(), result_set.end());
        }
    };
    ```


## 4.快乐数

- 题目：202.Happy Number

  - 编写一个算法来判断一个数 n 是不是快乐数。
  - 快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。如果 可以变为 1，那么这个数就是快乐数。

  - 如果 n 是快乐数就返回 True ；不是，则返回 False 

  ```c++
  Input: n = 19
  Output: true
  Explanation:
  12 + 92 = 82
  82 + 22 = 68
  62 + 82 = 100
  12 + 02 + 02 = 1
  ```

- 解题：

  - 找不到1时会无限循环，即sum会重复。

    所以我们就可以用哈希法快速判断一个元素是否出现在集合里

    ```c++
    class Solution {
    public:
        int getSum(int n){			// 求1个数每一位的平方和
            int sum = 0;
            while(n){
                sum +=(n%10)*(n%10);
                n /= 10;
            }
            return sum;
        }
        bool isHappy(int n) {
            unordered_set<int> record;
            if(n==1) return true;
            while(n!=1){
                n = getSum(n);
                if(record.find(n)==record.end()){	//判断是否重复，如果不重复则继续求和，直到找到1
                    record.emplace(n);
                }
                else{
                    return false;
                }
            }
            return true;
        }
    };
    ```

## 5.两数之和

- 题目：Two Sum

  给定一个包含各个数字的数组 和 一个目标数，求数组中哪些组合的和为目标数

  这里每一个目标，只有唯一解。

  ```
  Input: nums = [2,7,11,15], target = 9
  Output: [0,1]
  Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
  ```

- 解题：

  - 暴力法：两层for

    复杂度为$o(n^2)$

  - 用哈希法

    - 为什么用哈希法？

      因为是两数之和，所以只要1.在遍历数组时，2.找一下那个数对应的数在不在集合里就行了。而查看数是否出现过，显然是哈希法的应用场景。

    - 为什么用map来实现哈希法？

      - 数组：数组大小受限，如果元素很少而值很大时，会浪费大量空间

        因为哈希法时，元素值对应的是数组的下标。

      - set: 题目要求返回数组中那2个数的下标。

        显然set的值就是其key，无法返回下标

      - map:是一种key value的存储结构，符合题目要求。

        - key：存数组下标
        - value:存该下标对应的数组值

    ```c++
    class Solution {
    public:
        vector<int> twoSum(vector<int>& nums, int target) {
            unordered_map<int,int> map;
            vector<int> ans;
            for(int i =0;i<nums.size();i++){ 		// 1. 遍历数组 
                int j = target - nums[i];
                if(map.find(j) != map.end()){		// 2. 找一下那个数对应的数在不在集合里
                    return{map.find(j)->second,i};	// 如果在就找到了，返回索引
                }
                map.emplace(pair<int, int>(nums[i], i));	// 不在就加入到map里去
            }
            return {};
        }
    };
    ```

    

## 6.四数相加

- 题目：454.4sum 

  给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

  其中

  - `1 <= n <= 200`
  - `0 <= i, j, k, l < n`
  - `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`

  ```
  Input: nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
  Output: 2
  Explanation:
  The two tuples are:
  1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
  2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
  ```

- 解题：

  - 把4个数组分成2组，
  - 遍历第一组，求两两元素的和作为key，和出现的次数作为value。
  - 遍历第二组，应用哈希表特性，快速寻找是否第一组中有满足4数组和为0的存在
  - 若有，就将出现的次数计入，最后汇总所有可能性。

  ```c++
  class Solution {
  public:
      int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {
          unordered_map<int,int> map;
          for(int num1 : nums1){
              for(int num2 : nums2){					// 1. 遍历第一组，求两两元素的和作为key
                  int sum = num1 + num2;
                  if(map.find(sum)!=map.end()){		// map.find()返回的是一个迭代器
                      map.find(sum)->second ++;		// ->first是key,->second是value
                  }
                  else{
                      map.emplace(make_pair(sum,1));
                  }
              }
          }
          int ans=0;
          for(int num3:nums3){
              for(int num4:nums4){					// 2. 遍历第二组，查看是否第一组中有符合的
                  int sum = 0-(num3 + num4);
                  if(map.find(sum)!=map.end()){
                      ans += map.find(sum)->second;	// 3. 若有，则汇总出现的次数
                  }
              }
          }
          return ans;
      }
  };
  ```

  - 更简洁的写法：

    思路与上面一致。

    ```c++
    class Solution {
    public:
        int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
            unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数
            // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
            for (int a : A) {
                for (int b : B) {
                    umap[a + b]++;
                }
            }
            int count = 0; // 统计a+b+c+d = 0 出现的次数
            // 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
            for (int c : C) {
                for (int d : D) {
                    if (umap.find(0 - (c + d)) != umap.end()) {
                        count += umap[0 - (c + d)];
                    }
                }
            }
            return count;
        }
    };
    ```

## 7.赎金信

- 题目：383.Ransom Note

  给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。

  (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)

  ```
  Input: ransomNote = "aa", magazine = "ab"
  Output: false
  
  Input: ransomNote = "aa", magazine = "aab"
  Output: true
  ```

- 解题：

  - 简单的数组应用,把字母从a开始的地址作为索引

  ```c++
  class Solution {
  public:
      bool canConstruct(string ransomNote, string magazine) {
          vector<int> record(26,0);
          for(char x : magazine){
              record[x-'a']++;
          }
          for(char x : ransomNote){
              record[x-'a']--;
              if(record[x-'a']<0) return false;
          }
          return true;
      }
  };
  ```

## 8.三数之和

- 题目：15.3Sum

  给定一个数组，从中选3个数，让他们和为0。返回所有的可能性，要求不能重复相同的数字组合。

  ```c++
  Input: nums = [-1,0,1,2,-1,-4]
  Output: [[-1,-1,2],[-1,0,1]]
  Explanation: 
  nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.
  nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.
  nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.
  The distinct triplets are [-1,0,1] and [-1,-1,2].
  Notice that the order of the output and the order of the triplets does not matter.
  ```

- 解题：

  难点在于去重。

  - 如果用哈希法

    1. 两层for循环就可以确定 a 和b 的数值了，可以使用哈希法来确定 0-(a+b) 是否在数组里出现过。

    2. 去重：

       - 方案一：把符合条件的三元组放进vector中，然后再去重。超时，无法通过。

       - 方案二：排序后，对a+b+c=0，的a,b,c分别去重。很麻烦,但能通过。o(n^2)

         ```c++
         class Solution {
         public:
             vector<vector<int>> threeSum(vector<int>& nums) {
                 vector<vector<int>> result;
                 sort(nums.begin(), nums.end());
                 // 找出a + b + c = 0
                 // a = nums[i], b = nums[j], c = -(a + b)
                 for (int i = 0; i < nums.size(); i++) {
                     // 排序之后如果第一个元素已经大于零，那么不可能凑成三元组
                     if (nums[i] > 0) {
                         break;
                     }
                     if (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重
                         continue;
                     }
                     unordered_set<int> set;
                     for (int j = i + 1; j < nums.size(); j++) {
                         if (j > i + 2
                                 && nums[j] == nums[j-1]
                                 && nums[j-1] == nums[j-2]) { // 三元组元素b去重
                             continue;
                         }
                         int c = 0 - (nums[i] + nums[j]);
                         if (set.find(c) != set.end()) {
                             result.push_back({nums[i], nums[j], c});
                             set.erase(c);// 三元组元素c去重
                         } else {
                             set.insert(nums[j]);
                         }
                     }
                 }
                 return result;
             }
         };
         ```

  - 双指针法：

    这题相比哈希法更高效

    - 首先将数组从小到大排序，定义三个下标，并对他们去重

      - i：下标0开始的地方

        nums[i]如果等于nums[i-1]，显然重复

      - left：i+1

        nums[left]如果等于nums[lefts+1],显然重复 

      - right:数组结尾的位置

        nums[right]如果等于nums[right-1]，显然重复

    - 对应于a + b +c =0：`a = nums[i]，b = nums[left]，c = nums[right]`。
    - for循环i,去重i，然后计算和
      - 如果`nums[i] + nums[left] + nums[right] > 0`，则让right向左移动。
      - 如果`nums[i] + nums[left] + nums[right] < 0`, 则让left向右移动。
      - 如果`nums[i] + nums[left] + nums[right] = 0`，则加入答案，然后去重right和left，最后移动right和left

    ```c++
    class Solution {
    public:
        vector<vector<int>> threeSum(vector<int>& nums) {
            vector<vector<int>> result;
            sort(nums.begin(), nums.end());
            // 找出a + b + c = 0
            // a = nums[i], b = nums[left], c = nums[right]
            for (int i = 0; i < nums.size(); i++) {
                // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
                if (nums[i] > 0) {
                    return result;
                }
                // 错误去重a方法，将会漏掉-1,-1,2 这种情况
                /*
                if (nums[i] == nums[i + 1]) {
                    continue;
                }
                */
                // 正确去重a方法
                if (i > 0 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {
                    // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                    /*
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;
                    */
                    if (nums[i] + nums[left] + nums[right] > 0) right--;
                    else if (nums[i] + nums[left] + nums[right] < 0) left++;
                    else {
                        result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                        // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;
    
                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }
    
            }
            return result;
        }
    };
    ```

## 9.四数之和

- 题目：18.4Sum

  给定一个数组，选定其中4个，使他们和为给定的target。要求数字排列不重复。

  ```
  Input: nums = [1,0,-1,0,-2,2], target = 0
  Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
  ```

- 解题

  - 有别于6.四数相加，这里是从1个数组里选4个数

    这里也要求，数字排列组合不重复，而6.四数相加要求下标不同就行。

  - 所以这题更类似于8.三数之和，需要进行去重，

  - 解题思路也是再8.三数之和的双指针解法外再套一层for循环.

  ```c++
  class Solution {
  public:
      vector<vector<int>> fourSum(vector<int>& nums, int target) {
          vector<vector<int>> result;
          sort(nums.begin(), nums.end());
          for (int k = 0; k < nums.size(); k++) {
              // 剪枝处理
              if (nums[k] > target && nums[k] >= 0) {
              	break; // 这里使用break，统一通过最后的return返回
              }
              // 对nums[k]去重
              if (k > 0 && nums[k] == nums[k - 1]) {
                  continue;
              }
              for (int i = k + 1; i < nums.size(); i++) {
                  // 2级剪枝处理
                  if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
                      break;
                  }
  
                  // 对nums[i]去重
                  if (i > k + 1 && nums[i] == nums[i - 1]) {
                      continue;
                  }
                  int left = i + 1;
                  int right = nums.size() - 1;
                  while (right > left) {
                      // nums[k] + nums[i] + nums[left] + nums[right] > target 会溢出
                      if ((long) nums[k] + nums[i] + nums[left] + nums[right] > target) {
                          right--;
                      // nums[k] + nums[i] + nums[left] + nums[right] < target 会溢出
                      } else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  < target) {
                          left++;
                      } else {
                          result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                          // 对nums[left]和nums[right]去重
                          while (right > left && nums[right] == nums[right - 1]) right--;
                          while (right > left && nums[left] == nums[left + 1]) left++;
  
                          // 找到答案时，双指针同时收缩
                          right--;
                          left++;
                      }
                  }
  
              }
          }
          return result;
      }
  };
  
  ```

## 10.总结

- 一般来说哈希表都是用来快速判断一个元素是否出现集合里。

- 要知道**哈希函数**和**哈希碰撞**在哈希表中的作用

  - 哈希函数是把传入的key映射到符号表的索引上。
  - 哈希碰撞处理有多个key映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。

- 常见的三种哈希结构：

  - 数组
    - 数组就是简单的哈希表，但是数组的大小是受限的
    - 如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费
  - set（集合）
    - std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希， 
    - 使用unordered_set 读写效率是最高的，如果不需要对数据进行排序，而且还不要让数据重复，就选择unordered_set。
    - set是一个集合，里面放的元素只能是一个key
  - map（映射）
    - std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解），
    - 5.两数之和，并不需要key有序，选择std::unordered_map 效率更高！

  要了解什么时候用具体的哪一种

# 四、字符串

## 1.理论基础

- 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组

- 在C语言中，把一个字符串存入一个数组时，也把结束符 '\0'存入数组，并以此作为该字符串是否结束的标志。

- 在C++中，提供一个string类，string类会提供 size接口，可以用来判断string类字符串是否结束，就不用'\0'来判断是否结束。

  - vector< char > 和 string 又有什么区别呢？

    其实在基本操作上没有区别，但是 string提供更多的字符串处理的相关接口，例如string 重载了+，而vector却没有。

## 2.反转字符串

- 题目：344:Reverse String

  编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。

  不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

  示例：

  ```
  输入：s = ["h","e","l","l","o"]
  输出：["o","l","l","e","h"]
  
  输入：s = ["H","a","n","n","a","h"]
  输出：["h","a","n","n","a","H"]
  ```

- 题解

  使用库函数的原则：**如果库函数仅仅是 解题过程中的一小部分，并且你已经很清楚这个库函数的内部实现原理的话，可以考虑使用库函数。**

  - 使用reverse库函数：

    ```c++
    class Solution {
    public:
        void reverseString(vector<char>& s) {
            reverse(s.begin(),s.end());
        }
    };
    ```

  - 使用swap库函数

    ```c++
    class Solution {
    public:
        void reverseString(vector<char>& s) {
            for(int i=0,j=s.size()-1;i<s.size()/2;i++,j--){
                swap(s[i],s[j]);
            }
        }
    };
    
    // swap()实现的两种原理：
    //1. 中间值
    int tmp = s[i];
    s[i] = s[j];
    s[j] = tmp;
    //2. 位运算：异或
    s[i] ^= s[j];
    s[j] ^= s[i];
    s[i] ^= s[j];
    ```

  
## 3.反转字符串||

- 题目：541.Reverse String ||

  给定一个字符串 s 和一个整数 k，从字符串开头算起, 每计数至 2k 个字符，就反转这 2k 个字符中的前 k 个字符。

  如果剩余字符少于 k 个，则将剩余字符全部反转。

  如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样

  ```
  Input: s = "abcdefg", k = 2
  Output: "bacdfeg"
  
  Input: s = "abcd", k = 2
  Output: "bacd"
  ```

- 解题：

  - 在遍历字符串的过程中，只要让 i += (2 * k)，i 每次移动 2 * k 就可以了，然后判断是否需要有反转的区间。

  ```c++
  class Solution {
  public:
      string reverseStr(string s, int k) {
          for (int i = 0; i < s.size(); i += (2 * k)) {
              // 1. 每隔 2k 个字符的前 k 个字符进行反转
              // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符
              if (i + k <= s.size()) {
                  reverse(s.begin() + i, s.begin() + i + k );
              } else {
                  // 3. 剩余字符少于 k 个，则将剩余字符全部反转。
                  reverse(s.begin() + i, s.end());
              }
          }
          return s;
      }
  };
  ```


## 4.替换空格

- 题目：[剑指 Offer 05. 替换空格](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/)

  请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

  ```
  输入：s = "We are happy."
  输出："We%20are%20happy."
  ```

- 解题

  1. 首先扩充数组到每个空格替换成"%20"之后的大小。
  2. 然后**从后向前**替换空格，也就是双指针法，
     - i指向新长度的末尾，j指向旧长度的末尾。
     - j指向字符，就就将字符填入i对应的位置
     - j指向空格，就将%20填入i

  好处：

  1. 不用申请新数组。
  2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

  ```c++
  class Solution {
  public:
      string replaceSpace(string s) {
          int count = 0; // 统计空格的个数
          int sOldSize = s.size();
          for (int i = 0; i < s.size(); i++) {
              if (s[i] == ' ') {
                  count++;
              }
          }
          // 扩充字符串s的大小，也就是每个空格替换成"%20"之后的大小
          s.resize(s.size() + count * 2);	//为什么%20三个字符，这里却乘2呢，因为本身空格就占1位。
          int sNewSize = s.size();
          // 从后先前将空格替换为"%20"
          for (int i = sNewSize - 1, j = sOldSize - 1; j < i; i--, j--) {
              if (s[j] != ' ') {
                  s[i] = s[j];
              } else {
                  s[i] = '0';
                  s[i - 1] = '2';
                  s[i - 2] = '%';
                  i -= 2;
              }
          }
          return s;
      }
  };
  ```


## 5.翻转字符串里的单词

- 题目：151. Reverse Words in a String

  给定一个字符串，根据空格，反转单词（不是反转每个字符）

  字符串可能会包含行首行尾空格或者连续多个空格，这些空格都不要。

  ```
  Input: s = "  hello world  "
  Output: "world hello"
  ```

- 解题：

  思路：

  1. 移除多余空格
  2. 将整个字符串反转
  3. 将每个单词反转

  ```c++
  class Solution {
  public:
      void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []
          for (int i = start, j = end; i < j; i++, j--) {
              swap(s[i], s[j]);
          }
      }
  
      void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
          int slow = 0;   
          for (int i = 0; i < s.size(); ++i) { //
              if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
                  if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
                  while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                      s[slow++] = s[i++];
                  }
              }
          }
          s.resize(slow); //slow的大小即为去除多余空格后的大小。
      }
  
      string reverseWords(string s) {
          removeExtraSpaces(s); 				// 1. 去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。
          reverse(s, 0, s.size() - 1);		// 2. 反转整个字符串
          									// 3. 反转单个单词
          int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。
          for (int i = 0; i <= s.size(); ++i) {
              if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。
                  reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。
                  start = i + 1; //更新下一个单词的开始下标start
              }
          }
          return s;
      }
  };
  ```




## 6.左旋转字符串

- 题目：[剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

  字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

  ```
  输入: s = "abcdefg", k = 2
  输出: "cdefgab"
  ```

- 解题：

  - 申请额外的空间：

    ```c++
    class Solution {
    public:
        string reverseLeftWords(string s, int n) {
            string ans;
            for(int i=n;i<s.size();i++){
                ans.push_back(s[i]);
            }
            for(int i=0;i<n;i++){
                ans.push_back(s[i]);
            }
            return ans;
        }
    };
    ```

  - 不申请额外的空间：

    abcdefg

    1. 反转区间为前n的子串:bacdefg
    2. 反转区间为n到末尾的子串:bagfedc
    3. 反转整个字符串:cdefgab

    ```c++
    class Solution {
    public:
        string reverseLeftWords(string s, int n) {
            reverse(s.begin(), s.begin() + n);
            reverse(s.begin() + n, s.end());
            reverse(s.begin(), s.end());
            return s;
        }
    };
    ```

## 7.KMP算法

### 7.1 KMP算法：

在一个串中查找是否出现过另一个串，这是KMP的看家本领。

- **KMP名字由来**：

  因为是由这三位学者发明的：Knuth，Morris和Pratt，所以取了三位学者名字的首字母。所以叫做KMP

- **KMP有什么用**：

  KMP主要应用在字符串匹配上，主要思想是：当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。

  所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。

- **前缀表**：

  - 什么是前缀表：
  
    KMP算法中的next数组就是一个前缀表（prefix table）。
  
  - 前缀表有什么用：
  
    前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配。
  
    否则如果使用暴力匹配，发现不匹配时，就要从头匹配了。
  
  - 前缀表会记录什么？
  
    记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀
  
  - 前缀和后缀
  
    - 前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串
    - 后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串
    - **最长相等前后缀**：前缀表要求的就是相同前后缀的长度。
  
  - 为什么一定要用前缀表？
  
    前缀表具有告诉我们当前位置匹配失败，跳到之前已经匹配过的地方的能力。
  
- **如何计算前缀表**？
  
  以aabaaf为例：
  
  - 长度为前1个字符的子串`a`,
  
    前缀NULL,后缀NULL-->最长相同前后缀的长度=0
  
  - 长度为前2个字符的子串`aa`,
  
    前缀a,后缀a-->最长相同前后缀的长度=1, a
  
  - 长度为前3个字符的子串`aab`,
  
    前缀有a,aa,后缀b,ab-->最长相同前后缀的长度=0
  
  - 长度为前4个字符的子串`aaba`
  
    前缀有a,aa,aab，后缀有a,ba,aba-->最长相同前后缀的长度=1, a
  
  - 长度为前5个字符的子串`aabaa`
  
    前缀有a,aa,aab,aaba，后缀有a,aa,baa,abaa-->最长相同前后缀的长度=2, aa
  
    - 前缀表值为2，就意味着，当前位置`后缀:最后2个字母`和`前缀：开头的两个字母`相等
    - 所以如果在后缀后发现不匹配的字符，那我们就只需要移动到前缀后那一格重新开始匹配就行了、
    - 而前缀后那一格的下标，也就是这里前缀表值。
  
  - 长度为前6个字符的子串`aabaaf`
  
    前缀有a,aa,aab,aaba,aabaa 后缀有f,af,aaf,baaf,abaaf-->最长相同前后缀的长度=0
  
  如此得到aabaaf的前缀表:`[0,1,0,1,2,0]`
  
- **如何使用前缀表？**
  
  - 用法：
  
    在找到不匹配的位置，将模式串指针向前移动到前一个字符的前缀表值所在处。
  
  - 例子：
  
    在文本串`aabaabaafa`中找是否出现过`aabaaf`

      | 文本串下标 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
      | ---------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
      | 文本串     | a    | a    | b    | a    | a    | b    | a    | a    | f    | a    |
      | 模式串下标 | 0    | 1    | 2    | 3    | 4    | 5    |      |      |      |      |
      | 模式串     | a    | a    | b    | a    | a    | f    |      |      |      |      |
      | 前缀表     | 0    | 1    | 0    | 1    | 2    | 0    |      |      |      |      |

    - 在文本串和模式串指针一起指到5的时候，我们发现模式串是`f`和文本串`b`不符，然后看到模式串前一个字符`a`的前缀表值为2，所以将模式串指针从当前位置移动到下标为2处。
  
  - 为什么要前一个字符的前缀表的数值呢？
  
    因为要找前面字符串的最长相同的前缀和后缀。
  
- **时间复杂度分析**

  n为文本串长度，m为模式串长度，

  - 因为在匹配的过程中，根据前缀表不断调整匹配的位置，可以看出匹配的过程是O(n)，之前还要单独生成next数组，时间复杂度是O(m)。

    所以整个KMP算法的时间复杂度是O(n+m)的。
  
  - 暴力的解法显而易见是O(n × m)，

​	所以KMP在字符串匹配中极大地提高了搜索的效率。

### 7.2 KMP的next数组构造

next数组就是前缀表，在实现的时候，有三种：

1. 将前缀表的值统一减一

   遇到冲突时，找前一位的前缀值并给其加1。

2. 右移一位，初始位置为-1，之后作为next数组。

   遇到冲突时，直接找当前位的前缀值。

3. 直接将前缀表作为next数组

   遇到冲突时，找前一位的前缀值。

- **构建next数组**

  构造next数组其实就是计算模式串s，前缀表的过程。 主要有如下三步：

  1. 初始化
  2. 处理前后缀不相同的情况
  3. 处理前后缀相同的情况

  ```c++
  //********* 1. 前缀表统一减一的next数组构建 *********
  // 为什么这里next参数用指针引用呢？因为next是个数组，需要传递它的数组头地址
  void getNext(int* next, const string& s) {
      int j = -1;			// 这里的j是前缀表值-1，j指向前缀末尾位置，i指向后缀末尾位置
      next[0] = j;		// next[i]表示i处的前缀表值
      for(int i = 1; i < s.size(); i++) { // 注意i从1开始
          while (j >= 0 && s[i] != s[j + 1]) { // 前后缀只要不相等，j就不断向前回退
              j = next[j];					 // 直到j到起始位置，或找到前后缀相等的位置
          }
          if (s[i] == s[j + 1]) { // 如果遇到相同的前后缀，就前缀向后移动一位
              j++;			    // 此处的前缀表值也就等于++后的j，因为j表示了此时前后缀有j位相同的值
          }
          next[i] = j; // 将j（前缀的长度）赋给next[i]
      }
  }
  
  //********* 2. 前缀表不减一的next数组构建 *********
  void getNext(int* next, const string& s) {
      int j = 0;			// 这里的j是前缀表值
      next[0] = 0;		// next[i]表示i处的前缀表值
      for(int i = 1; i < s.size(); i++) {
          while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作
              j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了
          }
          if (s[i] == s[j]) {
              j++;
          }
          next[i] = j;
      }
  }
  ```

- **使用next数组来匹配**

  要在文本串s里找是否出现过模式串t

  - 对于统一减一的next数组

    ```c++
    // 下标j 指向模式串起始位置，i指向文本串起始位置。
    int j = -1; // 因为next数组里记录的起始位置为-1
    for (int i = 0; i < s.size(); i++) { // 注意i就从0开始
        while(j >= 0 && s[i] != t[j + 1]) { // 不匹配
            j = next[j]; // j 寻找之前匹配的位置
        }
        if (s[i] == t[j + 1]) { // 匹配，j和i同时向后移动
            j++; // i的增加在for循环里
        }
        if (j == (t.size() - 1) ) { // 文本串s里出现了模式串t
            return (i - t.size() + 1);
        }
    }
    ```

  - 对于直接用前缀表的next数组

    ```c++
    for (int i = 0; i < haystack.size(); i++) {
        while(j > 0 && haystack[i] != needle[j]) {
            j = next[j - 1];
        }
        if (haystack[i] == needle[j]) {
            j++;
        }
        if (j == needle.size() ) {
            return (i - needle.size() + 1);
        }
    }
    ```

    

### 7.2 例题：找出字符串中第一个匹配项的下标

- 题目：28. Find the Index of the First Occurrence in a String

  给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回  -1 。

  ```
  Input: haystack = "sadbutsad", needle = "sad"
  Output: 0
  
  Input: haystack = "leetcode", needle = "leeto"
  Output: -1
  ```

- 解题：

  利用KMP算法查看needle是否出现在haystack中

  直接使用前缀表构建这里的next数组

  ```c++
  class Solution {
  public:
      void getNext(int* next, const string& s) {
          int j = 0;
          next[0] = 0;
          for(int i = 1; i < s.size(); i++) {
              while (j > 0 && s[i] != s[j]) {
                  j = next[j - 1];
              }
              if (s[i] == s[j]) {
                  j++;
              }
              next[i] = j;
          }
      }
      int strStr(string haystack, string needle) {
          if (needle.size() == 0) {
              return 0;
          }
          int next[needle.size()];
          getNext(next, needle);
          int j = 0;
          for (int i = 0; i < haystack.size(); i++) {
              while(j > 0 && haystack[i] != needle[j]) {
                  j = next[j - 1];
              }
              if (haystack[i] == needle[j]) {
                  j++;
              }
              if (j == needle.size() ) {
                  return (i - needle.size() + 1);
              }
          }
          return -1;
      }
  };
  ```


## 8.重复的子字符串

- 题目：459. Repeated Substring Pattern

  给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

  ```
  Input: s = "abab"
  Output: true
  Explanation: It is the substring "ab" twice.
  
  Input: s = "aba"
  Output: false
  ```

- 解题

  - **暴力解法**：

    一个for循环找子串，嵌套一个for循环判断子串是否能重复构成字符串

    ```c++
    class Solution {
    public:
        bool repeatedSubstringPattern(string s) {
            int n = s.size();
            for (int i = 1; i * 2 <= n; ++i) {	// i表示子串的长度
                if (n % i == 0) {				// 字符串s的长度，一定是子串长度的倍数
                    bool match = true;
                    for (int j = i; j < n; ++j) {	// 判断是否是可以重复构成
                        if (s[j] != s[j - i]) {
                            match = false;
                            break;
                        }
                    }
                    if (match) {
                        return true;
                    }
                }
            }
            return false;
        }
    };
    ```

    时间：$o(n^2)$

  - **移动匹配法**：

    判断字符串s是否由重复子串组成，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。

    在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

    ```c++
    class Solution {
    public:
        bool repeatedSubstringPattern(string s) {
            string t = s + s;
            t.erase(t.begin()); t.erase(t.end() - 1); // 掐头去尾
            if (t.find(s) != std::string::npos) return true; // r
            return false;
        }
    };
    ```

    时间:$o(m+n)$

  - **KMP法**：

    相比于用语言自带的find()方法，KMP方法可以更高效的实现找到是否存在另一个字符串。

    ```c++
    class Solution {
    public:
        void getNext (int* next, const string& s){
            next[0] = 0;
            int j = 0;
            for(int i = 1;i < s.size(); i++){
                while(j > 0 && s[i] != s[j]) {
                    j = next[j - 1];
                }
                if(s[i] == s[j]) {
                    j++;
                }
                next[i] = j;
            }
        }
        bool repeatedSubstringPattern (string s) {
            if (s.size() == 0) {
                return false;
            }
            int next[s.size()];
            getNext(next, s);
            int len = s.size();
            if (next[len - 1] != 0 && len % (len - (next[len - 1] )) == 0) {
                return true;
            }
            return false;
        }
    };
    ```

  ## 9.总结：

  主要考察有：

  1. 双指针法：

     很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。

  2. 反转系列：

     - 当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章
     - 也可以 先整体反转再局部反转 或者 先局部反转再整体反转

  3. KMP：

     见7

# 五、双指针法

## 1.理论基础

- 双指针法并不隶属于某一种数据结构，但数组，链表，字符串都会用到双指针法

## 2. 移除元素

- 题目：27:Remove Element

  给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

  不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

  元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

  示例：

  ```
  输入：nums = [3,2,2,3], val = 3
  输出：2, nums = [2,2]
  解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
  
  输入：nums = [0,1,2,2,3,0,4,2], val = 2
  输出：5, nums = [0,1,4,0,3]
  解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
  ```

- 题解

  - 暴力方法：
  
    用2个for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。将val值移到数组的最后面。
  
    时间复杂度：O(n^2)
  
    ```c++
    class Solution {
    public:
        int removeElement(vector<int>& nums, int val) {
            int size = nums.size();
            for(int i=0;i<size;i++){
                if(nums[i]==val){
                    for(int j=i;j<size;j++){
                        nums[i]=nums[j];
                    }
                    i--;	// 因为下标i以后的数值都向前移动了一位，所以i也向前移动一位
                    size--;	// 此时数组的大小-1
                }
            }
            return size;
        }
    };
    ```
  
  - 双指针法：
  
    通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。
  
    核心思想就是：慢指针指向要处理的val值。快指针遍历整个数组，将不是val的值覆盖掉慢指针指向的val值。
  
    时间复杂度：O(n)。空间复杂度：O(1)
  
    ```c++
    class Solution {
    public:
        int removeElement(vector<int>& nums, int val) {
            int slowindex = 0;
            for(int fastindex=0;fastindex < nums.size(); fastindex++){
                // 如果不是val值，两个指针会一起往前进。
    			// 如果是val值，快指针移到下一个，慢指针仍指向val值。
                // 直到快指针移到下一个不是val值的地方，然后慢指针指向的val值会被该值覆盖掉。
                // 最后2个指针再往前移动处理下一个val值。
                if(val != nums[fastindex]){
                    nums[slowindex++]=nums[fastindex];
                }
            }
            return slowindex;
        }
    };
    ```
  
  - 类似题：
  
    - 26.删除排序数组中的重复项
    - 283.移动零
    - 844.比较含退格的字符串
    - 977.有序数组的平方
  
  

# 六、栈与队列

## 1.理论基础

- 队列queue是先进先出，栈stack是先进后出。

- **栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）。
  
  定义一个栈：`stack<int> xxx`
  
  - 栈的底层实现可以是容器vector，deque，list 
  - 栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也**不提供迭代器(iterator)**。
  - STL有3个普遍版本：HP STL, P.J.Plauger STL,和SGL STL
    -  知道了使用版本，才知道对应的底层实现。
  - 我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈和队列的底层结构
    - SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。
  - deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。
  - 如果不想用dqeque作为底层实现，也可以指定其他底层实现：
    - 指定vector为栈的底层实现：`std::stack<int, std::vector<int> > third;`
    - 指定list 为队列的底层实现：`std::queue<int, std::list<int>> third; `
  
- **SGI STL中 队列底层实现缺省情况下一样使用deque实现的。**STL 队列也不被归类为容器，而被归类为container adapter（ 容器适配器）。
  
  [deque](https://en.cppreference.com/w/cpp/container/deque): double-ended queue
  
  定义一个队列：`queue<int> xxx`
  
  - 和栈一样不允许有遍历行为，**不提供迭代器**

## 2.用栈实现队列

- 题目 232:Implement Queue using Stacks

  实现 MyQueue 类：

  - void push(int x) 将元素 x 推到队列的末尾
    int pop() 从队列的开头移除并返回元素
    int peek() 返回队列开头的元素
    boolean empty() 如果队列为空，返回 true ；否则，返回 false

  示例

  ```
  输入：
  ["MyQueue", "push", "push", "peek", "pop", "empty"]
  [[], [1], [2], [], [], []]
  输出：
  [null, null, null, 1, 1, false]
  ```

- 题解

  用一个栈来模拟队列的功能是不现实的，必须用1个输入栈1个输出栈来模拟。

  - 在push数据时：把数据放入输入栈
  - 在pop时：
    - 如果输出栈为空，就先把输入栈元素先全导入输出栈，然后从输出栈弹出数据
    - 如果输出栈不为空，直接从输出弹出数据
  
  ```c++
  class MyQueue {
  private:
      stack<int> stIn;
      stack<int> stOut;
  public:
      MyQueue() {
  
      }
      //在push数据的时候，只要数据放进输入栈就好
      void push(int x) {
          stIn.push(x);
      }
      //输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。
      int pop() {
          if(stOut.empty()){
              while(!stIn.empty()){
                  stOut.push(stIn.top());           
                  stIn.pop();
              }
          }
          int result = stOut.top();
          stOut.pop();
          return result;
      }
      // 区别于pop就是头元素不删除
      int peek() {
          if(stOut.empty()){
              while(!stIn.empty()){
                  stOut.push(stIn.top());           
                  stIn.pop();
              }
          }
          int result = stOut.top();
          return result;
      }
      // 2个栈都是空的，那队列就是空的
      bool empty() {
          if(stOut.empty()&&stIn.empty())
              return true;
          else
              return false;
      }
  };
  
  ```
  

## 3.用队列实现栈

- 题目：225. Implement Stack using Queues

  使用队列实现栈的下列操作：

  - push(x) -- 元素 x 入栈
  - pop() -- 移除栈顶元素
  - top() -- 获取栈顶元素
  - empty() -- 返回栈是否为空

- 解题：

  - 用两个队列来模拟栈

    - 输入：正常输入到第一个队列
    - 输出：先将除最后一个元素外的所有元素，移动到第二个队列，然后第一个队列输出最后的那个元素

    ```c++
    class MyStack {
    public:
        queue<int> que1;
        queue<int> que2; // 辅助队列，用来备份
        /** Initialize your data structure here. */
        MyStack() {
    
        }
    
        /** Push element x onto stack. */
        void push(int x) {
            que1.push(x);
        }
    
        /** Removes the element on top of the stack and returns that element. */
        int pop() {
            int size = que1.size();
            size--;
            while (size--) { // 将que1 导入que2，但要留下最后一个元素
                que2.push(que1.front());
                que1.pop();
            }
    
            int result = que1.front(); // 留下的最后一个元素就是要返回的值
            que1.pop();
            que1 = que2;            // 再将que2赋值给que1
            while (!que2.empty()) { // 清空que2
                que2.pop();
            }
            return result;
        }
    
        /** Get the top element. */
        int top() {
            return que1.back();
        }
    
        /** Returns whether the stack is empty. */
        bool empty() {
            return que1.empty();
        }
    };
    ```

    

  - 用一个队列来模拟栈

    - 输入：正常输入到队列
    - 输出：只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。

    ```c++
    class MyStack {
    public:
        queue<int> que;
        /** Initialize your data structure here. */
        MyStack() {
    
        }
        /** Push element x onto stack. */
        void push(int x) {
            que.push(x);
        }
        /** Removes the element on top of the stack and returns that element. */
        int pop() {
            int size = que.size();
            while (--size) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
                que.push(que.front());
                que.pop();
            }
            int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
            que.pop();
            return result;
        }
    
        /** Get the top element. */
        int top() {
            return que.back();
        }
    
        /** Returns whether the stack is empty. */
        bool empty() {
            return que.empty();
        }
    };
    ```

    

## 4.有效的括号

- 题目: 20. Valid Parentheses

  给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

  有效字符串需满足：

  - 左括号必须用相同类型的右括号闭合。
  - 左括号必须以正确的顺序闭合。
  - 注意空字符串可被认为是有效字符串。

  ```
  Input: s = "()[]{}"
  Output: true
  
  Input: s = "(]"
  Output: false
  ```

- 解题

  **括号匹配是使用栈解决的经典问题。**

  1. 遍历数组，识别到左括号时，将对应的右括号入栈
  2. 识别到右括号时，栈头应该就是该右括号，否则返回错误
  3. 最后遍历完成，若为空栈，就返回正确。

  ```c++
  class Solution {
  public:
      bool isValid(string s) {
          stack<char> sta;
          for(int i=0; i<s.size();i++){		// 1. 遍历数组，识别到左括号时，将对应的右括号入栈
              if(s[i]=='(') sta.push(')');
              else if(s[i]=='[') sta.push(']');
              else if(s[i]=='{') sta.push('}');
              else{
                  if(sta.empty()!=true && s[i]==sta.top()) sta.pop();	// 2. 识别到右括号时，栈头应该就是该右括号，否则返回错误
                  else return false;
              }
          }
          if(sta.empty()==true) return true;	// 3. 后遍历完成，若为空栈，就返回正确。
          else return false;
      }
  };
  ```


## 5.删除字符中的所有相邻重复项

- 题目：1047. Remove All Adjacent Duplicates In String

  给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

  在 S 上反复执行重复项删除操作，直到无法继续删除。

  在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

  ```
  输入："abbaca"
  输出："ca"
  解释：例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
  ```

- 解题：

  1. 遍历字符串，将字符存入栈中
  2. 如果栈头和字符串的字符相同，就将该字符从栈中移出

  ```c++
  class Solution {
  public:
      string removeDuplicates(string S) {
          stack<char> st;
          for (char s : S) {
              // 一定要先判断栈是否为空，否则会地址错误
              if (st.empty() || s != st.top()) {
                  st.push(s);
              } else {
                  st.pop(); // s 与 st.top()相等的情况
              }
          }
          string result = "";
          while (!st.empty()) { // 将栈中元素放到result字符串汇总
              result += st.top();
              st.pop();
          }
          reverse (result.begin(), result.end()); // 此时字符串需要反转一下
          return result;
  
      }
  };
  ```

## 6.逆波兰表达式求值

- 题目：150. Evaluate Reverse Polish Notation

  根据[逆波兰表示法](https://en.wikipedia.org/wiki/Reverse_Polish_notation)，求表达式的值。有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

  ```
  Input: tokens = ["2","1","+","3","*"]
  Output: 9
  Explanation: ((2 + 1) * 3) = 9
  
  Input: tokens = ["4","13","5","/","+"]
  Output: 6
  Explanation: (4 + (13 / 5)) = 6
  ```

- 解题：

  用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。

  ```c++
  class Solution {
  public:
      int evalRPN(vector<string>& tokens) {
          stack<int> sta;
          for(string s: tokens){
              if(s=="+" || s=="-" || s=="*" || s=="/"){
                  int num1 = sta.top();
                  sta.pop();
                  int num2 = sta.top();
                  sta.pop();
                  if(s=="+") sta.push(num2+num1);
                  if(s=="-") sta.push(num2-num1);
                  if(s=="*") sta.push(num2*num1);
                  if(s=="/") sta.push(num2/num1);
              }
              else{
                  sta.push(stoi(s));
              }
          }
          return sta.top();
      }
  };
  ```


## 7.滑动窗口最大值

- 题目：239. Sliding Window Maximum

  给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

  返回滑动窗口中的最大值。

  ```
  Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
  Output: [3,3,5,5,6,7]
  Explanation: 
  Window position                Max
  ---------------               -----
  [1  3  -1] -3  5  3  6  7       3
   1 [3  -1  -3] 5  3  6  7       3
   1  3 [-1  -3  5] 3  6  7       5
   1  3  -1 [-3  5  3] 6  7       5
   1  3  -1  -3 [5  3  6] 7       6
   1  3  -1  -3  5 [3  6  7]      7
  ```

- 解题

  - 暴力方法，遍历一遍的过程中每次从窗口中再找到最大的数值，这样很明显是O(n × k)的算法。

  - 这是使用单调队列的经典题目。

    - 这个队列应该长这个样子：

      ```++
      class MyQueue {
      public:
          void pop(int value) {
          }
          void push(int value) {
          }
          int front() {
              return que.front();
          }
      };
      ```

      每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.front()就返回我们要的最大值。

    - 队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。

    - 单调队列: 即单调递减或单调递增的队列。C++中没有直接支持单调队列，需要我们自己来实现一个单调队列

      - 实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。
      - 比如元素{2, 3, 5, 1 ,4}，单调队列里只维护{5, 4} 就够了，保持单调队列里单调递减，此时队列出口元素就是窗口里最大元素。

    -  因为只保留递减的元素，比如上面的{2, 3, 5, 1 ,4}，就需要这个数据结构支持两端都可以删除元素(左端的2、3和右端的1)。显然队列queue和栈都不满足，而实现他们的底层容器[std::deque](https://en.cppreference.com/w/cpp/container/deque)双端队列，可以满足这个需求。

  ```c++
  class Solution {
  private:
      //先实现我们的单调队列
      class MyQueue { //单调队列（从大到小）
      public:
          deque<int> que; // 使用deque来实现单调队列
          // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
          // 同时pop之前判断队列当前是否为空。
          void pop(int value) {
              if (!que.empty() && value == que.front()) {
                  que.pop_front();
              }
          }
          // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
          // 这样就保持了队列里的数值是单调从大到小的了。
          void push(int value) {
              while (!que.empty() && value > que.back()) {
                  que.pop_back();
              }
              que.push_back(value);
  
          }
          // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
          int front() {
              return que.front();
          }
      };
  public:
      vector<int> maxSlidingWindow(vector<int>& nums, int k) {
          MyQueue que;
          vector<int> result;
          for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
              que.push(nums[i]);
          }
          result.push_back(que.front()); // result 记录前k的元素的最大值
          for (int i = k; i < nums.size(); i++) {
              que.pop(nums[i - k]); // 滑动窗口移除最前面元素
              que.push(nums[i]); // 滑动窗口前加入最后面的元素
              result.push_back(que.front()); // 记录对应的最大值
          }
          return result;
      }
  };
  ```


## 8.前K个高频元素

- 题目：347. Top K Frequent Elements

  给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

  ```
  Input: nums = [1,1,1,2,2,3], k = 2
  Output: [1,2]
  
  Input: nums = [1], k = 1
  Output: [1]
  ```

- 解题：

  1. 统计元素出现频率：map

  2. 对频率排序：优先级队列

     - **优先级队列**：就是一个披着队列外衣的堆，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。
     - 缺省情况下priority_queue利用max-heap（大顶堆）完成对元素的排序，这个大顶堆是以vector为表现形式的complete binary tree（完全二叉树）。
     - **堆**：堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。如果父亲结点是大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。

     不使用快排而用优先级队列的原因：使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。

  3. 找出前K个高频元素

     我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。

  ```c++
  // 时间复杂度：O(nlogk)
  // 空间复杂度：O(n)
  class Solution {
  public:
      // 小顶堆定义规则
      // 这里有2个值，不能直接用less<int>表示小顶堆，greater<int>表示大顶堆，因为我们要比较的是键值对的值，即第二个元素。
      class mycomparison {
      public:
          bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
              return lhs.second > rhs.second;
          }
      };
      vector<int> topKFrequent(vector<int>& nums, int k) {
          // 1. 要统计元素出现频率
          unordered_map<int, int> map; // map<nums[i],对应出现的次数>
          for (int i = 0; i < nums.size(); i++) {
              map[nums[i]]++;
          }
  
          // 2. 对频率排序
          // 定义一个小顶堆，大小为k
          // 使用std::priority_queuey优先队列，变量1：存储元素的类型，变量2存储这些元素的容器，变量3用于定义大顶堆/小顶堆的比较规则。
          // std::pair是一个模板类，用于把2个不同/相同类型的量组合成一个量
          // 因为map类型是<int,int>，所以优先队列里要存的也是这个类型
          priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;
  
          // 用固定大小为k的小顶堆，扫面所有频率的数值
          for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
              pri_que.push(*it);	//将数字-频率传入优先队列
              if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k，因为小顶堆的头是最小元素，所以弹出后的就是我们要的频率高的。
                  pri_que.pop();
              }
          }
  
          // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
          vector<int> result(k);
          for (int i = k - 1; i >= 0; i--) {
              result[i] = pri_que.top().first;
              pri_que.pop();
          }
          return result;
      }
  };
  ```

  

  

  

# 七、二叉树

## 1.理论基础

- 二叉树的种类
  - 满二叉树Full Binary Tree：如果一棵二叉树只有度为0的结点（国外定义，国内度必须是2）和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
    - 度：即有几个子节点
    - 深度为k，有2^k-1个节点
    
    ![image-20230515224258664](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202305152242697.png)
    
  - 完全二叉树Complete Binary Tree：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层**最左边**的若干位置。
    - 堆就是一棵完全二叉树，同时保证父子节点的顺序关系
    
    ![image-20230515224358204](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202305152243230.png)
    
  - 二叉搜索树Binary Search Tree：二叉搜索树是一个有有序数值的有序树
    - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
    - 它的左、右子树也分别为二叉排序树
    
    ![image-20230515224426071](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202305152244096.png)
    
  - 平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
    - C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树。所以map、set的增删操作时间时间复杂度是logn
      - unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。
    
    ![image-20230515224449588](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202305152244613.png)
  
- 二叉树的存储方式

  - 二叉树可以链式存储，也可以顺序存储。链式存储方式就用指针， 顺序存储的方式就是用数组。
  - 如果用数组来存储：如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2
  - 一般使用链式存储二叉树

- 二叉树的遍历方式

  - 深度优先遍历：使用递归的方式或借助栈使用非递归的方式来实现

    **这里前中后，其实指的就是中间节点的遍历顺序**

    - 前序遍历（递归法，迭代法）中间节点的顺序：中左右
    - 中序遍历（递归法，迭代法）中间节点的顺序：左中右
    - 后序遍历（递归法，迭代法）中间节点的顺序：左右中

  - 广度优先遍历：使用队列来实现

    - 层次遍历（迭代法）

- 二叉树的定义：

  ```c++
  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };
  ```

## 2.二叉树的递归遍历

### 2.1 递归的基础

每次写递归，要遵从三要素：

1. **确定递归函数的参数和返回值：** 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. **确定终止条件：** 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑：** 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

### 2.2 前序遍历

- 题目：144. Binary Tree Preorder Traversal

  给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

  ```
  Input: root = [1,null,2,3]
  Output: [1,2,3]
  ```

- 解题：

  ```c++
  class Solution {
  public:
      // 1. 确定递归函数的参数和返回值
      void recursion(TreeNode* cur, vector<int>& vec) {
          // 2. 确定终止条件
          if (cur == NULL) return;
          // 3. 确定单层递归的逻辑：前序遍历：中->左->右
          vec.push_back(cur->val);    // 中
          recursion(cur->left, vec);  // 左
          recursion(cur->right, vec); // 右
      }
      vector<int> preorderTraversal(TreeNode* root) {
          vector<int> result;
          recursion(root, result);
          return result;
      }
  };
  ```

### 2.3 中序遍历

- 题目：94. Binary Tree Inorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **中序遍历** 

  ```
  Input: root = [1,null,2,3]
  Output: [1,3,2]
  ```

- 解题：

  ```c++
  class Solution {
  public:
      // 1. 确定递归函数的参数和返回值
      void recursion(TreeNode* cur, vector<int>* result){
          // 2. 确定终止条件
          if(cur==NULL) return;
          // 3. 确定单层递归的逻辑：前序遍历：左->中->右
          recursion(cur->left,result);
          result->push_back(cur->val);
          recursion(cur->right,result);
      }
      vector<int> inorderTraversal(TreeNode* root) {
          vector<int> result;
          // 对比2.2，如果参数用的指针不是索引的话，这里要把地址传进去
          recursion(root, &result);
          return result;
      }
  };
  ```

### 2.4 后序遍历

- 题目：145. Binary Tree Postorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

  ```
  Input: root = [1,null,2,3]
  Output: [3,2,1]
  ```

- 解题：

  ```c++
  class Solution {
  public:
      // 1. 确定递归函数的参数和返回值
      void recursion(TreeNode* cur, vector<int>* result){
          // 2. 确定终止条件
          if(cur==NULL) return;
          // 3. 确定单层递归的逻辑：前序遍历：左->右->中
          recursion(cur->left, result);
          recursion(cur->right,result);
          result->push_back(cur->val);
      }
      vector<int> postorderTraversal(TreeNode* root) {
          vector<int> result;
          // 对比2.2，如果参数用的指针，这里要把地址传进去
          recursion(root,&result);
          return result;
      }
  };
  ```

## 3.二叉树的迭代遍历

用迭代法(非递归方式，用**栈**)来实现2中的二叉树前中后序遍历。

**递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中**，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

所以下面用栈来实现二叉树的前后中序遍历。我们会做2个操作：

1. **处理：将元素放进result数组中**
2. **访问：遍历节点**

### 3.1 前序遍历

前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。

为什么要先加入 右孩子，再加入左孩子呢？ 因为这样出栈的时候才是中左右的顺序。

- 题目：144. Binary Tree Preorder Traversal

  给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

  ```
  Input: root = [1,null,2,3]
  Output: [1,2,3]
  ```

- 解题：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
   class Solution {
  public:
      vector<int> preorderTraversal(TreeNode* root) {
          stack<TreeNode*> st;
          vector<int> result;
          if (root == NULL) return result;
          st.push(root);
          while (!st.empty()) {
              // 1. 处理：将元素放进result数组中
              TreeNode* node = st.top();                       // 中
              st.pop();
              result.push_back(node->val);					
              // 2. 访问：遍历节点
              if (node->right) st.push(node->right);           // 右（空节点不入栈）
              if (node->left) st.push(node->left);             // 左（空节点不入栈）
          }
          return result;
      }
  };
  ```

### 3.2 中序遍历

刚刚写的前序遍历的代码不能和中序遍历通用，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，**因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。**

那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**

那么**在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。**

- 题目：94. Binary Tree Inorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **中序遍历** 

  ```
  Input: root = [1,null,2,3]
  Output: [1,3,2]
  ```

- 解题：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> inorderTraversal(TreeNode* root) {
          vector<int> result;
          stack<TreeNode*> st;
          TreeNode* cur = root;
          while (cur != NULL || !st.empty()) {
              if (cur != NULL) { // 指针来访问节点，访问到最底层
                  st.push(cur); // 将访问的节点放进栈
                  cur = cur->left;                // 左
              } else {
                  cur = st.top(); // 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）
                  st.pop();
                  result.push_back(cur->val);     // 中
                  cur = cur->right;               // 右
              }
          }
          return result;
      }
  };
  
  ```

### 3.3 后序遍历

先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了：

![前序到后序](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/20200808200338924.png)

- 题目：145. Binary Tree Postorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

  ```
  Input: root = [1,null,2,3]
  Output: [3,2,1]
  ```

- 解题：

  ```c++
  class Solution {
  public:
      vector<int> postorderTraversal(TreeNode* root) {
          stack<TreeNode*> st;
          vector<int> result;
          if (root == NULL) return result;
          st.push(root);
          while (!st.empty()) {
              TreeNode* node = st.top();
              st.pop();
              result.push_back(node->val);
              if (node->left) st.push(node->left); // 相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）
              if (node->right) st.push(node->right); // 空节点不入栈
          }
          reverse(result.begin(), result.end()); // 将结果反转之后就是左右中的顺序了
          return result;
      }
  };
  ```

## 4.二叉树的统一迭代法

在3中，先中后序的实现无法保持统一的风格，因为**无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况**。

为了实现统一的风格：**就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。**

如何标记呢，**就是要处理的节点(中)放入栈之后，紧接着放入一个空指针作为标记。** 

之后就可以在遍历的时候判断是不是NULL,如果是NULL就执行从栈取出元素放入结果集的操作。

### 4.1 前序遍历

- 题目：144. Binary Tree Preorder Traversal

  给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

  ```
  Input: root = [1,null,2,3]
  Output: [1,2,3]
  ```

- 解题:

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> preorderTraversal(TreeNode* root) {
          stack<TreeNode*> st;
          vector<int> result;
          if (root != NULL) st.push(root);
          while(!st.empty()){
              TreeNode* node = st.top();
              if(node != NULL){
                  // 前序遍历：中->左->右
                  // 注意，由于栈先进后出的特性，如栈顺序为右->左->中
                  st.pop();	// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中
                  if(node->right) st.push(node->right);// 添加右节点（空节点不入栈）
                  if(node->left) st.push(node->left); // 添加左节点（空节点不入栈）
                  st.push(node);	// 添加中节点
                  st.push(NULL);	// 中节点访问过，但是还没有处理，加入空节点做为标记。
              }
              else{	// 只有遇到空节点的时候，才将下一个节点(中)放进结果集
                  st.pop();	// 将空节点弹出
                  node = st.top();	// 取出中节点
                  result.push_back(node->val);// 加入到结果集
                  st.pop();	// 删除被取出的中节点
              }
          }
          return result;
      }
  };
  ```

  

### 4.2 中序遍历

- 题目：94. Binary Tree Inorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **中序遍历** 

  ```
  Input: root = [1,null,2,3]
  Output: [1,3,2]
  ```

- 解题：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> inorderTraversal(TreeNode* root) {
          vector<int> result;
          stack<TreeNode*> st;
          if(root!=NULL) st.push(root);
          while(!st.empty()){
              TreeNode* node = st.top();
              if(node!=NULL){ 
                  //和4.1变得只是从中->左->右变成了左->中->右
                  //注意，由于栈先进后出的特性，如栈顺序为右->中->左
                  st.pop();
                  if(node->right) st.push(node->right);
                  st.push(node);
                  st.push(NULL);
                  if(node->left) st.push(node->left);
              }else{
                  st.pop();
                  node = st.top();
                  result.push_back(node->val);
                  st.pop();
              }
          }
          return result;
      }
  };
  ```

### 4.3 后序遍历

- 题目：145. Binary Tree Postorder Traversal

  给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

  ```
  Input: root = [1,null,2,3]
  Output: [3,2,1]
  ```

- 解题:

  ```c++
  class Solution {
  public:
      vector<int> postorderTraversal(TreeNode* root) {
          vector<int> result;
          stack<TreeNode*> st;
          if(root!=NULL) st.push(root);
          while(!st.empty()){
              TreeNode* node = st.top();
              if(node!=NULL){ 
                  //和4.1变得只是从中->左->右变成了左->右->中
                  //注意，由于栈先进后出的特性，如栈顺序为中->右->左
                  st.pop();
                  st.push(node);
                  st.push(NULL);
                  if(node->right) st.push(node->right);
                  if(node->left) st.push(node->left);
              }else{
                  st.pop();
                  node = st.top();
                  result.push_back(node->val);
                  st.pop();
              }
          }
          return result;
      }
  };
  ```


## 5.二叉树的层序遍历

2,3,4都是深度优先遍历，这里是另一种遍历方式：层序遍历。

需要借用一个辅助数据结构即队列来实现，**队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。**

**而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**、

除了用栈外，也可以向2一样用递归的形式来完成层序遍历

### 5.1 二叉树的层序遍历

- 题目102.Binary Tree Level Order Traversal

  给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/tree1.jpg)

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: [[3],
  		 [9,20],
  		 [15,7]]
  ```

- 解题：

  1. 用栈来实现

     ```c++
     /**
      * Definition for a binary tree node.
      * struct TreeNode {
      *     int val;
      *     TreeNode *left;
      *     TreeNode *right;
      *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
      *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
      *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
      * };
      */
     class Solution {
     public:
         vector<vector<int>> levelOrder(TreeNode* root) {
             queue<TreeNode*> que;
             if (root != NULL) que.push(root);
             vector<vector<int>> result;
             while (!que.empty()) {
                 int size = que.size();
                 vector<int> vec;
                 // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
                 for (int i = 0; i < size; i++) {
                     TreeNode* node = que.front();
                     que.pop();
                     vec.push_back(node->val);
                     if (node->left) que.push(node->left);
                     if (node->right) que.push(node->right);
                 }
                 result.push_back(vec);
             }
             return result;
         }
     };
     ```

  2. 递归法

     ```c++
     class Solution {
     public:
         void order(TreeNode* cur, vector<vector<int>>& result, int depth)
         {
             if (cur == nullptr) return;
             // 每当到达新的一层，就往result这个2维数组里加入一个新的1维数组
             if (result.size() == depth) result.push_back(vector<int>());
             // 往对应的一维数组里添加元素
             result[depth].push_back(cur->val);
             // 递归下去往新的一层里加元素
             order(cur->left, result, depth + 1);
             order(cur->right, result, depth + 1);
         }
         vector<vector<int>> levelOrder(TreeNode* root) {
             vector<vector<int>> result;
             int depth = 0;
             order(root, result, depth);
             return result;
         }
     };
     ```

### 5.2 二叉树的层次遍历 II

-  题目：107.Binary Tree Level Order Traversal II

  给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/tree1.jpg)
  
  ```c++
  class Solution {
  public:
      vector<vector<int>> levelOrderBottom(TreeNode* root) {
          queue<TreeNode*> que;
          if (root != NULL) que.push(root);
          vector<vector<int>> result;
          while (!que.empty()) {
              int size = que.size();
              vector<int> vec;
              for (int i = 0; i < size; i++) {
                  TreeNode* node = que.front();
                  que.pop();
                  vec.push_back(node->val);
                  if (node->left) que.push(node->left);
                  if (node->right) que.push(node->right);
              }
              result.push_back(vec);
          }
          reverse(result.begin(), result.end()); // 在这里反转一下数组即可
          return result;
  
      }
  };
  ```
  

### 5.3 二叉树的右试图

- 题目：199. Binary Tree Right Side View

  给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/tree.jpg)

  ```
  Input: root = [1,2,3,null,5,null,4]
  Output: [1,3,4]
  ```

- 解题：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> rightSideView(TreeNode* root) {
          vector<int> result;
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size = que.size();
              for(int i=0; i<size; i++){
                  TreeNode* node = que.front();
                  que.pop();
                  if(i==(size-1)) result.push_back(node->val);
                  if(node->left) que.push(node->left);
                  if(node->right) que.push(node->right);
              }
          }
          return result;
      }
  };
  ```

### 5.4 二叉树的层平均值

- 题目: 637. Average of Levels in Binary Tree

  给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/tree1.jpg)

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: [3.00000,14.50000,11.00000]
  Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11.
  Hence return [3, 14.5, 11].
  ```

- 解题

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<double> averageOfLevels(TreeNode* root) {
          vector<double> result;
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              double sum = 0;
              for(int i=0;i<size;i++){
                  TreeNode* node = que.front();
                  que.pop();
                  sum+=node->val;
                  if(node->left) que.push(node->left);
                  if(node->right) que.push(node->right);
              }
              result.push_back(sum/size);
          }
          return result;
      }
  };
  ```

### 5.5 N叉树的层序遍历

- 题目: 429. N-ary Tree Level Order Traversal

  给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/narytreeexample.png)

  ```
  Input: root = [1,null,3,2,4,null,5,6]
  Output: [[1],[3,2,4],[5,6]]
  ```

- 解题

  ```c++
  /*
  // Definition for a Node.
  class Node {
  public:
      int val;
      vector<Node*> children;
  
      Node() {}
  
      Node(int _val) {
          val = _val;
      }
  
      Node(int _val, vector<Node*> _children) {
          val = _val;
          children = _children;
      }
  };
  */
  
  class Solution {
  public:
      vector<vector<int>> levelOrder(Node* root) {
          queue<Node*> que;
          vector<vector<int>> result;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              vector<int> temp;
              for(int i=0;i<size;i++){
                  Node* current = que.front();
                  que.pop();
                  temp.push_back(current->val);
                  int size_children=current->children.size();
                  for(int j=0;j<size_children;j++){
                      que.push(current->children[j]);
                  }
              }
              result.push_back(temp);
          }
          return result;
      }
  };
  ```

### 5.6  在每个树行中找最大值

- 题目：515. Find Largest Value in Each Tree Row

  您需要在二叉树的每一行中找到最大的值。

  ![img](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/largest_e1.jpg)

  ```
  Input: root = [1,3,2,5,3,null,9]
  Output: [1,3,9]
  ```

- 解题：

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      vector<int> largestValues(TreeNode* root) {
          vector<int> result;
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size = que.size();
              int max=INT_MIN;
              for(int i=0;i<size;i++){
                  TreeNode* current = que.front();
                  que.pop();
                  if(current->val > max) max=current->val;
                  if(current->left) que.push(current->left);
                  if(current->right) que.push(current->right);
              }
              result.push_back(max);
          }
          return result;
      }
  };
  ```

### 5.7 填充每个节点的下一个右侧节点指针

- 题目:116. Populating Next Right Pointers in Each Node

  给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

  ```
  struct Node {
    int val;
    Node *left;
    Node *right;
    Node *next;
  }
  ```

  填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

  初始状态下，所有 next 指针都被设置为 NULL。

  ![img](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202306071820022.png)

  ```
  输入：root = [1,2,3,4,5,6,7]
  输出：[1,#,2,3,#,4,5,6,7,#]
  解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
  ```

- 解题

  ```c++
  /*
  // Definition for a Node.
  class Node {
  public:
      int val;
      Node* left;
      Node* right;
      Node* next;
  
      Node() : val(0), left(NULL), right(NULL), next(NULL) {}
  
      Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}
  
      Node(int _val, Node* _left, Node* _right, Node* _next)
          : val(_val), left(_left), right(_right), next(_next) {}
  };
  */
  
  class Solution {
  public:
      Node* connect(Node* root) {
          queue<Node*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              Node* current;
              Node* previous;
              int size = que.size();
              for(int i=0; i<size; i++){
                  if(i==0){
                      previous = que.front();// 取出一层的头结点
                      que.pop();
                      current = previous;
                  }else{
                      current = que.front();
                      que.pop();
                      previous->next = current;// 本层前一个节点next指向本节点
                      previous = current;
                  }
                  if(current->left) que.push(current->left);
                  if(current->right) que.push(current->right);
              }
              current->next = NULL;// 本层最后一个节点指向NULLe
          }
          return root;
      }
  };
  ```

### 5.8 填充每个节点的下一个右侧节点指针II

- 题目：117. Populating Next Right Pointers in Each Node II

  ![img](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202306071929380.png)

  ```
  Input: root = [1,2,3,4,5,null,7]
  Output: [1,#,2,3,#,4,5,7,#]
  Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.
  ```

- 解题：

  ```c++
  /*
  // Definition for a Node.
  class Node {
  public:
      int val;
      Node* left;
      Node* right;
      Node* next;
  
      Node() : val(0), left(NULL), right(NULL), next(NULL) {}
  
      Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}
  
      Node(int _val, Node* _left, Node* _right, Node* _next)
          : val(_val), left(_left), right(_right), next(_next) {}
  };
  */
  
  class Solution {
  public:
      Node* connect(Node* root) {
          queue<Node*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              Node* current;
              Node* previous;
              for(int i=0;i<size;i++){
                  if(i==0){
                      previous=que.front();
                      que.pop();
                      current = previous;
                  }else{
                      current = que.front();
                      que.pop();
                      previous->next=current;
                      previous=current;
                  }
                  if(current->left) que.push(current->left);
                  if(current->right) que.push(current->right);
              }
              current->next=NULL;
          }
          return root;
      }
  };
  ```

### 5.9 二叉树的最大深度

- 题目：104. Maximum Depth of Binary Tree

  给定一个二叉树，找出其最大深度。

  二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

  说明: 叶子节点是指没有子节点的节点。

  ![img](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202306071939623.jpeg)

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: 3
  ```

- 解题

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      int maxDepth(TreeNode* root) {
          int depth=0;
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              for(int i=0;i<size; i++){
                  TreeNode* node = que.front();
                  que.pop();
                  if(node->left) que.push(node->left);
                  if(node->right) que.push(node->right);
              }
              depth++;
          } 
          return depth;
      }
  };
  ```

- 也可以用递归的方法

  1. 确定递归函数的参数和返回值：
  2. 确定终止条件：
  3. 确定单层递归的逻辑：

  ```c++
  class solution {
  public:
      // 1. 确定递归函数的参数和返回值
      int getdepth(TreeNode* node) {
          // 2. 确定终止条件
          if (node == NULL) return 0;
          // 3. 确定单层递归的逻辑
          int leftdepth = getdepth(node->left);       // 左
          int rightdepth = getdepth(node->right);     // 右
          int depth = 1 + max(leftdepth, rightdepth); // 中
          return depth;
      }
      int maxDepth(TreeNode* root) {
          return getdepth(root);
      }
  };
  ```

  

### 5.10二叉树的最小深度

- 题目:111. Minimum Depth of Binary Tree

  **需要注意的是，只有当左右孩子都为空的时候，才说明遍历的最低点了。如果其中一个孩子为空则不是最低点**

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: 2
  ```

- 解题

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      int minDepth(TreeNode* root) {
          int depth=0;
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              depth++;
              for(int i=0;i<size; i++){
                  TreeNode* node = que.front();
                  que.pop();
                  if(node->left) que.push(node->left);
                  if(node->right) que.push(node->right);
                  if(!node->left && !node->right) return depth;
              }
              
          } 
          return depth;
      }
  };
  ```

- 递归法：

  1. 确定递归函数的参数和返回值：
  2. 确定终止条件：
  3. 确定单层递归的逻辑：

  ```c++
  class Solution {
  public:
      int getDepth(TreeNode* node) {
          if (node == NULL) return 0;
          int leftDepth = getDepth(node->left);           // 左
          int rightDepth = getDepth(node->right);         // 右
                                                          // 中
          // 当一个左子树为空，右不为空，这时并不是最低点
          if (node->left == NULL && node->right != NULL) { 
              return 1 + rightDepth;
          }   
          // 当一个右子树为空，左不为空，这时并不是最低点
          if (node->left != NULL && node->right == NULL) { 
              return 1 + leftDepth;
          }
          int result = 1 + min(leftDepth, rightDepth);
          return result;
      }
  
      int minDepth(TreeNode* root) {
          return getDepth(root);
      }
  };
  ```

  

## 6.反转二叉树

- 题目

  翻转一棵二叉树。

  ![img](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/202306071959208.jpeg)

  ```
  Input: root = [4,2,7,1,3,6,9]
  Output: [4,7,2,9,6,3,1]
  ```

- 思路

  **只要把每一个节点的左右孩子翻转一下，就可以达到整体翻转的效果**

  **这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了**

  那么层序遍历可以不可以呢？**依然可以的！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的！**

### 6.1 递归法

- 递归三部曲：

  1. 确定递归函数的参数和返回值

     参数就是要传入节点的指针，不需要其他参数了，通常此时定下来主要参数，如果在写递归的逻辑中发现还需要其他参数的时候，随时补充。

  2. 确定终止条件

     当前节点为空的时候，就返回

  3. 确定单层递归的逻辑

     因为是先前序遍历，所以先进行交换左右孩子节点，然后反转左子树，反转右子树

- 解题

  ```c++
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      	// 1. 确定递归函数的参数和返回值
      TreeNode* invertTree(TreeNode* root) {
          // 2. 确定终止条件
          if(root==NULL) return root;
          // 3. 确定单层递归的逻辑
          swap(root->left,root->right); //中
          invertTree(root->left); //左
          invertTree(root->right); //右
          return root;
      }
  };
  ```

### 6.2 迭代法

- 深度优先遍历(栈)

  递归能做的，栈也都能做。

  ```c++
  // 前序遍历，迭代写法
  class Solution {
  public:
      TreeNode* invertTree(TreeNode* root) {
          if (root == NULL) return root;
          stack<TreeNode*> st;
          st.push(root);
          while(!st.empty()) {
              TreeNode* node = st.top();              // 中
              st.pop();
              swap(node->left, node->right);
              if(node->right) st.push(node->right);   // 右
              if(node->left) st.push(node->left);     // 左
          }
          return root;
      }
  };
  
  // 前序遍历，统一迭代方法
  class Solution {
  public:
      TreeNode* invertTree(TreeNode* root) {
          stack<TreeNode*> st;
          if (root != NULL) st.push(root);
          while (!st.empty()) {
              TreeNode* node = st.top();
              if (node != NULL) {
                  st.pop();
                  if (node->right) st.push(node->right);  // 右
                  if (node->left) st.push(node->left);    // 左
                  st.push(node);                          // 中
                  st.push(NULL);
              } else {
                  st.pop();
                  node = st.top();
                  st.pop();
                  swap(node->left, node->right);          // 节点处理逻辑
              }
          }
          return root;
      }
  };
  ```

- 广度优先遍历(队列)

  ```c++
  class Solution {
  public:
      TreeNode* invertTree(TreeNode* root) {
          queue<TreeNode*> que;
          if(root!=NULL) que.push(root);
          while(!que.empty()){
              int size=que.size();
              for(int i=0;i<size;i++){
                  TreeNode* node= que.front();
                  que.pop();
                  swap(node->left,node->right);
                  if(node->left) que.push(node->left);
                  if(node->right) que.push(node->right);
              }
          }
          return root;
      }
  };
  ```


## 7.对称二叉树

题目：101. Symmetric Tree

给定一个二叉树，检查它是否是镜像对称的。

```
Input: root = [1,2,2,3,4,4,3]
Output: true

Input: root = [1,2,2,null,3,null,3]
Output: false
```

对于二叉树是否对称，要比较的是根节点的左子树与右子树是不是相互翻转的。

### 7.1 递归法

本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。

**正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。**都可以理解算是后序遍历。

- 递归三部曲：

  1. 确定递归函数的参数和返回值

     因为我们要比较的是根节点的两个子树是否是相互翻转的，进而判断这个树是不是对称树，所以要比较的是两个树，参数自然也是左子树节点和右子树节点。

     返回值自然是bool类型。

  2. 确定终止条件

     要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

     节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

     - 左节点为空，右节点不为空，不对称，return false

     - 左不为空，右为空，不对称 return false

     - 左右都为空，对称，返回true

     此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

     - 左右都不为空，比较节点数值，不相同就return false

     此时左右节点不为空，且数值也不相同的情况我们也处理了。

  3. 确定单层递归的逻辑

     此时才进入单层递归的逻辑，单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。

     - 比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。

     - 比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。

     - 如果左右都对称就返回true ，有一侧不对称就返回false 。

- 代码：

  ```c++
  class Solution {
  public:
      // 1. 确定递归函数的参数和返回值
      bool compare(TreeNode* left, TreeNode* right) {
          // 2. 确定终止条件
          // 首先排除空节点的情况
          if (left == NULL && right != NULL) return false;
          else if (left != NULL && right == NULL) return false;
          else if (left == NULL && right == NULL) return true;
          // 排除了空节点，再排除数值不相同的情况
          else if (left->val != right->val) return false;
  		
          // 3. 确定单层递归的逻辑
          // 此时就是：左右节点都不为空，且数值相同的情况
          // 此时才做递归，做下一层的判断
          bool outside = compare(left->left, right->right);   // 左子树：左、 右子树：右
          bool inside = compare(left->right, right->left);    // 左子树：右、 右子树：左
          bool isSame = outside && inside;                    // 左子树：中、 右子树：中 （逻辑处理）
          return isSame;
  
      }
      bool isSymmetric(TreeNode* root) {
          if (root == NULL) return true;
          return compare(root->left, root->right);
      }
  };
  ```

### 7.2 迭代法

下面用队列和栈，其实用任何数据结构来暂时保存节点值都是可以的。

- 使用队列

  ```c++
  class Solution {
  public:
  
      bool isSymmetric(TreeNode* root) {
          queue<TreeNode*> que1;
          queue<TreeNode*> que2;
          if(root==NULL) return true;
          que1.push(root->left);
          que2.push(root->right);
  
          while(!que1.empty() && !que2.empty()){
              int size = que1.size();
              for(int i=0;i<size;i++){
                  TreeNode* node1 = que1.front();
                  que1.pop();
                  TreeNode* node2 = que2.front();
                  que2.pop();
                  if (!node1 && !node2) {  // 左节点为空、右节点为空，此时说明是对称的
                      continue;
                  }
                  // 左右一个节点不为空，或者都不为空但数值不相同，返回false
                  if(!node1 || !node2 || node1->val != node2->val) return false;
                  // 注意下面不能加if(que->right)判断，否则NULL不会被记录
              	// 注意下面的加节点的顺序
                  que1.push(node1->left);
                  que1.push(node1->right);
                  que2.push(node2->right);
                  que2.push(node2->left);
              }
          }
          return true;
      }
  };
  ```

- 使用栈

  ```c++
  class Solution {
  public:
  
      bool isSymmetric(TreeNode* root) {
          stack<TreeNode*> st1;
          stack<TreeNode*> st2;
          if(root==NULL) return true;
          st1.push(root->left);
          st2.push(root->right);
  
          while(!st1.empty() && !st2.empty()){
              int size = st1.size();
              for(int i=0;i<size;i++){
                  TreeNode* node1 = st1.top();
                  st1.pop();
                  TreeNode* node2 = st2.top();
                  st2.pop();
                  if (!node1 && !node2) {  // 左节点为空、右节点为空，此时说明是对称的
                      continue;
                  }
                  if(!node1 || !node2 || node1->val != node2->val) return false;
                  st1.push(node1->left);
                  st1.push(node1->right);
                  st2.push(node2->right);
                  st2.push(node2->left);
              }
          }
          return true;
      }
  };
  ```

  

## 8.平衡二叉树

题目：110. Balanced Binary Tree

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

  ```
  Input: root = [3,9,20,null,null,15,7]
  Output: true
  ```

### 8.1 递归

1. 明确递归函数的参数和返回值

   参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。

   如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。

2. 明确终止条件

   递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0

3. 明确单层递归的逻辑

   如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。

   分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。

```c++
class Solution {
public:
    // 1. 明确递归函数的参数和返回值
    int getHeight(TreeNode* root){
        // 2. 明确终止条件
        if(root==NULL) return 0;
        int leftheight= getHeight(root->left);
        if(leftheight == -1) return -1;
        int rightheight = getHeight(root->right);
        if(rightheight == -1) return -1;
        // 3. 明确单层递归的逻辑
        if(abs(leftheight-rightheight)>1)
            return -1;
        else
            return 1+max(leftheight,rightheight);
    }
    bool isBalanced(TreeNode* root) {
        if(getHeight(root)==-1)
            return false;
        else
            return true;
    }
};
```

### 8.2 迭代(不推荐)

本题的迭代方式可以先定义一个函数，专门用来求高度。

这个函数通过栈模拟的后序遍历找每一个节点的高度（其实是通过求传入节点为根节点的最大深度来求的高度）

```c++
class Solution {
private:
    int getDepth(TreeNode* cur) {
        stack<TreeNode*> st;
        if (cur != NULL) st.push(cur);
        int depth = 0; // 记录深度
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);
                depth++;
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                depth--;
            }
            result = result > depth ? result : depth;
        }
        return result;
    }

public:
    bool isBalanced(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return true;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            if (abs(getDepth(node->left) - getDepth(node->right)) > 1) {
                return false;
            }
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return true;
    }
};
```

# 八、回溯算法

## 1.理论基础

- 回溯算法也叫回溯搜索法，是递归的副产品。

  - 回溯的本质是穷举，琼剧所有的可能，然后选出想要的答案。所以效率不高。

- 回溯法，一般解决如下问题：

  - 组合问题：N个数里面按一定规则找出k个数的集合。组合无序
  - 切割问题：一个字符串按一定规则有几种切割方式
  - 子集问题：一个N个数的集合里有多少符合条件的子集
  - 排列问题：N个数按一定规则全排列，有几种排列方式。排列有序
  - 棋盘问题：N皇后，解数独等等

  所有回溯法的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

- 回溯函数做题模板

  ```c++
  // 第一步：回溯函数模板返回值以及参数
  // 因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
  void backtracking(参数) {
      // 第二步：回溯函数终止条件
      // 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
      if (终止条件) {
          存放结果;
          return;
      }
  	
      // 第三步：回溯搜索的遍历过程
      // 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
      for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
          处理节点;
          backtracking(路径，选择列表); // 递归
          回溯，撤销处理结果
      }
  }
  ```
  
  
  

# 九、贪心算法

## 1.理论基础

- **贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。
  - 贪心算法并没有固定的套路。所以唯一的难点就是如何通过局部最优，推出整体最优。
- 如何验证可不可以用贪心?
  - **最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**
  - 严谨的话需要数学证明
    - 数学归纳法
    - 反证法
- 一般截图步骤
  - 将问题分解为若干个子问题
  - 找出适合的贪心策略
  - 求解每一个子问题的最优解
  - 将局部最优解堆叠成全局最优解

  
  
# 十、动态规划

Dynamic Programming,简称dp

## 1.理论基础

### 1.1 基本思想

参考：https://www.zhihu.com/question/23995189

- **什么是DP？**

  将一个问题拆分成几个子问题，分别求解这些子问题的最优解，就可以得到总问题的最优解。

- **什么问题可以用DP来解决？**

  这个问题可以拆成几个小问题，且满足无后效性、最优子结构性质。

  - 无后效性：未来与过去无关，即如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。

    求得了f(n)就固定住了,f(n-1)...f(n-x)的值不管怎么样都对f(n)无影响了。

  - 最优子结构：大问题的最优解可以由小问题的最优解推出

- **DP为什么比暴力快**

  - 无论是DP还是暴力，我们的算法都是在可能解空间内，寻找最优解。

  - 暴力做法是枚举所有的可能解，这是最大的可能解空间。　

  - 而DP是枚举有希望成为答案的解，这个空间比暴力的小得多。

  - 比如用尽可能少的5,1,11来组成15：

    - 暴力会考虑：15 = 5+5+1+1+1+1+1
    - 而DP不会，因为这不可能是最优解

  - **DP的核心思想**：**尽量缩小可能解空间**

    一般来说，解空间越小，寻找解就越快。这样就完成了优化。

- **如何设计DP**

  - 第一步：设计状态：我是谁

  - 第二步：设计转移：有2种方式：
    1. 我从哪里来，又称pull型转移
    2. 我要到哪里去，又称push型转移

  **例子：用尽可能少的5,1,11元来组成15元：**

  - 第一步：设计状态

    用f(n)来表示凑出n所需的最少钞票数量

  - 第二步：设计转移，这里使用第一种方式，即我从哪里来

    - f(15)有三种情况：

      - 取11:f(15)=f(4)+1 =4+1=5
      - 取5: f(15)=f(10)+1=2+1=3
      - 取1: f(15)=f(14)+1=4+1=5

      显然我们要取cost最小的那个，即5.

    - 这就给了我们启示：f(n)只和f(n-1).f(n-5),f(n-11)有关

      也即我们的**转移方程**：$f(n)=min\{f(n-1),f(n-5),f(n-11) \}+1$

  - 利用上面的转移方程，我们要求出f(n)，只需要求出几个更小的f值：既然如此，我们从小到大把所有的f(x)求出来不就好了？

    ```c
    int f[105],i,n,cost;
    scanf("%d",&n);	// n是希望凑的数值，比如这里是15
    f[0]=0;			// 从最小的0开始网上凑，每一个i需要用到1，5，11的最小次数
    for(i=1;i<=n;i++){
        cost = INF;
        if(i-1>=0) cost = min(cost, f[i-1]+1);
        if(i-5>=0) cost = min(cost, f[i-5]+1);
        if(i-11>=0)cost = min(cost, f[i-11]+1);		// 之所以要用min,对应于转移方程，比如15在上个if就求出了更小的cost
        f[i] = cost;
    }
    ```

    

### 1.2 解题思路

- 如果某一问题有很多重叠子问题，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的.

- 解题步骤
  1. 确定dp数组（dp table）以及下标的含义
  2. 确定递推公式
  3. dp数组如何初始化
  4. 确定遍历顺序
  5. 举例推导dp数组

- 动态规划如何debug

  - **做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

  - 然后再写代码，如果代码没通过就**打印dp数组**，看看是不是和自己预先推导的哪里不一样。

    - 如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。
    - 如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

  - 具体debug时问自己三个问题

    1. 这道题目我举例推导状态转移公式了么？
    2. 我打印dp数组的日志了么？
    3. 打印出来了dp数组和我想的一样么？

    
