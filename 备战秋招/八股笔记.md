# C++相关

## 1.面向对象的三大特性

封装、继承、多态

**封装Encapsulation**

- 封装就是把客观的事物的变量和方法打包成一个类
- 这些变量和方法按照级别对外界开放
  - public：对外公开，级别最高。
  - protect：只对当前类或其子类公开，级别次之。
  - private:不对外公开，只能在对象内部访问，级别最低。

**继承Inheritance**

- 继承是指这样⼀种能⼒：它可以使⽤现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进⾏扩展。
- 通过继承创建的新类称为“⼦类”或者“派⽣类”，被继承的类称为“基类”或“⽗类”

**多态Polymorphism**

- 同一个操作符或方法在不同数据类型上具有不同的含义或行为。

## 2. 虚函数和纯虚函数

[参考](https://zhuanlan.zhihu.com/p/37331092)

虚函数是实现多态的机制。其核心理念就是通过基类访问派生类定义的函数。

多态性使得程序调用的函数是在运行时动态确定的，而不是在编译时静态确定的。

使用一个基类类型的指针或者引用，来指向子类对象，进而调用由子类复写的个性化的虚函数，这是C++实现多态性的一个最经典的场景。

- **虚函数**：

  - 在类成员方法的声明（不是定义）语句前加“virtual”, 如 `virtual void func()`
  - 对于虚函数，子类可以（也可以不）重新定义基类的虚函数，该行为称之为复写Override。
  - 子类如果不提供虚函数的实现，将会自动调用基类的缺省虚函数实现，作为备选方案；

- **纯虚函数**：

  - 在虚函数后加“=0”，如 `virtual void func()=0`

  - 对于纯虚函数，子类必须提供纯虚函数的个性化实现。

  - 子类如果不提供纯虚函数的实现，编译将会失败。

  - 通过指针，定义了虚函数的基类，可以调用它的派生类的实现的方法

    ```c++
    class Shape {
    public:
      virtual void draw() = 0; // 虚函数
    };
    
    class Rectangle : public Shape {
    public:
      void draw() override {
        std::cout << "绘制矩形" << std::endl;
      }
    };
    
    class Circle : public Shape {
    public:
      void draw() override {
        std::cout << "绘制圆形" << std::endl;
      }
    };
    
    int main() {
      Shape* shape = new Rectangle();
      shape->draw(); // 调用的是Rectangle重写后的`draw()`方法
      return 0;
    }
    ```

    

## 3. 指针，引用的区别

### 3.1 区别：

- 引用必须在声明时被初始化，但是不分配存储空间。但指针不在声明时初始化，在初始化的时候需要分配存储空间。
- 引用初始化后不能被改变，即永远指向某个对象，但指针可以改变所指的对象。
  - 因为**指针是一个实体**，而**引用仅是个别名**；
  - 所以 “sizeof 引用”得到的是所指向的变量（对象）的大小，而“sizeof 指针”得到的是指针本身（所指向的变量或对象的**地址**）的大小；
- 不存在指向空值的引用，但是存在指向空值的指针。
  - 因为引用必须指向一个变量，是这个变量的别名

### 3.2 基本使用：

- 引用：

  ```c++
  int m；  
  int &n = m；  
  ```

  - 引用(reference)n是被引用物(referent)m的别名
  - 对n的任何操作就是对m的操作。
  - **注意这里的&是写在引用n前面的**

- 指针：

  ```c++
  int  *ip;        // 指针变量的声明
  ip = &var;       // 在指针变量中存储 var 的地址
  ```

  - **注意这里的&是和上面的引用符号不同，它是用来获得变量var的地址的**

### 3.3 函数值传递：**值传递、指针传递和引用传递**

- 值传递：

  ```c++
  void Func1(int x)  
  {  
      x = x + 10;  
  }  
  int n = 0;  
  Func1(n);  
  cout << “n = ” << n << endl;// n = 0 
  ```

  - 改变x不会改变n，n仍然是0

- 指针传递：

  ```c++
  void Func2(int *x)  
  {  
      (* x) = (* x) + 10;  
  }  
  ⋯  
  int n = 0;  
  Func2(&n);  //将变量n的地址传给函数的指针变量x
  cout << “n = ” << n << endl; // n = 10  
  
  // 指针传递还可以用于传递数组,下面两种效果是一样的
      // 1. 形式参数是一个指针：
  	void myFunction(int *param{}
      // 2. 形式参数是一个数组：
      void myFunction(int param[])
      //调用时，不用传地址，直接传数组就行：
      int par[];
      myFunction(par);
  ```

  - 由于Func2 函数体内的x 是指向外部变量n 的指针，改变该指针的内容将导致n 的值改变，所以n 的值成为10.

- 引用传递：

  ```c++
  void Func3(int &x)  
  {  
      x = x + 10;  
  }  
  //...  
  int n = 0;  
  Func3(n);  // x是n的别名，指向同一个东西
  cout << “n = ” << n << endl; // n = 10  
  ```

  - 由于Func3 函数体内的x 是外部变量n 的引用，x和n 是同一个东西，改变x 等于改变n，所以n 的值成为10.
  - 能用引用传递就不用指针传递

### 3.4 Const的作用

- const只能作用于指针，不能作用于引用

- const只能修饰输入参数,不能修饰输出参数，否则值不变的输出就没有意义了。

  在指针和引用传递时，可以用于防止函数修改传入的参数

  ```c++
  //例如StringCopy 函数：
  void StringCopy(char *strDestination, const char *strSource);
  ```

  - 其中strSource 是输入参数，strDestination 是输出参数。他们都是指针传递，函数内对他们操作，都会改变他们的值
  - 给strSource 加上const修饰后，如果函数体内的语句试图改动strSource 的内容，编译器将指出错误。

- const还可以修饰函数的返回值

  如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。

  ```c++
  // 例如函数：
  const char * GetString(void);
  // 错误用法：
  char *str = GetString();
  // 正确的用法：
  const char *str = GetString();
  ```

  

## 4. C++如何实现内存管理

C++中内存管理主要有两种方式：

- **手动管理**：程序员负责申请和释放内存。
  - `int* p = new int`： new 给一个变量p申请一个整数内存
  - `delete p`：delete释放这个变量的内存
- **自动管理**：由编译器或运行时系统负责申请和释放内存。
  - **局部变量**：在函数内部定义的局部变量存储在栈内存中，函数结束时栈内存会自动释放。
  - **智能指针**：智能指针是一种特殊的指针，它会自动管理指针所指向的内存。

### 4.1 手动管理内存make_unique/new/malloc

`std::make_unique`、`new` 和 `malloc` 都是用于分配内存的机制

- **std::make_unique, std::make_shared 和 std::make_weak函数**:

  - 是 C++11 引入的标准库函数，用于创建动态分配对象的 `std::unique_ptr` 智能指针。
  - **自动管理内存**，不需要手动释放。
  - 支持在创建对象时传递构造函数参数。
  - 更安全，能够防止资源泄漏和内存管理错误。

  ```c++
  // 使用 std::make_unique 创建动态分配的整数对象
  std::unique_ptr<int> ptr = std::make_unique<int>(42);
  
  // ptr 离开作用域时，分配的整数对象会被自动释放
  ```

- **new**

  - 是 C++ 中的运算符，用于在堆上分配内存，并返回指向分配内存的指针。
  - 需要手动释放内存，使用 `delete` 运算符来释放。
  - 支持在分配内存时调用构造函数。
  - **可以用于任何类型的对象**。
  - 可能会出现内存泄漏和悬挂指针问题，需要谨慎管理。

  ```c++
  // 使用 new 运算符分配整数对象的内存
  int* ptr = new int(42);
  
  // 使用完毕后，需要手动释放内存
  delete ptr;
  ```

- **malloc**

  - 是 C 语言中的函数，用于分配内存，并返回指向分配内存的指针。
  - 需要手动释放内存，使用 `free` 函数来释放。
  - **不会调用对象的构造函数**，只是简单分配内存空间。即不能用于类
  - 通常用于分配基本数据类型或无需构造函数初始化的数据。
  - 与 C++ 的对象管理机制不兼容，可能导致资源泄漏和内存管理错误。

  ```c++
  // 使用 malloc 函数分配整数对象的内存
  int* ptr = (int*)malloc(sizeof(int));
  
  // 使用完毕后，需要手动释放内存
  free(ptr);
  ```

## 5. 智能指针

### 5.1 什么是智能指针

- 智能指针（Smart Pointer）是一种用于管理动态分配的资源（通常是内存）的 C++ 技术，旨在**简化资源的生命周期管理**，从而**减少内存泄漏和资源管理错误的风险**。
- 智能指针是一种封装了原始指针的c++类，它们提供了自动化资源管理的功能，**避免了手动释放内存或资源的繁琐工作**。
- 智能指针是在 [<memory>](https://learn.microsoft.com/zh-cn/cpp/standard-library/memory?view=msvc-170) 头文件中的 `std` 命名空间中定义的
- 主要目标：
  - **自动化资源释放：** 智能指针会在适当的时候自动释放其所管理的资源，从而避免内存泄漏和资源泄漏。
  - **防止悬挂指针：** 通过合适的生命周期管理，智能指针可以防止悬挂指针（指向已释放内存的指针）的情况。
  - **提高代码安全性：** 由于智能指针负责管理资源，可以减少人为错误，从而提高代码的安全性和可维护性。

- 三种智能指针类型：
  - **std::unique_ptr**：独占所有权的智能指针，用于确保在特定时间只有一个指针指向资源。
  - **std::shared_ptr**：允许多个指针共享资源所有权的智能指针，使用引用计数器来管理资源的生命周期。
    - 这个计数器跟踪有多少个 `std::shared_ptr` 实例共享同一个资源
    - 当最后一个 `std::shared_ptr` 离开资源时，资源会被正确地释放。
  - **std::weak_ptr**：通常和`std::shared_ptr` 一起使用，用于避免循环引用和解决 `std::shared_ptr` 可能的资源泄漏问题。
    - `std::weak_ptr` 可以帮助避免资源泄漏，主要是因为它不会增加引用计数，从而不会影响由 `std::shared_ptr` 管理的资源的生命周期。
    - 将一个weak_ptr绑定到一个shared_ptr对象，不会改变shared_ptr的引用计数。一旦最后一个所指向对象的shared_ptr被销毁，所指向的对象就会被释放，即使此时有weak_ptr指向该对象，所指向的对象依然被释放。

### 5.2 和传统指针的对比

- 传统指针即4.中说的手动管理内存
- 智能指针即4.中说的自动管理内存

```c++
// 传统指针：
void UseRawPointer()
{
    // Using a raw pointer -- not recommended.
    Song* pSong = new Song(L"Nothing on You", L"Bruno Mars"); 

    // Use pSong...

    // Don't forget to delete!
    delete pSong;   
}


// 智能指针
void UseSmartPointer()
{
    // Declare a smart pointer on stack and pass it the raw pointer.
    unique_ptr<Song> song2(new Song(L"Nothing on You", L"Bruno Mars"));

    // Use song2...
    wstring s = song2->duration_;
    //...

} // song2 is deleted automatically here.
```

### 5.3 使用例子

演示了如何使用 C++ 标准库中的 `unique_ptr` 智能指针类型将指针封装到大型对象。

```c++
class LargeObject
{
public:
    void DoSomething(){}
};

void ProcessLargeObject(const LargeObject& lo){}
void SmartPointerDemo()
{    
    // 将智能指针声明为一个自动（局部）变量pLarge。 
    // 不要对智能指针本身使用 new 或 malloc 表达式。
    // 在类型参数中即<>内，指定封装指针的指向类型：<LargeObject>
    // 在智能指针构造函数中将原始指针传递至 new 对象：(new LargeObject())
    // Create the object and pass it to a smart pointer
    std::unique_ptr<LargeObject> pLarge(new LargeObject());

    // 智能指针使用重载的 -> 和 * 运算符访问对象
    //Call a method on the object
    pLarge->DoSomething();
    // Pass a reference to a method.
    ProcessLargeObject(*pLarge);

} //pLarge is deleted automatically when function block goes out of scope.

void SmartPointerDemo2()
{
    // Create the object and pass it to a smart pointer
    std::unique_ptr<LargeObject> pLarge(new LargeObject());

    //Call a method on the object
    pLarge->DoSomething();
	
   	// 允许智能指针删除对象
    // Free the memory before we exit function block.
    pLarge.reset();

    // Do some other work...
}
```

### 5.4 shared_ptr带来的资源泄漏

使用`std::shared_ptr`在下面场景可能会产生资源泄漏

1. 循环引用

   循环引用是 shared_ptr 产生资源泄漏的最常见原因。例如，以下代码中，`a` 和 `b` 互相引用，形成了循环引用：

   ```c++
   // 这种情况下，shared_ptr 的引用计数不会减少，内存就不会被释放。
   std::shared_ptr<A> a(new A);
   std::shared_ptr<B> b(new B);
   
   a->b = b;
   b->a = a;
   ```

2. 野指针

   野指针是指指向不存在内存的指针。当 shared_ptr 离开作用域时，它会自动释放所指向的内存。但是，如果在离开作用域之前，shared_ptr 被赋值为 nullptr，那么内存就不会被释放，这会导致野指针的出现。

   ```c++
   // 在这种情况下，a 所指向的内存不会被释放，这会导致野指针的出现。
   std::shared_ptr<A> a(new A);
   
   // ...
   
   a = nullptr;
   ```

### 5.5 weak_ptr阻止资源泄漏

```c++
//strong reference
class B;
class A
{
public:
    shared_ptr<class B> m_spB;
};


class B
{
public:
    shared_ptr<class A> m_spA;
};

//weak reference
class WeakB;
class WeakA
{
public:
    weak_ptr<class WeakB> m_wpB;
};


class WeakB
{
public:
    weak_ptr<class WeakA> m_wpA;
};


void test_loop_ref()
{
    weak_ptr<class A> wp1;

    {	
        // 使用shared_ptr进行循环引用
        auto pA = make_shared<class A>();
        auto pB = make_shared<class B>();

        pA->m_spB = pB;
        pB->m_spA = pA;

        wp1 = pA;    
    }// 此时会产生内存泄漏

    cout << "wp1 reference number: " << wp1.use_count() << "\n";

    weak_ptr<class WeakA> wp2;
    {	
        // 将weak_ptr对象绑定到shared_ptr所指向的对象
        auto pA = make_shared<class WeakA>();
        auto pB = make_shared<class WeakB>();

        pA->m_wpB = pB;
        pB->m_wpA = pA;

        wp2 = pA;
    }// 此时不会产生内存泄漏

    cout << "wp2 reference number: " << wp2.use_count() << "\n";
}

int main()
{    
    //std::weak_ptr 用来避免 std::shared_ptr 的循环引用
    test_loop_ref();

    return 0;
}

```

## 6. 指针常量，常量指针有什么区别？

| 特性             | 指针常量                      | 常量指针                      |
| :--------------- | :---------------------------- | :---------------------------- |
| 指针本身         | 常量                          | 可变                          |
| 指针所指向的对象 | 可变                          | 常量                          |
| 可以指向的对象   | 任意类型                      | 常量类型                      |
| 示例             | `int *const p = new int(10);` | `const int *p = new int(10);` |

## 7. 动态连接静态连接各自场景

C++中动态连接和静态连接是两种不同的库链接方式。

- 动态连接
  - 在程序运行时进行，根据程序的需要，动态加载库文件。
    - 优点是可以提高程序的灵活性，减小可执行文件的大小
    - 缺点是会增加程序的启动时间和运行时间
  - 第三方库通常是动态链接的
- 静态连接
  - 在程序编译时进行。
    - 优点是可以提高程序的启动时间和运行时间。
    - 缺点是会增加程序的大小。
  - 系统库通常是静态链接的

## 8. 线程和进程

| 特性   | 线程                                                         | 进程                             |
| :----- | :----------------------------------------------------------- | :------------------------------- |
| 资源   | 共享进程的所有资源                                           | 拥有独立的资源                   |
| 调度   | 由操作系统调度                                               | 由操作系统调度                   |
| 并发性 | python中同一时刻只能有一个线程在执行，c++可以同时多个线程运行 | 同一时刻可以有多个进程在执行     |
| 通信   | 通过共享内存进行通信                                         | 通过管道、消息队列等方式进行通信 |
| 创建   | 由 `pthread_create()` 函数创建                               | 由 `fork()` 函数创建             |
| 终止   | 由 `pthread_exit()` 函数终止                                 | 由 `exit()` 函数终止             |

## 9. 死锁是怎么产生的？如何解决死锁问题？

**死锁产生原因**：

死锁是指两个或多个进程或线程，由于互相等待对方释放资源而导致的一种永久阻塞现象

**如何解决**：

- 预防死锁：通过破坏死锁的产生条件来预防死锁。常用的预防死锁的方法包括：
  - **资源分配顺序策略**：规定资源的分配顺序，防止进程或线程在请求资源时形成循环等待关系。
  - **资源分配算法**：使用资源分配算法，防止进程或线程在请求资源时占有过多的资源。
  - **资源预留策略**：在进程或线程申请资源时，一次性预留所有所需资源，防止进程或线程在申请资源时形成循环等待关系。
- 检测死锁：在系统运行过程中，监控进程或线程的资源占有情况，发现死锁时采取措施解除死锁。
- 恢复死锁：当系统发生死锁时，采取措施解除死锁，恢复系统的正常运行。常用的恢复死锁的方法包括：
  - **资源强行剥夺**：将死锁进程或线程中占有的资源强行剥夺，使死锁进程或线程得以运行。
  - **进程或线程回退**：将死锁进程或线程回退到一个不存在死锁的状态，使死锁进程或线程得以运行。

## 10. C++为什么比python快，python为什么是伪多线程

- **C++比Python快的原因**

  1.  编译方式不同

     - C++是一种编译型语言，代码在编译时被转换成机器代码，这使得它在运行时执行速度非常快。

     - Python是一种解释型语言，代码在运行时由解释器逐行解释和执行，这导致了一定的性能损失。

  2.  内存管理：

     - C++允许直接控制内存，包括手动分配和释放内存，这可以更精细地管理内存，避免了垃圾收集的开销。

     - Python使用自动垃圾回收，这意味着在运行时需要额外的开销来跟踪和释放不再使用的内存。

  3. 多线程模型不同：

     - C++采用操作系统提供的多线程模型，可以实现真正的并行执行。
     - Python采用GIL（Global Interpreter Lock）机制，同一时刻只能有一个线程执行Python代码。GIL机制可以避免数据竞争，但会影响多线程程序的性能。

- **Python为什么是伪多线程？**

  - Python是解释型语言，采用GIL机制，同一时刻只能有一个线程执行Python代码。因此，Python中的多线程是伪多线程，并不是真正的并行执行。
  - 当多个线程执行Python代码时，只有一个线程可以获得GIL，其他线程只能等待。因此，多个线程不能同时执行Python代码，只能交替执行。

# 机器人相关

## 1.DH坐标4个参数的意义

DH坐标（Denavit-Hartenberg坐标系）是一种常用于描述机械臂关节之间相对位置和方向的方法。DH参数是描述这种坐标系的参数，通常有四个参数，分别是：

1. $\alpha$角：上一关节的Z轴绕着X轴旋转多少度来对齐当前关节的Z轴
2. a：上一关节的Z轴沿着X轴平移多少距离来对齐当前关节的Z轴
3. $\theta$：上一关节的X轴绕着Z轴旋转多少度来对齐当前关节的X轴
4. d：上一关节的X轴沿着Z轴平移多少距离来对齐当前关节的X轴

## 2.动力学方程如何构建

![image](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E8%BF%90%E5%8A%A8%E5%AD%A6%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

### 2.1 动力学的用处：

| 动力学类型 | 用途                                     | 已知量   | 求解量   | 数值积分 |
| :--------- | :--------------------------------------- | :------- | :------- | :------- |
| 正向动力学 | 数值仿真，半实物仿真                     | 驱动力矩 | 运动状态 | 包含     |
| 逆向动力学 | 前馈控制，反馈控制，重力补偿，零部件校核 | 运动状态 | 驱动状态 | 无       |

- 由于正向动力学计算得到的是加速度值，因而正向动力学需要有效且高效的数值积分器。

### 2.2 动力学方程

![image](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%A8%A1%E5%9E%8B.png)

- $\tau$：根据关节状态生成的关节驱动力矩
- $\mathcal{\theta}$：机械臂运动状态

### 2.3 动力学建模：牛顿欧拉

![image](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E5%9F%BA%E4%BA%8E%E7%89%9B%E9%A1%BF%E6%AC%A7%E6%8B%89%E7%9A%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%BB%BA%E6%A8%A1.png)

步骤：使用牛顿第二定律和欧拉方程，从最后一个关节向基座逐个计算每个关节的力和力矩。

1. **建立坐标系**，通常用DH坐标系来表示每个关节的位置和方向
2. **计算质心位置**，计算其质心的位置相对于其坐标系的位置
3. **计算质心速度和加速度**，使用牛顿的第二定律（F=ma）以及欧拉的方程来计算每个刚体的线性速度、角速度、线性加速度和角加速度。涉及到考虑外部力和扭矩以及惯性、重力和关节力的影响。
4. **递归迭代**，从末端刚体开始，递归地向基座刚体传递力和扭矩。
5. **得到关节力和扭矩：** 通过递归迭代的过程，可以计算出每个关节的力和扭矩。这些力和扭矩可以用于控制系统、规划轨迹以及进行动力学仿真。

### 2.4 动力学建模：拉格朗日方法

![image](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E5%9F%BA%E4%BA%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%BB%BA%E6%A8%A11.png)

![image](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E5%9F%BA%E4%BA%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E7%9A%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%BB%BA%E6%A8%A12.png)

![image](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E5%9F%BA%E4%BA%8E%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E7%9A%84%E5%8A%A8%E5%8A%9B%E5%AD%A6%E5%BB%BA%E6%A8%A13.png)

步骤：

1. **动能函数计算**：计算每根杆的动能之和。动能是角度和角速度的函数，写成通用矩阵式
2. **势能函数计算**：计算每根杆的势能之和。势能是角度的函数
3. **构建拉格朗日表达式**: L= 动能-势能
4. **求解动力学方程**：计算拉格朗日函数L对$\theta$和$\dot{\theta}$的偏导

### 2.5  动力学控制过程

![image](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E5%8A%A8%E5%8A%9B%E5%AD%A6%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B.png)

## 3.旋转矩阵有什么特殊的性质

1. 正交性：

   意味着其列向量（或行向量）是正交的，即彼此垂直，并且每个列向量（或行向量）都是单位向量。

   $AA^T=E$

2. 行列是为1：意味着它不引入体积伸缩

3. 逆矩阵即转置

4. 对加法不封闭

   多个旋转操作的合并，需要将他们乘起来

## 4.雅可比矩阵的伪逆是怎么求的

- 伪逆允许处理雅可比矩阵不是满秩的情况，这在实际问题中很常见，特别是在机器人控制和运动规划中。

- 使用奇异值分解（SVD）来求解伪逆

  1. 使用SVD分解雅可比矩阵J

     $J=U\Sigma V^T$

     - U,V：2个正交矩阵
  
     - $\Sigma$：对角矩阵，对角元素是J的奇异值
  
       > - 最大奇异值表示矩阵的最大线性变换的大小。
       > - 最小奇异值表示矩阵的最小线性变换的大小。

  2. 计算伪逆
  
     - 如果$\Sigma$的奇异值非常接近零（接近奇异），则将这些奇异值取倒数并置零，得到一个伪逆的$\Sigma^+$。
  
     - $J^+=V\Sigma^+U^T$

## 5. 数值优化

### 5.1 带不等式约束的非线性优化问题

- 问题：

  ```
  min f(x)
  s.t. g(x)=0
  	 h(x)<=0
  ```

  - 有什么方法可以解决上述问题

    - 拉格朗日乘子法(KKT)

    - 内点法

    - 罚函数法

    - 序列（逐步）二次规划法（SQP）

      利用 Newton 法求解 Lagrange 函数的稳定点，因此也被称为 Lagrange-Newton 法。

  - 挑一种写出计算流程的伪代码

# 控制相关

## 1. PID各部分意义

- p比例：能提高系统的动态响应速度，**迅速反映误差，从而减少误差**，但是不能消除误差，简单来说就是越大越快越小越慢但是可能会超调或者过慢有很多弊端，并且太大了会不稳定。
- i积分：一般就是**消除稳态误差**，只要系统存在误差积分作用就会不断积累，输出控制量来消除误差，如果偏差为零这时积分才停止，但是积分作用太强会使得超调量加大，甚至使系统出现震荡
- d微分：三个参数中的预备人员，一般不用，在反馈量噪声比较大时可能会使系统震荡。Kd增大可以加快系统响应，减小**超调量**，适用于迟滞系统或无阻尼系统。微分控制是一种提前控制，以偏差的变化率为基准进行控制。

## 2. LQR和MPC了解吗，2者的区别

### 2.1 LQR线性二次调节器

LQR (Linear-Quadratic Regulator) ,全称线性二次型调节器，可以根据系统模型设计一个最优状态反馈规律。

### 2.2 MPC模型预测控制

### 2.3 两者区别

从二者的研究对象、状态方程、工作时域、目标函数不同，这些方面去回答的

- 研究对象
  - LQR的研究对象是现代控制理论中以状态空间方程形式给出的线性系统
  - MPC的研究对象可以是线性系统，也可以是非线性系统
  - 在具体的优化求解时，均通过线性化方法将状态方程转化为线性方程进行求解

## 3. 有哪些线性化非线性系统的方法

- **泰勒级数展开**

  展开后忽略高阶项

- **小扰动**
  
  小扰动法是一种基于非线性系统在某个工作点附近的行为进行线性化的方法。它适用于具有小幅度变化的系统。
  
  比如李群李代数求导就用的这个方法
  
- **雅可比矩阵**

  雅可比矩阵描述了非线性函数的局部导数。使其在特定操作点附近近似为线性系统

## 4. 全状态反馈控制

1. 受力分析，并给出线性状态方程
2. 分析系统的可控性、平衡点、稳态误差是否为0？如果不为0，如何设计控制器让稳态误差为0
3. 用极点配置法设计全状态反馈增益，将闭环系统的极点配置到{p1,p2}；或采用LQR得到最优增益

## 5. 自动控制基本组成

![](https://img-blog.csdnimg.cn/8aa073cef78547a285c5387158734063.png)

## 6. 传感器和执行器

- 传感器：将物理信号转变成电信号的器件

  比如：相机，雷达，压力传感器

- 执行器：根据电信号执行一些机械动作

  比如：电机，电动调节阀

# 规划相关

## 1. 路径规划，轨迹规划有啥区别？

1. 路径规划（Path/Motion Planning），是在不考虑临时或者移动的障碍物的前提下，对车辆在空间上的变化的规划；
2.  轨迹规划（Trjectory Planning）一般轨迹规划包括横向规划和纵向规划，横向规划主要输出 trajectory 中的 x, y, s，纵向规划主要填充轨迹上各点期望速度 ds/dt。一般横纵解耦规划方案先规划横向，再规划纵向。

# 数学相关

## 1. 特征值分解/奇异值分解



## 2. 什么是零空间

- 阵将向量映射到另一个向量，零空间就是这个现行变换中所有被映射到0向量的输入向量集合
- 例子：Ax=0，就是求矩阵A的零空间，也就是输入向量x的集合



## 3. Ax=b 求解

- 解的个数：

  - 若rank(A) < rank(A|b)，则该线性方程为超定方程，无解。（但是可以有最小二乘解
  - 若rank(A) = rank(A|b)，则该线性方程组有解：在此基础上，若rank < A的列数（即变量的个数），则为欠定方程，有无穷解；若rank = A的列数，则为适定方程，具有唯一解。

- 求解方法

  - **矩阵分解法：**

    - LU分解法：通过分解矩阵A=LU来求解线性方程组的未知数。这种方法快速而稳定，但对矩阵的选取有要求，必须是对称正定矩阵。
    - QR分解法：通过分解矩阵A=QR来求解线性方程组的未知数。这种方法快速而稳定，不对矩阵的选取有要求，因此比LU分解法更常用。
    - SVD分解法：通过分解矩阵A=UΣVT来求解线性方程组的未知数。这种方法稳定性较好，适用于任意矩阵

  - **逆矩阵法：**

    在满足矩阵A可逆的情况下，可以通过求解A^(-1)b来求解线性方程组的未知数。

    但这种方法在实际应用中通常效率较低，特别是对于大型矩阵。

  - **迭代法：**

    - 雅可比迭代：通过迭代更新x的值，每次迭代使用前一个迭代的x来更新，直到满足收敛条件。
    - 高斯-赛德尔迭代：类似于雅可比迭代，但每次迭代使用最新的x值来更新，可以更快地收敛。

# 人工智能

## 1. tensor底层用c++是如何实现的

## 2. pytorch执行一个训练任务的流程

# 结构化面试

## 1. 自我介绍

各位考官好，我叫xx，本科毕业于上海理工大学能源与动力工程专业，在400人的学院中排名前10并获得了保研资格，后来放弃了保研选择来德国继续学业。现在是慕尼黑工业大学机电与机器人专业的一名研究生。

在德国读研期间，我在德国的高校、公司和研究所都做过不同方向的实习。其中最近的实习是在慕尼黑机器人与智能研究所做机械臂控制，去年9月到今年2月我在罗伯特博世公司做强化学习的自适应控制，此外我还为慕尼黑大学的质子物理实验室做过cad建模的工作。

现在我正在慕尼黑工业大学信息学院6所的的Knoll教授手下做硕士毕业论文，研究方向式同步定位与建图。

我预计于明年1月到3月之间毕业，毕业后希望立刻回国工作。

## 2. 最大的优缺点

- 优点：

  我是一个非常乐于学习的人，勤于总结做笔记也善于动手。在开源社区github上可以看到我学习机器人，人工智能，控制，数学等等所有的学习笔记。在我的朋友圈可以看到我自己组装的无人机、小车还有网球篮球滑雪等等动态。

  此外，我也是一个乐于分享自己学习成果的人。在学校和实习单位，大家问我问题我都会尽力解答。在网上开源社区github，我写的SLAM代码注释也已经得到了36个星。在球场和雪山上，我一直都是免费帮助新人小伙伴。

- 缺点：

  我觉得我最大的缺点是专精不够。机器人本身是一个交叉学科需要各方面的知识，而我又对他们都很感兴趣，所以虽然我机械设计、控制理论、人工智能都懂也都做过相对应的实习和项目，但可能还是没有专注于某一方面的同学那样精通某一领域。但我相信随着工作经验的累积，我会成为一个既有知识广度又有专业深度的工程师。

## 3. 最成功/失败的一件事

- 成功：

  由于高中没有努力，大一觉得有点遗憾就非常努力的奋斗了4年，绩点每年都是400人的学院前10，参加比赛拿了多次国奖，大四毕业时找工作、保研和出国都成功了。最后放弃了工作offer和保研资格，选择来德国读研，现在也快毕业了。

- 失败：

  我觉得没什么事可以被定义为失败的，任何事我们都可以从中学到不少。只有感觉遗憾的事，可能会觉得当时如果怎样做会有更好的结果。

## 4. 记忆最深刻的一件事

德语考试成功那一天

## 5. 合作

本科时候参加数学建模，3个人一个小组，我负责编写程序，一个同学负责做数值分析，一个同学负责大部分论文的撰写。在自己主要负责的任务外，我们3人还需要一起确定思路、翻阅论文、推导模型以及寻找相关的数据。最后通过努力，我们获得过校级1等奖，国家级3等奖的成绩。

## 6. 学习/工作中不满足于现状为此做出的努力

刚来德国的时候德语还没过，在斯图加特大学读语言班，但一年过去语言班结束了我的德语还没过，我当然不满足于德语考不过无法入学的现状。德语考试有4个部分，分别是阅读、口语、听力、写作，除了听力其他三个部分我一直都是过的，只有听力总是差1分。为此我两手准备，1手是每天背300个单词并听他们的发音确保我在听力中听到的能和我背的联系在一起。另一手是每天花2小时精听，听一句写一句。我在路上和烧饭的时候，我也会放着德语播客做个泛听。最后成功考出了德语。

