# 课程准备

## 1. 资源

根据[MIT6.S081](https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/)学习操作系统的笔记

- 课程网站：
  - [2023 fall](https://pdos.csail.mit.edu/6.828/2023/schedule.html)
  - [2022 fall](https://pdos.csail.mit.edu/6.828/2022/schedule.html), 学习的课
  - [2021 fall](https://pdos.csail.mit.edu/6.828/2021/schedule.html)

- 课程视频：https://www.youtube.com/watch?v=L6YqHxYHa7A，每节课的链接详见课程网站
- 课程视频翻译文档：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/
- 课程教材：https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf

XV6资源：

- [xv6 操作系统的深入讲解](https://space.bilibili.com/1040264970/)
- [xv6 中文文档](https://th0ar.gitbooks.io/xv6-chinese/content/index.html)
- [xv6 关键源码逐行解读 + 整体架构分析](https://www.youtube.com/playlist?list=PLbtzT1TYeoMhTPzyTZboW_j7TPAnjv9XB)

参考题解/博客

- [relaxcn](https://github.com/relaxcn/xv6-labs-2022-solutions)不错

- [doraemonzzz](http://doraemonzzz.com/tags/6-S081/)
- [Miigon's blog](https://blog.miigon.net/categories/mit6-s081/)不错
- [Zhou Fang](https://walkerzf.github.io/categories/6-S081/index.html)
- [Yichun's Blog](https://www.yichuny.page/tags/Operating System)
- [解析Ta](https://blog.csdn.net/u013577996/article/details/108679997)
- [PKUFlyingPig](https://github.com/PKUFlyingPig/MIT6.S081-2020fall)
- [星遥见](https://www.cnblogs.com/weijunji/tag/XV6/)

gdb:

- [教程1](https://linux.cn/article-14853-1.html)

## 2. 如何debug

- 确保理解了指针，是否能理解这个[exercise](https://pdos.csail.mit.edu/6.828/2019/lec/pointers.c)，值的记得的点：

  - If `int *p = (int*)100`, then `(int)p + 1` and `(int)(p + 1)` are different numbers: the first is `101` but the second is `104`. When adding an integer to a pointer, as in the second case, the integer is implicitly multiplied by the size of the object the pointer points to.

  - `p[i]` is defined to be the same as `*(p+i)`, referring to the i'th object in the memory pointed to by p. The above rule for addition helps this definition work when the objects are larger than one byte.

    `&p[i]` is the same as `(p+i)`, yielding the address of the i'th object in the memory pointed to by p.

  所以当看到指针时，要注意这是一个整数加法还是指针加法

- 当一部分可以工作了，即的git一下

- 使用print大法

- 使用gdb.(See [Using the GNU Debugger](https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf) for helpful GDB tips.)

  To use gdb with xv6, run `make make qemu-gdb` in one window, run `gdb` (or `riscv64-linux-gnu-gdb`) in another window, set a break point, followed by followed by 'c' (continue), and xv6 will run until it hits the breakpoint.

- 如果想了解 编译器生成的汇编代码 或者 特定内核地址的指令，可以查看kernel.asm（这是由Makefile生成的Assembly Language文件）

- **如果内核崩溃kernel panics**，比如内核崩溃/异常了，操作系统会停止工作并发出错误信息：

  为此可以做：

  - 在kernel.asm中查看内核崩溃时程序技术器(Program Counter)所指的位置

    > 程序计数器（Program Counter），也被称为指令指针（Instruction Pointer）。程序计数器是一种特殊的寄存器，它存储了当前正在执行的机器指令的内存地址。在执行程序时，处理器会不断从内存中读取指令，然后将程序计数器更新为下一条指令的地址，以便顺序执行指令。

  - 或者运行`addr2line -e kernel/kernel pc-value`直接找出给定程序计数器值所对应的源代码位置（函数名和行号）

    - `addr2line` 是一个用于符号解析的命令行工具，它可以根据给定的地址（或程序计数器值）和可执行文件（或共享库文件）来确定源代码中的对应位置
    - `-e kernel/kernel`：指定要解析的可执行文件，这里是内核的可执行文件
    - `pc-value`：代表程序计数器（指令指针）的值，即发生问题的机器代码地址。

- **如果内核崩溃kernel panics了，想回溯backtrace:**

  可以用gdb来回溯：

  - run `make qemu-gdb` in one window
  - run `gdb` (or `riscv64-linux-gnu-gdb`) in another window
  - set breakpoint in panic (`b panic`), followed by `c (continue). 
  - When the kernel hits the break point, type `bt` to get a backtrace.

- **如果内核死锁kernel hangs了**，比如死锁deadlock或者页错误page fault了

  > "Page fault"（页错误）是指在程序访问内存时，发现所请求的内存页面（页）当前不在主存中或者没有合法地映射到当前进程的虚拟地址空间中。

  可以使用geb找到哪里死锁了：

  - run `make qemu-gdb` in one window
  - run `gdb` (`riscv64-linux-gnu-gdb`) in another window , followed by `c` (continue). 
  - When the kernel appears to hang hit Ctrl-C in the `qemu-gdb` window and type `bt` to get a backtrace.

- **qemu提供了一个监视器monitor来查看虚拟系统的状态**

  > `qemu` 是一个通用的虚拟化工具，可以用于在一个操作系统上模拟运行另一个操作系统，或者在同一个操作系统上模拟运行不同的架构

  qemu的一些命令

  - `control-a c`：运行monitor，c指console操作台

  - `info mem`：打印页表(Page table)

    > `页表`是操作系统中的一种数据结构，用于管理虚拟内存和物理内存之间的映射关系。在计算机系统中，虚拟内存是指操作系统为每个进程提供的抽象内存空间，而物理内存是实际的硬件内存。页表帮助操作系统跟踪虚拟内存中的每个页面（页）与物理内存之间的对应关系。

  - `cpu`：指定看那个core的信息

## 3. 什么是Xv6和RISC-V

- Xv6：

  - 06年前：本课程的前身6.828最开始使用的是Unix V6（简称V6，基于PDP-11硬件体系和旧式C语言开发）作为教学用OS
  - 06年后：以V6为基础，使用ANSI C写一个新的在Intel x86多处理器计算机上的系统，也就是Xv6，来代替V6。
  - 19年后：使用**精简指令集RISC-V**替代了原有的复杂指令集x86来开发Xv6。

- RISC-V：

  - RISC-V和x86，ARM都是CPU的指令集架构，Xv6和Windows、Linux、MacOS等都是运用这些指令集架构来管理硬件的操作系统。

    >**指令集架构**（ISA，Instruction Set Architecture）是一种定义了计算机处理器如何执行指令的抽象层次。ISA 定义了处理器与软件之间的接口，决定了软件如何与硬件进行交互和执行。

  - ISA有2大类：

    - **复杂指令集计算机（CISC）架构：** CISC 架构设计的处理器支持一组复杂的指令，这些指令可以在一条指令中完成多个低级操作。因此，CISC 处理器的指令通常具有不同的长度和格式。典型的 CISC 架构包括 Intel 的 **x86** 和 Motorola 的 68k。
    - **精简指令集计算机（RISC）架构：** RISC 架构设计的处理器支持一组精简的指令，每个指令执行一个特定的操作。RISC 指令通常具有固定的长度和格式，简化了指令的解码和执行过程。这有助于提高处理器的执行速度。典型的 RISC 架构包括 **ARM** 和 MIPS。

## 安装：把xv6克隆到自己仓库上

1. 克隆原始仓库

   `git clone --mirror git://g.csail.mit.edu/xv6-labs-2022 project_xv6`

2. 在github上创建一个远程仓库，名字为`project_xv6`

3. 删除旧的origin（远程仓库）

   `git remote remove origin`

   - 通过`git remote -v`可以查看当前关联的远程仓库是哪一个

4. 更新新的origin

   `git remote add origin git@github.com:Fernweh-yang/project_xv6.git`

5. 上传分支

   - 上传所有分支：`git push --all origin`
   - 上传单个分支：`git push origin`

# Lab1: Unix utilities

实验目的：实现几个 unix 实用工具，熟悉 xv6 的开发环境以及系统调用。

## 1. 理论知识

[第一章：Operating system interfaces](https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf)

- OS的任务

  The job of an operating system is to share a computer among multiple programs and to provide a more useful set of services than the hardware alone supports.

  - 管理和抽象低维的硬件，从而某一进程(process)不用关心当前运行的硬件是什么
  - 在多个程序之间分享硬件，从而这些程序可以同时运行
  - 给程序们提供交互的方法，从而这些程序可以分享信息一起工作

- 系统内核和用户程序关系

  ![image-20230816233233405](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png)

  - `kernel`：一个给正在运行的程序们提供服务的特殊程序

  - `process`：进程，正在运行程序，分配的内存下存储着：

    - `instructions`：指令，让程序计算
    - `data`：用于计算的数据
    - `stack`：组织程序的过程调用(procedure calls)

  - **一个进程(process，红线)会交替的在user space和kernel space中执行**

    当一个process需要调用内核服务时，会调用OS Interface提供的某一个服务`system call`

    > 操作系统通过interface来给其他user program来提供服务

    这个`system call`会进入kernel，然后kernel执行服务并返回值。

  - cpu提供硬件保护机制来确保每一个在user space的进程只能访问它自己的内存空间(memory)

    相比user program，kernel有硬件特权用来访问硬件资源。
    
  - `shell`终端，是一个普通的user program不是内核，所以可以被任意的替代。
    
    `shell`的作用：从人这读取命令，并执行。

### 1.0 xv6提供的系统调用

![ ](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/xv6%20system%20calls.png)

### 1.1 Processes and memory

- 一些概念：

  - 一个**进程Process**：由**user-space memory** 以及 **per-process state private to the kernel** 所组成

    - 进程的用户空间内存(user-space memory)：指的是进程在执行时用于存储指令、数据和栈的部分。这是进程的用户态部分，用于执行用户编写的应用程序代码。
    - 内核私有的每个进程状态(per-process state private to the kernel)：指的是内核维护的关于每个进程的信息，如进程标识符（PID）、寄存器状态、打开文件表等等。这些状态数据是操作系统内核用来管理和控制进程的重要信息。

  - 系统的进程是 **time-sharing**的

    - 时间共享(time-sharing)：计算机会迅速地在不同的进程之间切换，每个进程都被分配一个小的时间片来执行。这种切换是如此迅速，以至于用户几乎感觉不到多个进程在同时运行。

    - 当一个进程不运行时，xv6系统会保存它对应的cpu寄存器，等到再次运行时再复原。

      > 寄存器是一种用于 **存储程序执行期间临时数据** 和 **处理指令、数据和地址** 的硬件组件。

  - 内核会给每个进程分配一个process identifier，也就是**pid**

    > PID通常是一个唯一的数字，用于在操作系统中标识和区分不同的进程。每个运行中的进程都会分配一个独特的PID。

- 在 xv6 操作系统中，大多数的用户空间内存(user-space memory)分配是隐式进行的。

  > user-space memory: 的是进程在执行时，用于存储用户程序、数据和栈等的内存区域。

  - `fork`： 当一个新的子进程被创建（通过 fork 函数），操作系统会为子进程分配足够的内存，用于存储子进程的副本数据，这些数据包括父进程在创建子进程时的内存内容（例如变量、数据等）。这样，子进程就可以继承父进程的状态，并且可以在之后的执行中对这些数据进行操作。

    > "fork" 是创建新进程的一种方式，它通过复制父进程的状态来生成一个子进程，子进程独立于父进程运行。这种机制在实现多任务和并发处理时非常有用，允许程序同时执行多个任务。

  - `exec`：当一个进程要执行一个新的可执行文件（通过 exec 函数），操作系统会为该进程分配足够的内存，以容纳要执行的可执行文件的代码、数据和其他需要的资源。这样，该进程就可以加载并执行新的可执行文件。

  - `sbrk(n)`：如果一个进程在运行时run-time需要更多的内存，可以用`sbrk(n)`来多分配n bytes的内存。

    sbrk()会返回新内存的地址
  
- 一些疑惑：

  - **启动一个新的程序(进程process)需要运行什么步骤？**

    - 首先，通过调用 `fork()` 系统调用，创建一个新的进程，该进程是调用进程的一个副本，包括代码、数据和打开的文件描述符等。

    - 接下来，在新创建的子进程中，通过调用 `exec()` 系统调用来加载一个新的程序到子进程的内存空间，并执行这个程序。

      `exec()` 系统调用会替换子进程的内存映像为新加载的程序，但是保留了其他进程属性（如PID和打开的文件描述符）。

  - **那为什么要将exec()和fork()分开来，不能一个命令解决吗？**

    这得联系1.2的I/O来看。

    - fork干的事：当我们在主 shell 中执行一个命令时，Shell 会创建一个子进程来执行该命令。子进程继承了主 shell 的 I/O 设置。即
    - I/O重定向：在fork后exec前，父进程通过系统调用来改变子进程的文件描述符。这不会影响主 shell 的 I/O 设置，从而保持主 shell 的输入输出行为不变。
    - exec干的事：子进程的内存空间将会被新程序的代码和数据替换，但是文件描述符等其他信息会被保留下来，包括重定向后的文件描述符。
    - 所以分开写的好处有：
      1. 使得 shell 能够控制子进程的输入输出，执行各种形式的重定向，以及管道等操作，而不影响主 shell 的运行。
      2. 允许操作系统和应用程序在执行过程中插入更多的步骤。即不止做I/O重定向更可以做些额外检查之类的工作

    > Shell" 和 "终端"（terminal）是相关但不同的概念。
    >
    > Shell 是一个命令行解释器，它是用户与操作系统之间的接口。它接受用户输入的命令并将其解释为操作系统可以执行的指令。
    >
    > Terminal 是用户与计算机交互的设备或应用程序。它通常提供一个命令行界面，用户可以在其中输入命令并查看输出。
    >
    > 所以Shell 是执行命令的解释器，而终端是用户与 Shell 进行交互的界面。

  - **fork了程序如何判断当前是父进程还是子进程？**

    fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：

    1. 在父进程中，fork返回新创建子进程的进程ID；

    2. 在子进程中，fork返回0；

    3. 如果出现错误，fork返回一个负值；

       fork出错可能有两种原因：

       - 当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
       - 系统内存不足，这时errno的值被设置为ENOMEM。

    参考一个例子：

    ```c++
    /*fork前：此时仅有一个进程*/
    pid=fork();
    /*fork后：此时已经有两个进程在同时运行，两个进程的代码部分完全相同
      		 所以下面的代码2个进程都在同时进行。
    */
    if(pid<0)
    printf("error in fork!");
    else if(pid==0)		// 在子进程中，fork返回0；
    printf("I am the child process, my process ID is %d/n",getpid());
    else				// 在父进程中，fork返回新创建的子进程pid
    {
        wait(0);		// 保证先执行子进程，再执行父进程
        printf("I am the parent process, my process ID is %d/n",getpid());
    }
    
    /*
    最后输出结果为：
    I am the child process, my process ID is 1992
    I am the parent process, my process ID is 1991
    */
    ```


### 1.2 I/O and File descriptors

- 一些概念

  - **文件描述符(File Descriptor)**：是一个非负整数。用于唯一地标识一个内核管理的**已经打开的**文件/资源。

    > 文件描述符不是在创建文件时就分配的，而是在进程通过系统调用打开文件时才会被分配。
    >
    > 每个文件描述符都与一个特定的已打开文件关联，进程可以使用该文件描述符来执行读取、写入、关闭等操作。

    文件描述符会将文件(files)、管道(pipes)和设备(devices) 统一的抽象为字节流，使得在编程时可以更方便地处理它们

    > 文件：适用于长期存储和随机访问数据
    >
    > 管道：用于进程间通信
    >
    > 设备：用于与硬件设备进行交互。

    

  - **标准的文件描述符有3个：**
  
    > 描述符 **0**：标准输入（stdin），用于接收输入
    >
    > 描述符 **1**：标准输出（stdout），用于输出普通信息
    >
    > 描述符 **2**：标准错误（stderr），用于输出错误信息
  
    shell会将这三个文件描述符扩展到 **输入/输出重定向(I/O Redirection)** 和 **管道(Pipelines)**
  
    > **I/O Redirection**：是一种在执行命令时，将标准输入、标准输出和标准错误流定向到其他文件或设备的技术。例如，通过使用输入重定向，您可以从一个文件而不是标准输入读取数据。
    >
    > **Pipelines**：管道是一种将一个命令的输出作为另一个命令的输入的方式。通过使用管道，您可以将多个命令连接在一起，使其中一个命令的输出成为下一个命令的输入。
  
  - **偏移量offset**：
  
    - 当进程打开一个文件并获得一个文件描述符时，该文件描述符与文件中的一个特定位置（偏移量）相关联。
    - 偏移量表示了在文件中的一个位置，通常以字节为单位。刚开始时，偏移量可能是文件的开头（偏移量为0）。
    - 通过文件描述符的偏移量，`read` 操作能够从文件中的特定位置读取数据，并在读取后更新偏移量，使得下次读取操作从新位置开始。
    - 类似于`read`操作，`write` 操作从文件的当前偏移量开始写入数据，并将偏移量在写入后按写入的字节数进行移动。
  
- 一些疑惑

  - **如果一个进程同时打开了4个文件，这4个文件的文件描述符会是什么？**

    当一个进程打开了4个文件，操作系统会为每个打开的文件分配一个文件描述符。文件描述符通常是依次递增的整数值，从3开始分配，因为0、1、2 分别用于标准输入、标准输出和标准错误。

    假设进程按照以下顺序打开了4个文件：

    1. 第一个文件 → 文件描述符为 3
    2. 第二个文件 → 文件描述符为 4
    3. 第三个文件 → 文件描述符为 5
    4. 第四个文件 → 文件描述符为 6

  - **那这些文件的地址保存到哪里去了？**

    在操作系统中，文件描述符并不是直接保存文件的地址，而是用于标识打开的文件或资源的唯一标识符。

    文件的实际地址和数据是由内核管理的，不会直接保存在文件描述符中。文件描述符只是一个引用，它指向内核中相应的文件表项或其他相关数据结构。

  - **不同进程对同一个标准文件描述符的offset是共享的吗？**

    - 不同进程对同一个文件的文件描述符的 offset 是相互独立的

      也就是说进程1对文件A从第7个字节开始输入1个字节后，进程1的offset为8。而此时进程2对文件A的offset可能是第3个字节。

    - 但！！`fork()` 出来的父子进程会共享同一个文件的文件描述符和文件偏移量（offset）

      ```c++
      // 下面先子进程对文件描述符1输出hello,父进程再在子进程移动后的offset基础上对文件描述符1输出world。
      // 最终输出 hello world。
      if(fork() == 0){ 	// 子进程,fork返回0
          write(1, "hello ", 6); 
          exit(0); 
      }else{ 				// 主进程,fork返回所创建子进程的id
          wait(0); 
          write(1, "world\n", 6);
      }
      
      // dup()可以复制一个已经存在的文件描述符
      // 下面的代码输出也是 hello world
      fd = dup(1); 	// fd指向和1相同指向的I/O对象
      write(1, "hello ", 6); 
      write(fd, "world\n", 6);
      ```

      

### 1.3 Pipes

- 一些概念

  - **pipe**: 管道是一个内核中创建的小型缓冲区(buffer), 一对文件描述符(file descriptor)的形式暴露给进程，其中一个用于读取，另一个用于写入。

    管道给进程们提供了1个沟通的方式

### 1.4 File system

- 一些概念

  - **file system**: 有很多不同类比,比如

    - 数据文件（Data Files）:数据文件是一种存储数据的基本单位。它们包含未经解释的字节数组，这意味着文件系统不会对数据进行特定的解释或处理，而只是将字节数组存储在文件中。
    - 目录（Directories）:目录是一种特殊类型的文件，它包含了对其他数据文件和目录的命名引用。目录可以被看作是文件系统中的文件索引，它将文件名与实际数据文件或其他目录的关联建立起来。
      - 目录会构成一个树(tree), 从一个叫`root`的特殊目录开始,
      - 一个地址`path`: 如/home/Desktop, 就是**root目录**: / 下的Desktop目录

    - 设备(Device): 设备文件用于表示硬件设备，如磁盘驱动器、打印机等。通过访问设备文件，应用程序可以与硬件设备进行交互，实现输入输出操作。

  - **文件系统是如何组织和管理文件**

    - 每个文件有一个或多个文件名，文件名通过硬链接(links)与实际文件的索引节点(inode)关联，所以它们实际上引用了同一个文件
    - 每个文件在文件系统中都有一个唯一的inode，inode 包含文件的元数据(metadata)
    - 目录作用之一：维护文件名到inode的映射。目录中的每个条目都包括一个文件名和对应文件的inode引用。

    > **inode**（index node，索引节点）是文件系统中的一个重要概念，它是用来存储和管理文件的元数据和信息的数据结构。每个文件系统都会在其内部使用inode来追踪文件的属性和位置，从而支持文件的访问、管理和存储。
    >
    > **metadata元数据**：文件系统使用元数据来描述文件的属性，如文件类型、权限、时间戳、长度等。这些信息存储在inode中，使得文件系统可以在文件访问和管理时了解文件的特性。

### 1.5 Real world

- 现代的unix 系统都遵守**POSIX（Portable Operating System Interface，可移植操作系统接口）**标准

  > POSIX：是一组操作系统接口标准，旨在促进不同操作系统之间的兼容性和可移植性。它的目标是使不同的操作系统在应用程序级别上具有一致的接口，以便开发人员可以在不同的系统上编写可移植的应用程序。

  xv6由于缺少很多系统调用(system calls)所以不符合posix




## 2. 实验

根据[实验文档](https://pdos.csail.mit.edu/6.828/2022/labs/util.html)完成

### 2.1 boot xv6

- 编译和运行xv6进入qemu:`make qemu`
- 查看qemu中正在运行的进程信息: 同时按ctrl和p
- 退出qemu：先同时按ctil和a，再按x

- 评分验证实验结果：`make grade`

### 2.2 sleep

- **问题：**

  Implement the UNIX program `sleep` for xv6; your `sleep` should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file `user/sleep.c`.

- **在user文件夹中创建sleep.c**

  ```c
  #include "kernel/types.h"
  #include "kernel/stat.h"
  #include "user/user.h"  // 系统调用和ulib.c中定义的函数
  
  // argc: 表示命令行参数的数量，包括程序本身。 比如./sleep arg1 arg2 此时argc=3
  // argv: 一个指向指针数组的指针，每个指针指向一个字符串，代表一个命令行参数。
  // argv[0] 指向字符串./sleep，argv[1]指向字符串arg1,argv[2]指向字符串arg2
  int main(int argc, char*argv[]){
      if(argc <= 1){
          // fprintf():C语言中的一个标准库函数，用于格式化输出数据到文件流。
          fprintf(2,"usage: sleep [seconds]\n");  // 参数 2 表示输出到标准错误流（stderr）
          exit(1);    // 表示程序异常终止
      }
      int tick = atoi(argv[1]);  // 使用的user/ulib.c的atoi()将字符串转为数字
      sleep(tick);    // 睡眠tick/10秒
      exit(0);        // 表示程序正常退出
  }
  ```

- **在Makefile中添加sleep文件路径**

  ```makefile
  # UPROGS 是一个变量，其值是一系列的文件路径。方便我们以后添加更多的用户程序
  # 这种用法通常用于定义一组需要编译或处理的用户程序。
  # 在 Makefile 的其他部分，可以使用 $(UPROGS) 来引用这些文件路径
  UPROGS=\
  	$U/_cat\
  	$U/_echo\
  	...
  	$U/_zombie\
  	$U/_sleep\
  ```

- **测试:**

  ```shell
  ./grade-lab-util sleep
  # 或者
  make GRADEFLAGS=sleep grade
  ```

- **使用**：

  ```shell
  make qemu 	# 编译并打开系统后
  sleep 10	# 睡眠1s
  ```

### 2.3 pingpong

- **问题：**

  Write a program that uses UNIX system calls to ''ping-pong'' a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print "<pid>: received ping", where <pid> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print "<pid>: received pong", and exit. Your solution should be in the file `user/pingpong.c`.

- **创建user/pingpong.c**

  ```c
  #include "kernel/types.h"
  #include "kernel/stat.h"
  #include "user/user.h"  // 系统调用和ulib.c中定义的函数
  
  int main(int argc, char* artv[]){
      int p2c[2],c2p[2];   // 创建2个用于存储管道的文件描述符，分别用于父进程到子进程和子进程到父进程
      // 通过系统调用pipe()创建管道，read/write file descriptor分别存在p[0]/p[1]
      pipe(p2c);  // 父进程 -> 子进程
      pipe(c2p);  // 子进程 -> 父进程
  
      if(fork()!=0){              // 在父进程中，fork返回新创建的子进程pid
          write(p2c[1],"x",1);    // 把x通过管道发送给子进程
          char buf;
          read(c2p[0],&buf,1);    // 从子进程的通道读取字符,存到buf中
          printf("%d: received pong\n",getpid());
          // printf("parent buf:%c \n",buf);
      }else{                      // 在子进程中，fork返回0；
          char buf;
          read(p2c[0],&buf,1);    // 从父进程的通道读取字符,存到buf中
          printf("%d: received ping\n",getpid());
          // printf("child buf:%c \n",buf);
          write(c2p[1],&buf,1);    // 把x通过管道发送给父进程
      }
      exit(0);
  }
  ```

- **在Makefile中添加pingpong文件路径**

  ```makefile
  UPROGS=\
  	...
  	$U/_pingpong\
  ```

- **测试**

  ```shell
  ./grade-lab-util pingpong
  # 或者
  make GRADEFLAGS=pingpong grade
  ```

- **运行**

  ```shell
  make qemu 	# 编译并打开系统后
  pingpong
  ```



### 2.4 primes

- **问题：**

  Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down [算法原理](http://swtch.com/~rsc/thread/) and the surrounding text explain how to do it. Your solution should be in the file `user/primes.c`.

  > **Concurrent programming**： 一种编程范式，用于处理并发执行的计算机程序。
  >
  > **Prime sieve**：（素数筛选算法）是一种用于找出一定范围内所有素数的算法。该算法使用递增的自然数序列，首先标记出最小的素数（通常是2），然后将其他能被这个素数整除的数标记为合数，然后继续下一个未被标记的数作为新的素数，以此类推，直到达到指定的范围。

- **原理：**

  ``` 
  主进程：生成 n ∈ [2,35] -> 子进程1：筛掉所有 2 的倍数 -> 子进程2：筛掉所有 3 的倍数 -> 子进程3：筛掉所有 5 的倍数 -> .....
  ```

  每一个 stage 以当前数集中最小的数字作为素数输出（每个 stage 中数集中最小的数一定是一个素数，因为它没有被任何比它小的数筛掉），并筛掉输入中该素数的所有倍数（必然不是素数），然后将剩下的数传递给下一 stage。最后会形成一条子进程链，而由于每一个进程都调用了 `wait(0);` 等待其子进程，所以会在最末端也就是最后一个 stage 完成的时候，沿着链条向上依次退出各个进程。

- **创建user/primes.c**

  - 注意xv6系统的file descriptor是有限的，一共16个(见 `defs.h` 中的 `NOFILE` 和 `proc.h` 中的 `struct file *ofile[NOFILE]; // Open files`)

    而fork 会将父进程的所有文件描述符都复制到子进程里，所以每个进程不需要的fd要及时关掉，否则资源会不够。

  - 解决方法：

    针对一个管道会占用2个文件描述符

    1. 关闭管道的两个方向中不需要用到的方向的文件描述符（在具体进程中将管道变成只读/只写）
    2. 子进程创建后，关闭父进程与祖父进程之间的文件描述符（因为子进程并不需要用到之前 stage 的管道）

  ```c
  #include "kernel/types.h"
  #include "kernel/stat.h"
  #include "user/user.h"  // 系统调用和ulib.c中定义的函数
  
  // 一次 sieve 调用是一个筛子阶段，会从 old_pipe 获取并输出一个素数 pime，筛除 prime 的所有倍数
  // 同时创建下一 stage 的进程以及相应输入管道 new_pipe，然后将剩下的数传到下一 stage 处理
  void sieve(int old_pipe[2]){
      int prime;
      read(old_pipe[0], &prime, sizeof(prime));   // 一个stage(子进程)读到的第一个数，必然是素数
      if(prime == 36) exit(0);                    // 如果读到的数是36，则代表所有数字处理完毕，退出程序
      printf("prime %d\n",prime);
  
      int new_pipe[2];
      pipe(new_pipe);                             // 创建用于输出到下一 stage 的进程的输出管道 new_pipe
  
      if(fork()!=0){  
          // 父进程（当前stage）
          close(new_pipe[0]);     // 父进程(当前stage)只需要将筛选完的数字write写入子进程，不需要从子进程读取read，所以关闭read
          int num;
          while(read(old_pipe[0], &num, 1) && num!=36){   // 从当前进程的父进程那读取数字
              if(num%prime!=0){   // 筛掉能被该进程筛掉的数字
                  write(new_pipe[1], &num, sizeof(num));  // 将剩余的数字写到子进程(新的stage)
              }
          }
          num = 36;               // 补写最后的 36，标示输入完成。
          write(new_pipe[1], &num, sizeof(num));
          wait(0);                // 等待该进程的子进程完成，也就是下一 stage
          exit(0);
      }else{
          // 子进程（下一个stage）
          close(new_pipe[1]);     // 子进程(新stage)只需要从父进程read它筛选完的数字,没有写东西给父进程需求，所以关闭write
          close(old_pipe[0]);     // 这里的 old_pipe 在上一个stage中write已经关了，现在关掉read
          sieve(new_pipe);        // 子进程以父进程的输出管道作为输入，开始进行下一个 stage 的处理。
      }
  }
  
  int main(int argc, char* artv[]){
      int input_pipe[2];
      pipe(input_pipe);           // 输入管道，输入2-35之间的所有整数
  
      if(fork()!=0){  
          // 父进程
          close(input_pipe[0]);   // 父进程只需要write输入管道，而不需要读，关掉子进程的管道read文件描述符
          for(int i=2;i<=36;i++){ // 将数字依次写入stage（传给子进程）
              write(input_pipe[1], &i, sizeof(i));
          }
      }else{                      
          // 第一个stage的子进程
          close(input_pipe[1]);   // 子进程只需要read输入管道，而不需要写，关掉子进程的管道write文件描述符
          sieve(input_pipe);
          exit(0);
      }
  
      // 等待第一个stage完成。注意：这里无法等待子进程的子进程，只能等待直接子进程，无法等待间接子进程。
      // 在 sieve() 中会为每个 stage 再各自执行 wait(0)，形成等待链。
      wait(0);    
      exit(0);
  }
  ```

- **在Makefile中添加primes文件路径**

  ```makefile
  UPROGS=\
  	...
  	$U/_primes\
  ```

- **测试**

  ```shell
  ./grade-lab-util primes
  # 或者
  make GRADEFLAGS=primes grade
  ```

- **运行**

  ```shell
  make qemu 	# 编译并打开系统后
  primes
  ```



### 2.5 find

- **问题**

  Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file `user/find.c`.

- **创建user/find.c**

  ```c
  #include "kernel/types.h"
  #include "kernel/stat.h"
  #include "user/user.h"  // 系统调用和ulib.c中定义的函数
  #include "kernel/fs.h"  // 文件状态相关
  
  void find(char *path, char *filename){
      char buf[512], *p;  
      struct dirent de;   // 文件信息包括inode号和文件名
      struct stat st;   // 用于描述文件的状态信息
  
      // ! ******************** 打开传进来的path,注意!!!这个path可能是目录也可能是普通文件 ********************
      // open(,0)：0代表读，1代表写.如果打开成功返回一个file descriptor:fd
      int fd;
      if((fd=open(path,0))<0){    // 不论是普通文件、目录、设备文件，都可以被打开
          fprintf(2,"can't open the path %s\n",path);
          return;
      }
      // 获得与文件描述符fd关联的文件信息，并保存到结构体st中
      // st可以保存所有类型的文件信息(设备,文件,目录), 因此下面靠st来做递归中的判断
      if(fstat(fd,&st)<0){
          fprintf(2,"can't get the info of file %s \n",path);
          close(fd);
          return;
      }
  
      // ! ******************** 判断这个path是目录还是我们想找的文件 ********************
      // 通过递归,依次获得fd(当前目录)下的文件保存在st中,判断他们是filename(找的目标)还是目录
      switch (st.type){
      case T_DEVICE:
      case T_FILE:
          // ******************** 如果是文件类型, 判断是否是我们想要找的文件 ********************
          // 先path+strlen(path):指针指向path最后元素的后一位
          // 再往前strlen(filename)位,指向文件名的起始位. 
          // 最后判断这2个指针指向的字符串是否相同
  		if(strcmp(path+strlen(path)-strlen(filename), filename) == 0) {
  			printf("%s\n", path);
  		}
          break;
      case T_DIR:
          // ******************** 如果是目录类型, 遍历该目录下的每一个文件 ********************
          // 判断路径会不会太长
          if(strlen(path)+1+DIRSIZ+1 > sizeof(buf)){
              printf("path too long \n");
              break;
          }
  
          // 创建当前目录的完整路径并加上'/', 以便后面遍历所有文件时直接把文件名加在后面,就是每个文件的完整路径了
          strcpy(buf, path);
          p = buf+strlen(buf);// 将p指针移动到字符数组buf(path)最后一个元素后的哪一个空字符处.
          *p++ = '/';         // 将p所指的空字符赋值'/',相当于在path后加一个"/",然后p再后移一位.
  
          // 从文件描述符 fd 所指向的目录文件path中读取一个文件条目的信息，包括inode号和文件名，然后将这些信息存储到 de 结构体中。
          while(read(fd, &de,sizeof(de))==sizeof(de)){
              if(de.inum == 0)  // 正常情况下inode不会为0,如果遇到就跳过,可能是文件受损
                  continue;
  
              // ******************** 获得该目录下的每一个文件/目录/设备的完整路径 ********************
              // 将目录下每个文件的名字加在目录后,这之后p指向的字符串就是每个文件/目录的完整地址
              memmove(p, de.name, DIRSIZ);  // 从de.name复制DIRSIZ个字节数据到p所指向的内存位置
              p[DIRSIZ] = 0;                // 运用指针偏移,直接在末尾加上终止符
  
              // 指针p指向的是buf,所以现在buf的字符串存的是: 每个文件/目录的完整地址
              if(stat(buf, &st) == -1){       // 尝试获取指定路径 buf 的文件信息并将其存储在结构体 st 中
                  printf("find: cannot stat %s\n", buf);
                  continue;
              }
  
              // ******************** 将这个文件的路径送入递归 ********************
              // 不要进入 `.` 和 `..`
              // buf+strlen(buf)-2 将指针移动到路径字符串的倒数第二个字符处
              // 然后使用 strcmp 函数来比较这个子字符串与 "/." 是否相等。 /..同理
  			if(strcmp(buf+strlen(buf)-2, "/.") != 0 && strcmp(buf+strlen(buf)-3, "/..") != 0) {
  				find(buf, filename); // 递归查找
  			}
          }
          break;
      }
      close(fd); // 关闭每一个递归下新开的文件描述符
  }
  
  int main(int argc, char* argv[]){
  
      if(argc < 3){
          fprintf(2,"usage: find [path] [filename] \n");
          exit(0);
      }
      find(argv[1],argv[2]);  // find path filename
      exit(0);
  }
  ```

- **在Makefile中添加find文件路径**

  ```makefile
  UPROGS=\
  	...
  	$U/_find\
  ```

- **测试**

  ```shell
  ./grade-lab-util find
  # 或者
  make GRADEFLAGS=find grade
  ```

- **运行**

  ```shell
  $ make qemu 	# 编译并打开系统后
  $ echo > b
  $ mkdir a
  $ echo > a/b
  $ mkdir a/aa
  $ echo > a/aa/b
  $ find . b
  ```

### 2.6 xargs

- **问题:**

  Write a simple version of the UNIX xargs program: its arguments describe a command to run, it reads lines from the standard input, and it runs the command for each line, appending the line to the command's arguments. Your solution should be in the file `user/xargs.c`.

  编写 xargs 工具，从标准输入读入数据，将每一行当作参数，加入到传给 xargs 的程序名和参数后面作为额外参数，然后执行。

  > xargs（英文全拼： eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。
  >
  > xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。
  >
  > xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。

  xargs的基本用法:`command1 | xargs [options] [command2]`

  - xargs根据options会处理command1的输出
  - 这个输出会作为参数传递给command2

- **创建user/xargs.c**

  ```c++
  // xargs.c
  #include "kernel/types.h"
  #include "kernel/stat.h"
  #include "user/user.h"
  #include "kernel/fs.h"
  
  // 带参数列表，执行某个程序
  void run(char *program, char **args) {
  	if(fork() == 0) { // 在子进程中，fork返回0；
  		exec(program, args);	// 将参数args的指针传递给程序program，并执行
  		exit(0);				// 终止当前进程，0表示程序正常终止
  	}
  	return; 		  // 父进程就直接返回
  }
  
  int main(int argc, char *argv[]){
  	char buf[2048]; 				// 读入时使用的内存池
  	char *p = buf, *last_p = buf; 	// 当前参数的结束、开始指针
  	// 定义了一个长度为 128 的字符指针数组。用于保存argv 传进来的参数和 stdin 读入的参数
  	char *argsbuf[128]; 		
  	// 指向指针的指针，初始化为argsbuf数组第一个元素的指针。
  	char **args = argsbuf; 	
  
  	// ! 考虑一个命令 $ echo hello world | xargs echo bye
  	// ********* 开始从命令行中读取参数: echo bye *********
  	// 将所有的命令行参数的指针，保存到指针数组argsbuf中去
  	for(int i=1;i<argc;i++) {
  		*args = argv[i];	// 将参数argv[i]的指针复制给指针args，即给argsbuf数组的某一元素
  		args++;				// 指针指向argsbuf数组的下一个元素
  	}
  
  	// ********* 开始从标准输入stdin中读取参数: echo hello world命令的结果 *********
  	// 此时argsbuf存了echo和bye2个字符串，args指向bye后面一个字符串的指针
  	char **pa = args; // pa用于指向每一个从stdin读取到的参数的开始位置
  	// 系统调用read，从标准输入0读取数据，将数据存储到p指针所指向的内存位置，每次读取1个字节的数据
  	while(read(0, p, 1) != 0) {
  		// 读入一个参数完成（以空格分隔，如 `echo hello world`，则 hello 和 world 各为一个参数）
  		if(*p == ' ' || *p == '\n') {
  			// 将空格替换为 \0 分割开各个参数，这样可以直接使用内存池中的字符串作为参数字符串，而不用额外开辟空间
  			// \0是终止符，标志字符串的结束
  			*p = '\0';
  			// 将读取完的参数hello存储到argsbuf数组中去
  			// 此时p指向了hello\0的\0，last_p还指向开头的字符h
  			*(pa++) = last_p;
  			// 将last_p指向下一个参数,world的开头字符w
  			last_p = p+1;
  
  			// 如果遇到了换行符号
  			if(*p == '\n') {
  				*pa = 0; // 参数列表末尾用 null 标识列表结束
  				run(argv[1], argsbuf); // 执行最后一行指令，这里是echo bye hello world
  				pa = args; // 重置读入参数指针，准备读入下一行
  			}
  		}
  		p++;
  	}
  	// 如果最后一行不是空行，即最后没有遇到换行符\n
  	// 此时args还是指向bye后面一个字符串的位置,即hello
  	// 此时pa指向world后面一个字符串的位置
  	if(pa != args) { 
  		*p = '\0';
  		*(pa++) = last_p;
  		*pa = 0; // 参数列表末尾用 null 标识列表结束
  		run(argv[1], argsbuf);	// 子进程：执行最后一行指令，这里是echo bye hello world
  	}
  	while(wait(0) != -1) {}; // 循环等待所有子进程完成，每一次 wait(0) 等待一个
  	exit(0);
  }
  ```

  

- **在Makefile中添加xargs文件路径**

  ```makefile
  UPROGS=\
  	...
  	$U/_xargs\
  ```
- **测试**
  
  ```shell
  ./grade-lab-util xargs
  # 或者
  make GRADEFLAGS=xargs grade
  ```
- **运行**

  ```shell
  # xargs 一般是和管道一起使用。
  $ make qemu 	# 编译并打开系统后
  
  $ echo hello world | xargs echo bye
  bye hello world
  
  # will run "grep hello" on each file named b in the directories below ".".
  $ find . b | xargs grep hello 
  ```



# Lab2: System calls

## 0. 一些基本概念

- 本章介绍一个**操作系统是如何被组织organized**的，以实现3个要求

  1. multiplexing：即使执行的进程数多于cpu数，操作系统也保证每个进程都有被执行的机会
  2. isolation：一个进程由于Bug挂了，不会影响到其他和这个进程没有联系的进程
  3. interaction：进程之间可以互相通信

- **monolithic kernel** 是操作系统内核的一种设计，它将操作系统的所有功能都包含在一个单一的模块中。

  Windows、Linux、Unix 和 Android都用的这种类型。macOS用的就是hybrid kernel

  - 优点：
    - 简单易懂，开发和维护成本较低。
    - 效率高，因为所有的功能都在同一内核空间中运行，不需要额外的系统调用。
    - 兼容性好，因为它可以支持各种硬件和软件。
  - 缺点：
    - 安全性较差，因为一个漏洞可能会导致整个内核被破坏。
    - 可扩展性较差，因为增加新的功能需要修改内核代码，这可能会导致兼容性问题。
  - 其他类型：
    - microkernel：安全、可扩展性好 但 复杂、效率较低、兼容性差
    - hybrid kernel：兼顾 monolithic kernel 和 microkernel 的优点	但 设计复杂。 

- **Xv6操作系统**由"LP64"C写成，并运行在RISC-V microprocessor上

  - RISC-V： 是一个遵循了RISC 指令集的开源指令集架构，是一个64位的CPU 的“基础”，但它本身不是 CPU。
  - “LP64”C：意思是在C编程中long和pointer是64位的，但int是32位的

- **指令集架构**（Instruction Set Architecture，ISA）

  - 定义了 CPU 可以执行的操作。它是 CPU 和软件之间的接口，软件必须遵循指令集架构才能在 CPU 上运行。

  - 指令集架构可以分为两种类型：

    - CISC（复杂指令集计算）：CISC 指令集包含了大量复杂的指令，可以执行各种复杂的操作。如X86。

      windows11和以前的macos就是基于x86指令集的，即它是设计用于在 x86 处理器上运行的

    - RISC（精简指令集计算）：RISC 指令集包含了相对简单的指令，可以提高 CPU 的性能。如RISC-V，ARM和MIPS

      m1芯片之后的macos就是基于ARM指令集的

- **QEMU** 是一个用于模拟各种计算机系统的虚拟机软件。QEMU 会模拟以下硬件:

  - CPU：QEMU 可以模拟基于不同指令集架构的 CPU，包括 x86、ARM 和 RISC-V。
  - 内存：QEMU 会为模拟的 CPU 分配内存。
  - 存储：QEMU 可以模拟各种存储设备，包括硬盘、闪存和网络。
  - 网络：QEMU 可以模拟网络接口，允许模拟的系统与外部网络进行通信。

- 完整计算机系统中CPU还经由I/O interface和其他硬件连接在一起

  - RAM
  - ROM(包含启动代码)
  - 硬盘
  - 鼠标键盘和屏幕

## 1. 理论知识

### 1.1 Abstracting physical resources

**为什么需要操作系统？**

答：将物理资源抽象为服务

- 这些服务即一、1.0xv6提供的系统调用

  应用程序不再直接访问敏感sensitive的硬件资源，而是通过操作系统提供的系统调用来实现和硬件资源的交互。

- 操作系统提供的系统调用的**好处**：

  - 不仅让程序员更容易编写应用程序
  - 也让各个应用程序之间有了更强的隔离isolation。
  >strong isolation: 一个应用程序application的bug不会影响到另一个应用程序，而操作系统os可以清除运行失败的应用程序并继续运行另一个应用程序。

### 1.2 User mode, supervisor mode, and machine mode

**CPU在硬件层面提供了实现strong isolation的支持**

- **三个模式的目的**：

  1. 让应用程序app不能修改操作系统os的数据结构和指令。

  2. 应用程序也不能访问其他进程的内存。

- RISC-V提供了**3种模式**来让CPU执行指令

  1. **machine mode**

     - cpu以这个模式启动，用于配置电脑，然后很快的转为supervisor mode
     - instructions executing在这个模式下有所有的特权full privilege

  2. **supervisor mode**

     - 这个模式下，cpu可以执行privileged instructions即系统调用，比如：

       - 启用/禁用中断interrupt
       - 读取/写入保存页表page table地址的寄存器

       > page table: 页表是计算机操作系统中用于存储虚拟地址和物理地址映射关系的数据结构。

     - supervisor mode模式下运行的软件，称之为运行在kernel space。（见一、1.那张图）

       这个软件即内核kernel

       user mode模式下运行的程序，称之为运行在user space。

  3. **user mode**

     - 应用程序app只可以执行user-mode instruction

       如果想要执行privileged instructions需要先转移到kernel，让kernel来执行。（见一、1.那张图）

     - 应用程序app无法直接调用kernel function，而是通过cpu提供的特殊指令在一个进入点entry point来切换cpu的模式，RISC-V中这个指令是：`ecall`

     - 在这个进入点entry point后，内核会决定是否执行应用程序app想要执行的系统调用：

       1. cpu经过`ecall`指令后被切换到supervisor mode

       2. 内核验证这个系统调用的参数

          比如检查：传递给系统调用的地址是否是应用程序内存的一部分

       3. 决定是否执行这个系统调用

          比如检查：这个应用程序是否被允许写或读某一个文件

### 1.3 Kernel organization

考虑一个问题：OS的哪些部分应该以supervisor mode来运行呢？

- **monolithic kernel**

  - 又称宏内核，是一种操作系统内核架构，整个内核程序是一个单一的二进制可执行文件，所有的系统调用都以supervisor mode来执行。
  - 优点：
    - 设计简单：因为所有的内核功能都包含在一个单一的二进制文件中，程序员不用去考虑是属于supervisor还是user mode的，所以它更容易开发和维护。
    - 效率高：因为整个操作系统所有的内核功能位于同一个地址空间中。
  - 缺点：
    - 越大的系统潜在的bug就越多，bug在这种模式下是致命的，因为在supervisor mode下的error会导致内核fail，这时所有的app都会fail只能重启内核了

- **micro kernel**

  - 又称微内核，是一种操作系统内核架构，其特点是内核功能模块化，每个模块都是一个独立的进程。操作系统的大部分部分都以user mode来执行。
  - 这种架构使得内核尽可能的简单，因为大部分操作系统都存在于user-level servers。
  - 内核会提供一些low-level的功能：启动一个app，发送message，访问hardware等

- **两者都得到了广泛的应用**

  - Ubuntu、Windows 和 macOS 都属于 monolithic kernel 内核架构
  - [seL4](https://github.com/seL4/seL4)、QNX、MINIX 属于 micro kernel内核架构

- **两种架构有很多的相同理念**

  - 系统调用system call

  - 使用页表page tables用于将虚拟地址转换为物理地址。

    > 虚拟地址是进程看到的地址，而物理地址是硬件看到的地址。

  - 支持中断interrupts

  - 支持多进程processes

  - 利用锁locks来并发控制concurrency control

  - 应用文件系统file system

### 1.4 Code: xv6 organization

- xv6操作系统使用的是宏内核架构monolithic kernel，所以xv6内核的接口就是整个操作系统的结构。xv6的内核代码有:

  ![image-20230921010828188](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/Xv6%20kernel%20source%20files.png)

- 这些文件提供的函数（接口interfaces）都定义在文件[kernel/defs.h](kernel/defs.h)中

### 1.5 Process overview

- 1.1中说的隔离isolation也就是进程process。进程这一抽象不仅阻止了一个进程破坏或侦察另一个进程的内存、cpu和文件描述符，也阻止了破坏内核。进程的实现主要基于2个ideas:

  1.  **an address space**, to give a process the illusion幻觉 of its own memory。

     通过地址空间让进程以为有自己内存的假象

  2. **a thread**, to give the process the illusion of its own CPU

     通过线程让进程以为有自己CPU的假象

- 内核用包括用户/管理程序模式标志user/supervisor mode flag、地址空间address spaces和线程的时间分片time-slicing来**实现进程的机制**

- Xv6操作系统使用**page tables页表**（由硬件实现）来给予每个进程他们自己的私有内存系统(也叫address space)

  这个页表会将一个`virtual address`（RISC-V指令集操作的地址）映射到一个`physical address`（cpu芯片发送到主存main memory的地址）

  >  虚拟地址是进程在内存中分配的地址空间

- xv6中一个进程的**虚拟地址virtual address布局**：

  ![image-20230924033349973](https://raw.githubusercontent.com/Fernweh-yang/ImageHosting/main/img/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80.png)

  - 一个进程的user memory从虚拟地址0开始
    - 首先是**指令**instructions
    - 然后是**全局变量**global variables
    - 接着是**栈stack**：用于存储函数调用时的参数、局部变量和返回地址。
    - 最后是**堆heap**：用于动态分配内存，在程序结束时释放。
  - 有一系列因素限制一个进程的最大虚拟地址：[MAXVA](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/riscv.h#L363C1-L363C43)
    - RISC-V指令集中指针是64位的
    - 硬件在用页表查阅虚拟地址时，只使用这64位中的低39位来进行页表转换
    - 而xv6系统又只用其中的38位。所以最大地址MAXVA=$2^{38}-1=0x3fffffffff$
  - 在虚拟地址空间的顶端(末尾)，xv6保留了2页page分别对应于trampoline和trapframe
    - trampoline：是一个程序，用于在用户态和内核态之间切换。
    - ssstrapframe：是一个结构体，用于保存用户态中断或异常发生时的寄存器值。

- Xv6内核中每个进程的内核状态片段(piece of kernel state)都保存在一个**结构体[stusdsct proc](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/proc.h#L85)**

  - 每一个进程最重要的内核状态片段有：

    - 页表page table
    - 内核栈kernel stack
    - 运行状态run state

  - 在Xv6的程序中使用`p->xxx`来指向每一个结构体`proc`中的元素

    比如：

    - `p->pagetable`是一个指向进程页表的指针
    - `p->state`读取当前进程的状态：whether the process is allocated, ready to run, running, waiting for I/O, or exiting

- 每个进程都会使用一个**线程thread**来执行进程的指令

  - 线程可以被随时暂停suspend和重新启用resume，所以在切换进程时：内核会suspend当前运行进程的thread然后resume另一个进程的thread

  - 线程的状态(局部变量，函数调用的返回地址)都被保存在线程栈thread's stack中

    线程栈根据下面这条，动态的选择使用用户栈或者内核栈。

  - 每个进程有2个栈stack：用户栈user stack和内核栈kernel stack(p->kstack)
    - 当一个进程在执行用户指令时，只有用户栈被使用，这时的内核栈是空的
    - 当进程进入内核(执行系统调用或中断)的时候，内核代码执行再内核栈上。这时候进程虽然在内核栈中，但用户栈中仍然有着之前保存的数据，只是没在使用而以。
    - 内核栈是独立的，用户代码无法破坏到它，所以即使一个用户程序破坏了它的用户栈，内核还是可以继续运行的

- Xv6的一个进程可以通过调用RISC-V架构的**ecall指令**来提升hardware privilege level，使program counter转为内核定义的entry point。

  - 在entry point，代码会会进入内核栈kernel stack，然后执行内核指令（系统调用）
  - 当系统调用完成后，通过调用`sret`指令来降低hardware privilege level，代码会返回用户栈user stack。
  - 一个进程的线程可以在内核中阻塞(block)来等待I/O，等到I/O结束时再从它停止的地方重新开始(resume)

### 1.6 Code: starting xv6, the first process and system call

内核启动和运行第一个进程都发生了什么？：

1. **当基于RISC-V指令集的计算机启动，它会初始化自己并运行保存在read-only 内存中的 boot loader。这个boot loader会将xv6操作系统的内核载人内存中。**

   - 启动时，虚拟地址virtual address直接映射到 物理地址physical address

   - Boot loader会将xv6内核载入到物理地址`0x80000000`，为什么不是`0x0`？

     因为`0x0:0x80000000`这一段地址区间包含了所有的I/O设备

2. **在machine mode下， CPU会在[_entry](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/entry.S#L7)处执行xv6操作系统：为xv6内核创建栈**

   - 为内核创建栈：xv6会为一个初始栈[stack0](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/start.c#L11)申请空间，然后在`_entry`的代码会将这个栈的指针stack pointer register `sp`加载到地址`stack0+4096`，也就是栈的顶部（因为RISC-V中的栈grow down）
   - 运行C代码：有了栈以后，Xv6内核就可以用[start](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/start.c#L21)函数调用C语言代码

3. **在start()函数处从machine mode转为supervisor mode**


   - 这个`start`函数会执行一些只允许在machine mode做的设置，然后转换到supervisor mode。

     为了进入supervisor mode,`start`函数会创建一个"之前"的supervisor mode：

     1. 将寄存器`mstatus`中"之前"的privilege mode设置为supervisor mode

     2. 通过将main的地址写入寄存器`mepc`来将自己的返回地址设为main
     3. 通过将0写入页表寄存器page-table register`satp`，来禁止supervisor mode下的虚拟地址转换
     4. 为supervisor mode授权所有的中断interrupt和异常exceptions

   - 在跳入这个"之前"的supervisor mode之前，`start`函数还会对clock chip编程来生成timer interrupts：

     1. 然后`start`函数通过调用RISC-V指令集的mret指令来回到上面设置好的supervisor mode

        > **mret指令**：用来从machine mode跳回到之前调用machine mode的supervisor mode。
        >
        > 而一开始没有之前的supervisor mode，所以就有了上面先创建一个假的“之前”的supervisor mode，再来调用mret进入这个mode的过程

     2. 这会导致程序计数器program counter指向[main函数](https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/main.c#L11)

        > **程序计数器program counter**： 是一个寄存器，用于存储当前正在执行的指令的地址

4. **创建进程，并执行第一个系统调用exec()**

   - 在[main函数](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/main.c#L11)初始化了一些设备和子系统后，它会通过调用[userinit()](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/proc.c#L233)函数来创建第一个进程。
   - 这个进程会执行RISC-V架构本身写好的一个小程序，用来执行Xv6系统的第一个系统调用：**exec()**
     1.  汇编程序[initcode.S](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/user/initcode.S#L11)会加载系统调用`exec`的数字代号：[SYS_EXEC](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/syscall.h#L8)也就是7到寄存器`a7`。内核会使用这个数字[num](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/syscall.c#L137)来确定syscall()函数调用的是哪个系统调用
     2. 然后使用指令集的ecall指令来重新进入内核
     3. 内核通过[system call table](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/syscall.c#L107)将寄存器`a7`中保存的系统调用数字代号`SYS_EXEC`映射到`sys_exec`。
     4. 这个`sys_exec`也就是1.0中所展示的系统调用：exec()函数，系统调用exec()会将当前进程的村内和寄存器替换为一个新的程序，这里这个程序是/init

5. **启动初始化程序init，进入它的user mode**

   - 一旦内核完成了上面的系统调用`exec()`，它会返回`/init`进程的user space

   - [init](https://github.com/Fernweh-yang/project_xv6/blob/syscall/user/init.c)会创建一个新的console终端，这个终端console会以文件描述符0,1,2的形式打开(因为linux系统中一切都是文件)，最后会在console中启动一个命令行解释器shell(用于用户在该终端console中输入命令)。

     如此系统就启动了。

### 1.7 Security Model

操作系统是如何应对buggy和恶意代码malicious code的呢？

- **内核设计的绝对要求**：限制用户进程

  1. 只能在自己的user memory内执行read/write/execute操作。
  2. 只能使用32个通用RISC-V寄存器
  3. 只有在系统调用的帮助下去影响内核或其他进程

- **即使专家所写的内核代码和硬件(RISC-V架构的CPU，RAM，disk等)也可能有BUG**

  为此需要设置一些保护措施(safeguards)来预防可能的错误：

  1. assertions断言
  2. type checking类型检查
  3. stack guard pages栈保护页

### 1.8 Real world

现实使用的操作系统和xv6是大体相似的。

但现代的操作系统还允许：

1. 一个进程有多个线程
2. 一个进程可以使用多个cpu
3. 多个线程实现一些xv6没有的机制

## 2. 实验

根据[实验要求](https://pdos.csail.mit.edu/6.828/2022/labs/syscall.html)需要先读

1. 内核代码：kernel文件夹下的 [syscall.c](https://github.com/Fernweh-yang/project_xv6/blob/syscall/kernel/syscall.c)和[syscall.h](https://github.com/Fernweh-yang/project_xv6/blob/syscall/kernel/syscall.h)
2. 用户代码：user文件夹下的[usys.pl](https://github.com/Fernweh-yang/project_xv6/blob/syscall/user/usys.pl)和[user.h](https://github.com/Fernweh-yang/project_xv6/blob/syscall/user/user.h)
3. 进程相关的代码：kernel文件夹下的[proc.c](https://github.com/Fernweh-yang/project_xv6/blob/syscall/kernel/proc.c)和[proc.h](https://github.com/Fernweh-yang/project_xv6/blob/syscall/kernel/proc.h)

4. 本章的理论知识以及第四章的4.3,4.4



# Lab3: Page tables

# Lab4: Traps

## 1.  理论知识

### 1.1 RISC-V trap machinery

### 1.2 Traps from user space

### 1.3 Code: Calling system calls

Lab2的1.6中在汇编程序[user/initcode.s](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/user/initcode.S#L11)中调用了Xv6启动后的第一个系统调用exec，那么**内核中**具体是**如何实现系统调用的呢**：

1. [initcode.s](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/user/initcode.S#L8)将exec的参数(arguments)放入寄存器a0和a1，将系统调用号放入寄存器a7

   - 系统调用号[system call numbers](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/syscall.h)和[kernel/syscall.c](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/syscall.c#L107)的syscalls数组元素一一对应
   - 根据这个数组找到对应的系统调用函数

2. [ecall](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/user/initcode.S#L12)指令陷入(trap into)内核并导致uservec, usertrap。

   > 陷阱trap 是一种机制，允许用户程序从用户模式切换到内核模式，以便访问内核提供的资源或服务。有三种触发情况：
   >
   > 1. 用户程序执行了系统调用（system call）
   > 2. Page fault（缺页），运算时除以0，内存访问出错等错误
   >
   > - **uservec**：the first function to be called when a trap occurs in user space. It saves the user's registers and switches the CPU to kernel mode.
   > - **usertrap**：the function that determines the cause of the trap and takes appropriate action. For system calls, it calls the appropriate system call handler function. For other types of traps, it may kill the offending process or take other corrective action.

3. [syscall()](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/syscall.c#L132)从a7寄存器那得到系统调用号后，执行对应的系统调用函数
   
   - 这里第一个系统调用exec()的系统调用号[system call numbers](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/syscall.h#L8)是7
   - 所以根据[kernel/syscall.c](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/syscall.c#L107)的syscalls数组可知，c语言的sys_exec()函数会被执行
4. 最后，sys_exec()执行完返回后，函数返回值保存在p->trapframe->a0
   - RISC-V架构下，C语言的调用返回值通常保存在寄存器a0和a1内
   - 系统调用通常返回-1表示失败，0或1表示成功

### 1.4 Code: System call arguments

在内核中实现系统调用也需要找到由用户代码传来的参数(arguments)。这些参数被保存在用户寄存器

- **内核如何找到这些系统调用参数**？

  内核陷阱(kernel trap)会将用户寄存器(user register)保存到当前进程的trap frame中。在trap frame，内核可以找到这参数。

   > - **用户寄存器**：是指在用户模式下可用的寄存器。在 RISC-V 架构下，用户寄存器有 15 个，其中包括 13 个通用寄存器、1 个程序计数器和 1 个堆栈指针
   > - **trap frame**: 发生 trap 时，CPU 保存用户程序的寄存器状态和堆栈信息的结构

   - 内核函数 argint、argaddr 和 argfd 从trap frame中检索第 n 个系统调用参数

     - 这些参数可以是：整数、指针或文件描述符。

     - 这些函数都会调用[argraw](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/syscall.c#L34)来选择合适的用户寄存器
  
- **如何保证传递参数是指针时的安全性 + 如何解决xv6内核页表和用户页表不一致的问题**

  内核通过[fetchstr()](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/syscall.c#L25)函数来安全的传递用户提供的指针/地址。它主要通过[copyinstr()](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/vm.c#L403)从用户代码那得到参数(arguments)

  1. [copyinstr()](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/vm.c#L403)首先从用户页表pagetabe那复制max位的虚拟地址srcva。
2. 由于用户页表pagetable不是当前的页表，因此copyinstr()会使用[walkaddr()](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/vm.c#L109)函数来将用户也表的虚拟地址srcva转换为物理地址pa0
     - [walkaddr()](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/vm.c#L109)函数会检测用户传来的地址是不是进程地址的一部分，所以不用担心用户乱访问内存

  3. 最后这个物理地址pa0会被传给[dst](https://github.com/Fernweh-yang/project_xv6/blob/dc9c09903358605cef705b48746e202c6c9dd4f6/kernel/vm.c#L424)
   - dst是一个指向内核空间的字符串数组的指针。copyinstr() 函数将用户空间的 srcva 地址处的字符串复制到内核空间的 dst 地址处，并将复制到的字符串长度保存在 *dst_len 参数中。
  
  

### 1.5 Traps from kernel space

### 1.6 Page-fault exceptions

### 1.7 Real world

