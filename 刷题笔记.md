# 一、数组

## 1.理论基础

- 数组是存放在连续内存空间上的相同类型数据的集合
  - 数组下标都是从0开始的。
  - 数组内存空间的地址是连续的
  - 数组的元素是不能删的，只能覆盖！
    - 数组在内存中是连续的地址空间，不能释放单一元素，如果要释放，就是全释放（程序运行结束，回收内存栈空间）
- 二分法：
  - **循环不变量原则**，只有在循环中坚持对区间的定义
- 双指针法：
  - 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作
- 滑动窗口
  - 滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将O(n^2)的暴力解法降为O(n)。
- 总结图：

<img src="https://github.com/Fernweh-yang/Reading-Notes/blob/main/%E7%AC%94%E8%AE%B0%E9%85%8D%E5%A5%97%E5%9B%BE%E7%89%87/%E6%95%B0%E7%BB%84%E6%80%BB%E7%BB%93.png?raw=true" style="zoom:150%;" />

# 二、链表

## 1.理论基础

- 链表类型

  1. 单链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）
     - 链接的入口节点称为链表的头结点也就是head。

  2. 双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。
     - 双链表既可以向前查询也可以向后查询。

  3. 循环链表：链表首尾相连。
     - 循环链表可以用来解决约瑟夫环问题。

- 链表的存储方式

  链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

- 链表的定义

  ```c++
  struct ListNode {
      int val;  // 节点上存储的元素
      ListNode *next;  // 指向下一个节点的指针
      ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
  };
  ```

- 性能分析

  | 时间复杂度 | 插入/删除 | 查询 | 适用场景                         |
  | ---------- | --------- | ---- | -------------------------------- |
  | 数组       | O(n)      | O(1) | 数据量固定，频繁查询，较少增删   |
  | 链表       | O(1)      | O(n) | 数据量不固定，频繁增删，较少查询 |

  - 数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

  - 链表的长度可以是不固定的，并且可以动态增删， 

- 总结图

  ![](https://github.com/Fernweh-yang/Reading-Notes/blob/main/%E7%AC%94%E8%AE%B0%E9%85%8D%E5%A5%97%E5%9B%BE%E7%89%87/%E9%93%BE%E8%A1%A8%E6%80%BB%E7%BB%93.png?raw=true)

# 三、哈希表

Hash table

## 1.理论基础

- 哈希表是根据关键码的值而直接进行访问的数据结构

  - 数据就是一个哈希表：关键码就是数组的索引下标，然后通过下标直接访问数组中的元素
  - 一般哈希表都是用来快速判断一个元素是否出现集合里。

- 哈希函数：把元素的值直接映射为哈希表上的索引

  - 哈希函数通过hashCode把元素值转化为哈希表上的索引。
  - 如果hashCode得到的数值大于哈希表的大小了，就对数值做一个取模操作，以保证元素的值一定可以映射到哈希表上。

- 哈希碰撞：元素的数量大于哈希表的大小，多个元素映射到了同一个索引下。

- 解决哈希碰撞的2种方法

  1. 拉链法Chaining：把散列到同一槽中的所有元素放在一个链表中，而将此链表的头指针放在散列表T[0…m-1]中
  2. 开放寻址Open Adressing：将所有结点均存放在散列表T[0…m-1]中.
     - 有线性探测、二次探测以及双重探测。三种技术
     - 即去找一个空位来放置冲突的元素，因此要求哈希表的tableSize必须大于datasize

- 常见的三种哈希结构：

  1. 数组

  2. set集合

     | 集合               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::set           | 红黑树   | 有序     | 否               | 否           | O(log n) | O(log n) |
     | std::multiset      | 红黑树   | 有序     | 是               | 否           | O(logn)  | O(logn)  |
     | std::unordered_set | 哈希表   | 无序     | 否               | 否           | O(1)     | O(1)     |

     - 红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。
     - 优先使用unordered_set，因为它的查询和增删效率最优
     - 所有的元素只有key，没有value, key即value

  3. map映射

     | 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
     | ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
     | std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(logn)  | O(logn)  |
     | std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
     | std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

     - 所有的元素都是key :value

# 四、字符串

## 1.理论基础

- 字符串是若干字符组成的有限序列，也可以理解为是一个字符数组

# 五、双指针法

## 1.理论基础

- 双指针法并不隶属于某一种数据结构，但数组，链表，字符串都会用到双指针法

# 六、栈与队列

## 1.理论基础

- 队列是先进先出，栈是先进后出。
- **栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**
  - 栈的底层实现可以是vector，deque，list 
  - 栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。
  - 所以STL中栈往往不被归类为容器，而被归类为container adapter（容器适配器）
  - 我们常用的SGI STL，如果没有指定底层实现的话，默认是以deque为缺省情况下栈的低层结构
  - deque是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。
  - 指定其他底层实现：
    - 指定vector为栈的底层实现：`std::stack<int, std::vector<int> > third;`
    - 指定list 为队列的底层实现：`std::queue<int, std::list<int>> third; `
- **SGI STL中 队列底层实现缺省情况下一样使用deque实现的。**
  - 同样不允许有遍历行为，不提供迭代器

# 七、二叉树

## 1.理论基础

- 二叉树的种类
  - 满二叉树：如果一棵二叉树只有度为0的结点（国外定义，国内度必须是2）和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。
    - 度：即有几个子节点
    - 深度为k，有2^k-1个节点
  - 完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层**最左边**的若干位置。
    - 堆就是一棵完全二叉树，同时保证父子节点的顺序关系
  - 二叉搜索树：二叉搜索树是一个有有序数值的有序树
    - 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
    - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值
    - 它的左、右子树也分别为二叉排序树
  - 平衡二叉树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
    - C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树。所以map、set的增删操作时间时间复杂度是logn
      - unordered_map、unordered_set，unordered_map、unordered_map底层实现是哈希表。

- 二叉树的存储方式

  - 二叉树可以链式存储，也可以顺序存储。链式存储方式就用指针， 顺序存储的方式就是用数组。
  - 如果用数组来存储：如果父节点的数组下标是 i，那么它的左孩子就是 i \* 2 + 1，右孩子就是 i \* 2 + 2
  - 一般使用链式存储二叉树

- 二叉树的遍历方式

  - 深度优先遍历：使用递归的方式或借助栈使用非递归的方式来实现

    **这里前中后，其实指的就是中间节点的遍历顺序**

    - 前序遍历（递归法，迭代法）中间节点的顺序：中左右
    - 中序遍历（递归法，迭代法）中间节点的顺序：左中右
    - 后序遍历（递归法，迭代法）中间节点的顺序：左右中

  - 广度优先遍历：使用队列来实现

    - 层次遍历（迭代法）

- 二叉树的定义：

  ```c++
  struct TreeNode {
      int val;
      TreeNode *left;
      TreeNode *right;
      TreeNode(int x) : val(x), left(NULL), right(NULL) {}
  };
  ```

  

# 八、回溯算法

## 1.理论基础

- 回溯算法也叫回溯搜索法，是递归的副产品。

  - 回溯的本质是穷举，琼剧所有的可能，然后选出想要的答案。所以效率不高。

- 回溯法，一般解决如下问题：

  - 组合问题：N个数里面按一定规则找出k个数的集合。组合无序
  - 切割问题：一个字符串按一定规则有几种切割方式
  - 子集问题：一个N个数的集合里有多少符合条件的子集
  - 排列问题：N个数按一定规则全排列，有几种排列方式。排列有序
  - 棋盘问题：N皇后，解数独等等

  所有回溯法的问题都可以抽象为树形结构，因为回溯法解决的都是在集合中递归查找子集，**集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）。

- 回溯函数做题模板

  ```c++
  // 第一步：回溯函数模板返回值以及参数
  // 因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。
  void backtracking(参数) {
      // 第二步：回溯函数终止条件
      // 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
      if (终止条件) {
          存放结果;
          return;
      }
  	
      // 第三步：回溯搜索的遍历过程
      // 回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
      for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
          处理节点;
          backtracking(路径，选择列表); // 递归
          回溯，撤销处理结果
      }
  }
  ```
  
  
  

# 九、贪心算法

## 1.理论基础

- **贪心的本质是选择每一阶段的局部最优，从而达到全局最优**。
  - 贪心算法并没有固定的套路。所以唯一的难点就是如何通过局部最优，推出整体最优。
- 如何验证可不可以用贪心?
  - **最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧**
  - 严谨的话需要数学证明
    - 数学归纳法
    - 反证法
- 一般截图步骤
  - 将问题分解为若干个子问题
  - 找出适合的贪心策略
  - 求解每一个子问题的最优解
  - 将局部最优解堆叠成全局最优解

  # 十、动态规划

Dynamic Programming,简称dp

## 1.理论基础

- 如果某一问题有很多重叠子问题，使用动态规划是最有效的。所以动态规划中每一个状态一定是由上一个状态推导出来的，**这一点就区分于贪心**，贪心没有状态推导，而是从局部直接选最优的.

- 解题步骤
  1. 确定dp数组（dp table）以及下标的含义
  2. 确定递推公式
  3. dp数组如何初始化
  4. 确定遍历顺序
  5. 举例推导dp数组

- 动态规划如何debug

  - **做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

  - 然后再写代码，如果代码没通过就**打印dp数组**，看看是不是和自己预先推导的哪里不一样。

    - 如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。
    - 如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

  - 具体debug时问自己三个问题

    1. 这道题目我举例推导状态转移公式了么？
    2. 我打印dp数组的日志了么？
    3. 打印出来了dp数组和我想的一样么？

    
