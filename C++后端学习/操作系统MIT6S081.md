# 零、课程准备

## 1. 资源

根据[MIT6.S081](https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/)学习操作系统的笔记

- 课程网站：https://pdos.csail.mit.edu/6.828/2021/schedule.html
- 课程视频：https://www.youtube.com/watch?v=L6YqHxYHa7A，每节课的链接详见课程网站
- 课程视频翻译文档：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/
- 课程教材：https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf
- 课程作业：https://pdos.csail.mit.edu/6.828/2021/schedule.html，11个lab，具体要求详见课程网站

XV6资源：

- [xv6 操作系统的深入讲解](https://space.bilibili.com/1040264970/)
- [xv6 中文文档](https://th0ar.gitbooks.io/xv6-chinese/content/index.html)
- [xv6 关键源码逐行解读 + 整体架构分析](https://www.youtube.com/playlist?list=PLbtzT1TYeoMhTPzyTZboW_j7TPAnjv9XB)

参考题解/博客

- [doraemonzzz](http://doraemonzzz.com/tags/6-S081/)
- [Miigon's blog](https://blog.miigon.net/categories/mit6-s081/)不错
- [Zhou Fang](https://walkerzf.github.io/categories/6-S081/index.html)
- [Yichun's Blog](https://www.yichuny.page/tags/Operating System)
- [解析Ta](https://blog.csdn.net/u013577996/article/details/108679997)
- [PKUFlyingPig](https://github.com/PKUFlyingPig/MIT6.S081-2020fall)
- [星遥见](https://www.cnblogs.com/weijunji/tag/XV6/)

## 2. 如何debug

- 确保理解了指针，是否能理解这个[exercise](https://pdos.csail.mit.edu/6.828/2019/lec/pointers.c)，值的记得的点：

  - If `int *p = (int*)100`, then `(int)p + 1` and `(int)(p + 1)` are different numbers: the first is `101` but the second is `104`. When adding an integer to a pointer, as in the second case, the integer is implicitly multiplied by the size of the object the pointer points to.

  - `p[i]` is defined to be the same as `*(p+i)`, referring to the i'th object in the memory pointed to by p. The above rule for addition helps this definition work when the objects are larger than one byte.

    `&p[i]` is the same as `(p+i)`, yielding the address of the i'th object in the memory pointed to by p.

  所以当看到指针时，要注意这是一个整数加法还是指针加法

- 当一部分可以工作了，即的git一下

- 使用print大法

- 使用gdb.(See [Using the GNU Debugger](https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf) for helpful GDB tips.)

  To use gdb with xv6, run `make make qemu-gdb` in one window, run `gdb` (or `riscv64-linux-gnu-gdb`) in another window, set a break point, followed by followed by 'c' (continue), and xv6 will run until it hits the breakpoint.

- 如果想了解 编译器生成的汇编代码 或者 特定内核地址的指令，可以查看kernel.asm（这是由Makefile生成的Assembly Language文件）

- **如果内核崩溃kernel panics**，比如内核崩溃/异常了，操作系统会停止工作并发出错误信息：

  为此可以做：

  - 在kernel.asm中查看内核崩溃时程序技术器(Program Counter)所指的位置

    > 程序计数器（Program Counter），也被称为指令指针（Instruction Pointer）。程序计数器是一种特殊的寄存器，它存储了当前正在执行的机器指令的内存地址。在执行程序时，处理器会不断从内存中读取指令，然后将程序计数器更新为下一条指令的地址，以便顺序执行指令。

  - 或者运行`addr2line -e kernel/kernel pc-value`直接找出给定程序计数器值所对应的源代码位置（函数名和行号）

    - `addr2line` 是一个用于符号解析的命令行工具，它可以根据给定的地址（或程序计数器值）和可执行文件（或共享库文件）来确定源代码中的对应位置
    - `-e kernel/kernel`：指定要解析的可执行文件，这里是内核的可执行文件
    - `pc-value`：代表程序计数器（指令指针）的值，即发生问题的机器代码地址。

- **如果内核崩溃kernel panics了，想回溯backtrace:**

  可以用gdb来回溯：

  - run `make qemu-gdb` in one window
  - run `gdb` (or `riscv64-linux-gnu-gdb`) in another window
  - set breakpoint in panic (`b panic`), followed by `c (continue). 
  - When the kernel hits the break point, type `bt` to get a backtrace.

- **如果内核死锁kernel hangs了**，比如死锁deadlock或者页错误page fault了

  > "Page fault"（页错误）是指在程序访问内存时，发现所请求的内存页面（页）当前不在主存中或者没有合法地映射到当前进程的虚拟地址空间中。

  可以使用geb找到哪里死锁了：

  - run `make qemu-gdb` in one window
  - run `gdb` (`riscv64-linux-gnu-gdb`) in another window , followed by `c` (continue). 
  - When the kernel appears to hang hit Ctrl-C in the `qemu-gdb` window and type `bt` to get a backtrace.

- **qemu提供了一个监视器monitor来查看虚拟系统的状态**

  > `qemu` 是一个通用的虚拟化工具，可以用于在一个操作系统上模拟运行另一个操作系统，或者在同一个操作系统上模拟运行不同的架构

  qemu的一些命令

  - `control-a c`：运行monitor，c指console操作台

  - `info mem`：打印页表(Page table)

    > `页表`是操作系统中的一种数据结构，用于管理虚拟内存和物理内存之间的映射关系。在计算机系统中，虚拟内存是指操作系统为每个进程提供的抽象内存空间，而物理内存是实际的硬件内存。页表帮助操作系统跟踪虚拟内存中的每个页面（页）与物理内存之间的对应关系。

  - `cpu`：指定看那个core的信息

# 一、Lab1: Unix utilities

实验目的：实现几个 unix 实用工具，熟悉 xv6 的开发环境以及系统调用。

## 1. 理论知识

[第一章：Operating system interfaces](https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf)

- OS的任务

  The job of an operating system is to share a computer among multiple programs and to provide a more useful set of services than the hardware alone supports.

  - 管理和抽象低维的硬件，从而某一进程(process)不用关心当前运行的硬件是什么
  - 在多个程序之间分享硬件，从而这些程序可以同时运行
  - 给程序们提供交互的方法，从而这些程序可以分享信息一起工作

- 系统内核和用户程序关系

  ![image-20230816233233405](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png)

  - `kernel`：一个给正在运行的程序们提供服务的特殊程序

  - `process`：进程，正在运行程序，分配的内存下存储着：

    - `instructions`：指令，让程序计算
    - `data`：用于计算的数据
    - `stack`：组织程序的过程调用(procedure calls)

  - **一个进程(process，红线)会交替的在user space和kernel space中执行**

    当一个process需要调用内核服务时，会调用OS Interface提供的某一个服务`system call`

    > 操作系统通过interface来给其他user program来提供服务

    这个`system call`会进入kernel，然后kernel执行服务并返回值。

  - cpu提供硬件保护机制来确保每一个在user space的进程只能访问它自己的内存空间(memory)

    相比user program，kernel有硬件特权用来访问硬件资源。
    
  - `shell`终端，是一个普通的user program不是内核，所以可以被任意的替代。
    
    `shell`的作用：从人这读取命令，并执行。
    
    
    

## 2. 实验