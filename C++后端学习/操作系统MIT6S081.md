# 零、课程准备

## 1. 资源

根据[MIT6.S081](https://csdiy.wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6.S081/)学习操作系统的笔记

- 课程网站：https://pdos.csail.mit.edu/6.828/2021/schedule.html
- 课程视频：https://www.youtube.com/watch?v=L6YqHxYHa7A，每节课的链接详见课程网站
- 课程视频翻译文档：https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/
- 课程教材：https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf
- 课程作业：https://pdos.csail.mit.edu/6.828/2021/schedule.html，11个lab，具体要求详见课程网站

XV6资源：

- [xv6 操作系统的深入讲解](https://space.bilibili.com/1040264970/)
- [xv6 中文文档](https://th0ar.gitbooks.io/xv6-chinese/content/index.html)
- [xv6 关键源码逐行解读 + 整体架构分析](https://www.youtube.com/playlist?list=PLbtzT1TYeoMhTPzyTZboW_j7TPAnjv9XB)

参考题解/博客

- [doraemonzzz](http://doraemonzzz.com/tags/6-S081/)
- [Miigon's blog](https://blog.miigon.net/categories/mit6-s081/)不错
- [Zhou Fang](https://walkerzf.github.io/categories/6-S081/index.html)
- [Yichun's Blog](https://www.yichuny.page/tags/Operating System)
- [解析Ta](https://blog.csdn.net/u013577996/article/details/108679997)
- [PKUFlyingPig](https://github.com/PKUFlyingPig/MIT6.S081-2020fall)
- [星遥见](https://www.cnblogs.com/weijunji/tag/XV6/)

## 2. 如何debug

- 确保理解了指针，是否能理解这个[exercise](https://pdos.csail.mit.edu/6.828/2019/lec/pointers.c)，值的记得的点：

  - If `int *p = (int*)100`, then `(int)p + 1` and `(int)(p + 1)` are different numbers: the first is `101` but the second is `104`. When adding an integer to a pointer, as in the second case, the integer is implicitly multiplied by the size of the object the pointer points to.

  - `p[i]` is defined to be the same as `*(p+i)`, referring to the i'th object in the memory pointed to by p. The above rule for addition helps this definition work when the objects are larger than one byte.

    `&p[i]` is the same as `(p+i)`, yielding the address of the i'th object in the memory pointed to by p.

  所以当看到指针时，要注意这是一个整数加法还是指针加法

- 当一部分可以工作了，即的git一下

- 使用print大法

- 使用gdb.(See [Using the GNU Debugger](https://pdos.csail.mit.edu/6.828/2019/lec/gdb_slides.pdf) for helpful GDB tips.)

  To use gdb with xv6, run `make make qemu-gdb` in one window, run `gdb` (or `riscv64-linux-gnu-gdb`) in another window, set a break point, followed by followed by 'c' (continue), and xv6 will run until it hits the breakpoint.

- 如果想了解 编译器生成的汇编代码 或者 特定内核地址的指令，可以查看kernel.asm（这是由Makefile生成的Assembly Language文件）

- **如果内核崩溃kernel panics**，比如内核崩溃/异常了，操作系统会停止工作并发出错误信息：

  为此可以做：

  - 在kernel.asm中查看内核崩溃时程序技术器(Program Counter)所指的位置

    > 程序计数器（Program Counter），也被称为指令指针（Instruction Pointer）。程序计数器是一种特殊的寄存器，它存储了当前正在执行的机器指令的内存地址。在执行程序时，处理器会不断从内存中读取指令，然后将程序计数器更新为下一条指令的地址，以便顺序执行指令。

  - 或者运行`addr2line -e kernel/kernel pc-value`直接找出给定程序计数器值所对应的源代码位置（函数名和行号）

    - `addr2line` 是一个用于符号解析的命令行工具，它可以根据给定的地址（或程序计数器值）和可执行文件（或共享库文件）来确定源代码中的对应位置
    - `-e kernel/kernel`：指定要解析的可执行文件，这里是内核的可执行文件
    - `pc-value`：代表程序计数器（指令指针）的值，即发生问题的机器代码地址。

- **如果内核崩溃kernel panics了，想回溯backtrace:**

  可以用gdb来回溯：

  - run `make qemu-gdb` in one window
  - run `gdb` (or `riscv64-linux-gnu-gdb`) in another window
  - set breakpoint in panic (`b panic`), followed by `c (continue). 
  - When the kernel hits the break point, type `bt` to get a backtrace.

- **如果内核死锁kernel hangs了**，比如死锁deadlock或者页错误page fault了

  > "Page fault"（页错误）是指在程序访问内存时，发现所请求的内存页面（页）当前不在主存中或者没有合法地映射到当前进程的虚拟地址空间中。

  可以使用geb找到哪里死锁了：

  - run `make qemu-gdb` in one window
  - run `gdb` (`riscv64-linux-gnu-gdb`) in another window , followed by `c` (continue). 
  - When the kernel appears to hang hit Ctrl-C in the `qemu-gdb` window and type `bt` to get a backtrace.

- **qemu提供了一个监视器monitor来查看虚拟系统的状态**

  > `qemu` 是一个通用的虚拟化工具，可以用于在一个操作系统上模拟运行另一个操作系统，或者在同一个操作系统上模拟运行不同的架构

  qemu的一些命令

  - `control-a c`：运行monitor，c指console操作台

  - `info mem`：打印页表(Page table)

    > `页表`是操作系统中的一种数据结构，用于管理虚拟内存和物理内存之间的映射关系。在计算机系统中，虚拟内存是指操作系统为每个进程提供的抽象内存空间，而物理内存是实际的硬件内存。页表帮助操作系统跟踪虚拟内存中的每个页面（页）与物理内存之间的对应关系。

  - `cpu`：指定看那个core的信息

# 一、Lab1: Unix utilities

实验目的：实现几个 unix 实用工具，熟悉 xv6 的开发环境以及系统调用。

## 1. 理论知识

[第一章：Operating system interfaces](https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf)

- OS的任务

  The job of an operating system is to share a computer among multiple programs and to provide a more useful set of services than the hardware alone supports.

  - 管理和抽象低维的硬件，从而某一进程(process)不用关心当前运行的硬件是什么
  - 在多个程序之间分享硬件，从而这些程序可以同时运行
  - 给程序们提供交互的方法，从而这些程序可以分享信息一起工作

- 系统内核和用户程序关系

  ![image-20230816233233405](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/%E7%B3%BB%E7%BB%9F%E6%A0%B8%E5%92%8C%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB.png)

  - `kernel`：一个给正在运行的程序们提供服务的特殊程序

  - `process`：进程，正在运行程序，分配的内存下存储着：

    - `instructions`：指令，让程序计算
    - `data`：用于计算的数据
    - `stack`：组织程序的过程调用(procedure calls)

  - **一个进程(process，红线)会交替的在user space和kernel space中执行**

    当一个process需要调用内核服务时，会调用OS Interface提供的某一个服务`system call`

    > 操作系统通过interface来给其他user program来提供服务

    这个`system call`会进入kernel，然后kernel执行服务并返回值。

  - cpu提供硬件保护机制来确保每一个在user space的进程只能访问它自己的内存空间(memory)

    相比user program，kernel有硬件特权用来访问硬件资源。
    
  - `shell`终端，是一个普通的user program不是内核，所以可以被任意的替代。
    
    `shell`的作用：从人这读取命令，并执行。
    

### 1.1 Processes and memory

- 一些概念：

  - 一个**进程Process**：由**user-space memory** 以及 **per-process state private to the kernel** 所组成

    - 进程的用户空间内存(user-space memory)：指的是进程在执行时用于存储指令、数据和栈的部分。这是进程的用户态部分，用于执行用户编写的应用程序代码。
    - 内核私有的每个进程状态(per-process state private to the kernel)：指的是内核维护的关于每个进程的信息，如进程标识符（PID）、寄存器状态、打开文件表等等。这些状态数据是操作系统内核用来管理和控制进程的重要信息。

  - 系统的进程是 **time-sharing**的

    - 时间共享(time-sharing)：计算机会迅速地在不同的进程之间切换，每个进程都被分配一个小的时间片来执行。这种切换是如此迅速，以至于用户几乎感觉不到多个进程在同时运行。

    - 当一个进程不运行时，xv6系统会保存它对应的cpu寄存器，等到再次运行时再复原。

      > 寄存器是一种用于 **存储程序执行期间临时数据** 和 **处理指令、数据和地址** 的硬件组件。

  - 内核会给每个进程分配一个process identifier，也就是**pid**

    > PID通常是一个唯一的数字，用于在操作系统中标识和区分不同的进程。每个运行中的进程都会分配一个独特的PID。

- xv6提供的系统调用：

  ![ ](https://cdn.jsdelivr.net/gh/Fernweh-yang/ImageHosting@main/img/xv6%20system%20calls.png)

- 在 xv6 操作系统中，大多数的用户空间内存(user-space memory)分配是隐式进行的。

  > user-space memory: 的是进程在执行时，用于存储用户程序、数据和栈等的内存区域。

  - `fork`： 当一个新的子进程被创建（通过 fork 函数），操作系统会为子进程分配足够的内存，用于存储子进程的副本数据，这些数据包括父进程在创建子进程时的内存内容（例如变量、数据等）。这样，子进程就可以继承父进程的状态，并且可以在之后的执行中对这些数据进行操作。

    > "fork" 是创建新进程的一种方式，它通过复制父进程的状态来生成一个子进程，子进程独立于父进程运行。这种机制在实现多任务和并发处理时非常有用，允许程序同时执行多个任务。

  - `exec`：当一个进程要执行一个新的可执行文件（通过 exec 函数），操作系统会为该进程分配足够的内存，以容纳要执行的可执行文件的代码、数据和其他需要的资源。这样，该进程就可以加载并执行新的可执行文件。

  - `sbrk(n)`：如果一个进程在运行时run-time需要更多的内存，可以用`sbrk(n)`来多分配n bytes的内存。

    sbrk()会返回新内存的地址
  
- 一些疑惑：

  - **启动一个新的程序(进程process)需要运行什么步骤？**

    - 首先，通过调用 `fork()` 系统调用，创建一个新的进程，该进程是调用进程的一个副本，包括代码、数据和打开的文件描述符等。

    - 接下来，在新创建的子进程中，通过调用 `exec()` 系统调用来加载一个新的程序到子进程的内存空间，并执行这个程序。

      `exec()` 系统调用会替换子进程的内存映像为新加载的程序，但是保留了其他进程属性（如PID和打开的文件描述符）。

  - **那为什么要将exec()和fork()分开来，不能一个命令解决吗？**

    这得联系1.2的I/O来看。

    - fork干的事：当我们在主 shell 中执行一个命令时，Shell 会创建一个子进程来执行该命令。子进程继承了主 shell 的 I/O 设置。即
    - I/O重定向：在fork后exec前，父进程通过系统调用来改变子进程的文件描述符。这不会影响主 shell 的 I/O 设置，从而保持主 shell 的输入输出行为不变。
    - exec干的事：子进程的内存空间将会被新程序的代码和数据替换，但是文件描述符等其他信息会被保留下来，包括重定向后的文件描述符。
    - 所以分开写的好处有：
      1. 使得 shell 能够控制子进程的输入输出，执行各种形式的重定向，以及管道等操作，而不影响主 shell 的运行。
      2. 允许操作系统和应用程序在执行过程中插入更多的步骤。即不止做I/O重定向更可以做些额外检查之类的工作

    > Shell" 和 "终端"（terminal）是相关但不同的概念。
    >
    > Shell 是一个命令行解释器，它是用户与操作系统之间的接口。它接受用户输入的命令并将其解释为操作系统可以执行的指令。
    >
    > Terminal 是用户与计算机交互的设备或应用程序。它通常提供一个命令行界面，用户可以在其中输入命令并查看输出。
    >
    > 所以Shell 是执行命令的解释器，而终端是用户与 Shell 进行交互的界面。

  - **fork了程序如何判断当前是父进程还是子进程？**

    fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：

    1. 在父进程中，fork返回新创建子进程的进程ID；

    2. 在子进程中，fork返回0；

    3. 如果出现错误，fork返回一个负值；

       fork出错可能有两种原因：

       - 当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
       - 系统内存不足，这时errno的值被设置为ENOMEM。

    参考一个例子：

    ```c++
    /*fork前：此时仅有一个进程*/
    pid=fork();
    /*fork后：此时已经有两个进程在同时运行，两个进程的代码部分完全相同
      		 所以下面的代码2个进程都在同时进行。
    */
    if(pid<0)
    printf("error in fork!");
    else if(pid==0)		// 在子进程中，fork返回0；
    printf("I am the child process, my process ID is %d/n",getpid());
    else				// 在父进程中，fork返回新创建的子进程pid
    {
        wait(0);		// 保证先执行子进程，再执行父进程
        printf("I am the parent process, my process ID is %d/n",getpid());
    }
    
    /*
    最后输出结果为：
    I am the child process, my process ID is 1992
    I am the parent process, my process ID is 1991
    */
    ```


### 1.2 I/O and File descriptors

- 一些概念

  - **文件描述符(File Descriptor)**：是一个非负整数。用于唯一地标识一个内核管理的**已经打开的**文件/资源。

    > 文件描述符不是在创建文件时就分配的，而是在进程通过系统调用打开文件时才会被分配。
    >
    > 每个文件描述符都与一个特定的已打开文件关联，进程可以使用该文件描述符来执行读取、写入、关闭等操作。

    文件描述符会将文件(files)、管道(pipes)和设备(devices) 统一的抽象为字节流，使得在编程时可以更方便地处理它们

    > 文件：适用于长期存储和随机访问数据
    >
    > 管道：用于进程间通信
    >
    > 设备：用于与硬件设备进行交互。

    

  - **标准的文件描述符有3个：**
  
    > 描述符 **0**：标准输入（stdin），用于接收输入
    >
    > 描述符 **1**：标准输出（stdout），用于输出普通信息
    >
    > 描述符 **2**：标准错误（stderr），用于输出错误信息
  
    shell会将这三个文件描述符扩展到 **输入/输出重定向(I/O Redirection)** 和 **管道(Pipelines)**
  
    > **I/O Redirection**：是一种在执行命令时，将标准输入、标准输出和标准错误流定向到其他文件或设备的技术。例如，通过使用输入重定向，您可以从一个文件而不是标准输入读取数据。
    >
    > **Pipelines**：管道是一种将一个命令的输出作为另一个命令的输入的方式。通过使用管道，您可以将多个命令连接在一起，使其中一个命令的输出成为下一个命令的输入。
  
  - **偏移量offset**：
  
    - 当进程打开一个文件并获得一个文件描述符时，该文件描述符与文件中的一个特定位置（偏移量）相关联。
    - 偏移量表示了在文件中的一个位置，通常以字节为单位。刚开始时，偏移量可能是文件的开头（偏移量为0）。
    - 通过文件描述符的偏移量，`read` 操作能够从文件中的特定位置读取数据，并在读取后更新偏移量，使得下次读取操作从新位置开始。
    - 类似于`read`操作，`write` 操作从文件的当前偏移量开始写入数据，并将偏移量在写入后按写入的字节数进行移动。
  
- 一些疑惑

  - **如果一个进程同时打开了4个文件，这4个文件的文件描述符会是什么？**

    当一个进程打开了4个文件，操作系统会为每个打开的文件分配一个文件描述符。文件描述符通常是依次递增的整数值，从3开始分配，因为0、1、2 分别用于标准输入、标准输出和标准错误。

    假设进程按照以下顺序打开了4个文件：

    1. 第一个文件 → 文件描述符为 3
    2. 第二个文件 → 文件描述符为 4
    3. 第三个文件 → 文件描述符为 5
    4. 第四个文件 → 文件描述符为 6

  - **那这些文件的地址保存到哪里去了？**

    在操作系统中，文件描述符并不是直接保存文件的地址，而是用于标识打开的文件或资源的唯一标识符。

    文件的实际地址和数据是由内核管理的，不会直接保存在文件描述符中。文件描述符只是一个引用，它指向内核中相应的文件表项或其他相关数据结构。

  - **不同进程对同一个标准文件描述符的offset是共享的吗？**

    - 不同进程对同一个文件的文件描述符的 offset 是相互独立的

      也就是说进程1对文件A从第7个字节开始输入1个字节后，进程1的offset为8。而此时进程2对文件A的offset可能是第3个字节。

    - 但！！`fork()` 出来的父子进程会共享同一个文件的文件描述符和文件偏移量（offset）

      ```c++
      // 下面先子进程对文件描述符1输出hello,父进程再在子进程移动后的offset基础上对文件描述符1输出world。
      // 最终输出 hello world。
      if(fork() == 0){ 	// 子进程,fork返回0
          write(1, "hello ", 6); 
          exit(0); 
      }else{ 				// 主进程,fork返回所创建子进程的id
          wait(0); 
          write(1, "world\n", 6);
      }
      
      // dup()可以复制一个已经存在的文件描述符
      // 下面的代码输出也是 hello world
      fd = dup(1); 	// fd指向和1相同指向的I/O对象
      write(1, "hello ", 6); 
      write(fd, "world\n", 6);
      ```

      

### 1.3 Pipes

- 一些概念

  - **pipe**: 管道是一个内核中创建的小型缓冲区(buffer), 一对文件描述符(file descriptor)的形式暴露给进程，其中一个用于读取，另一个用于写入。

    管道给进程们提供了1个沟通的方式

### 1.4 File system

- 一些概念

  - **file system**: 有很多不同类比,比如

    - 数据文件（Data Files）:数据文件是一种存储数据的基本单位。它们包含未经解释的字节数组，这意味着文件系统不会对数据进行特定的解释或处理，而只是将字节数组存储在文件中。
    - 目录（Directories）:目录是一种特殊类型的文件，它包含了对其他数据文件和目录的命名引用。目录可以被看作是文件系统中的文件索引，它将文件名与实际数据文件或其他目录的关联建立起来。
      - 目录会构成一个树(tree), 从一个叫`root`的特殊目录开始,
      - 一个地址`path`: 如/home/Desktop, 就是**root目录**: / 下的Desktop目录

    - 设备(Device): 设备文件用于表示硬件设备，如磁盘驱动器、打印机等。通过访问设备文件，应用程序可以与硬件设备进行交互，实现输入输出操作。

  - **文件系统是如何组织和管理文件**

    - 每个文件有一个或多个文件名，文件名通过硬链接(links)与实际文件的索引节点(inode)关联，所以它们实际上引用了同一个文件
    - 每个文件在文件系统中都有一个唯一的inode，inode 包含文件的元数据(metadata)
    - 目录作用之一：维护文件名到inode的映射。目录中的每个条目都包括一个文件名和对应文件的inode引用。

    > **inode**（index node，索引节点）是文件系统中的一个重要概念，它是用来存储和管理文件的元数据和信息的数据结构。每个文件系统都会在其内部使用inode来追踪文件的属性和位置，从而支持文件的访问、管理和存储。
    >
    > **metadata元数据**：文件系统使用元数据来描述文件的属性，如文件类型、权限、时间戳、长度等。这些信息存储在inode中，使得文件系统可以在文件访问和管理时了解文件的特性。

### 1.5 Real world

- 现代的unix 系统都遵守**POSIX（Portable Operating System Interface，可移植操作系统接口）**标准

  > POSIX：是一组操作系统接口标准，旨在促进不同操作系统之间的兼容性和可移植性。它的目标是使不同的操作系统在应用程序级别上具有一致的接口，以便开发人员可以在不同的系统上编写可移植的应用程序。

  xv6由于缺少很多系统调用(system calls)所以不符合posix

  