# Assembly language：

http://c.biancheng.net/asm/

## 概览

**汇编语言是二进制指令的文本形式**，与指令是一一对应的关系。只要还原成二进制，汇编语言就可以被 CPU 直接执行，所以它是最底层的低级语言。

## 历史

最早的时候，编写程序就是手写二进制指令，然后通过各种开关输入计算机，比如要做加法了，就按一下加法开关。后来，发明了纸带打孔机，通过在纸带上打孔，将二进制指令自动输入计算机。

为了解决二进制指令的可读性问题，工程师将那些指令写成了八进制。二进制转八进制是轻而易举的，但是八进制的可读性也不行。很自然地，最后还是用文字表达，加法指令写成 ADD。内存地址也不再直接引用，而是用标签表示。

这样的话，就多出一个步骤，要把这些文字指令翻译成二进制，这个步骤就称为 assembling，完成这个步骤的程序就叫做 assembler。

# CPU指令

一个例子：

C:

```c
int add_a_and_b(int a, int b) {
   return a + b;
}

int main() {
   return add_a_and_b(2, 3);
}
```

汇编：

```assembly
_add_a_and_b:
   push   %ebx
   mov    %eax, [%esp+8] 
   mov    %ebx, [%esp+12]
   add    %eax, %ebx 
   pop    %ebx 
   ret  

_main:
   push   3
   push   2
   call   _add_a_and_b 
   add    %esp, 8
   ret
```

根据约定，程序从`_main`标签开始执行，这时会在 Stack 上为`main`建立一个帧，并将 Stack 所指向的地址，写入 ESP 寄存器。后面如果有数据要写入`main`这个帧，就会写在 ESP 寄存器所保存的地址。

## push指令

-  用于将运算子放入 Stack，
- `push`指令其实有一个前置操作。它会先取出 ESP 寄存器里面的地址，将其减去4个字节，然后将新地址写入 ESP 寄存器。使用减法是因为 Stack 从高位向低位发展，4个字节则是因为`3`的类型是`int`，占用4个字节。

`push 3`:

将`3`写入`main`这个帧

`push %ebx`

将 EBX 寄存器里面的值，写入`_add_a_and_b`这个帧。这是因为后面要用到这个寄存器，就先把里面的值取出来，用完后再写回去。这时，`push`指令会再将 ESP 寄存器里面的地址减去4个字节。

## call指令

- `call _add_a_and_b` 调用_add_a_and_b函数

## mov指令

- `mov`指令用于将一个值写入某个寄存器。

`mov %eax, [%esp+8]`

先将 ESP 寄存器里面的地址加上8个字节，得到一个新的地址，然后按照这个地址在 Stack 取出数据。根据前面的步骤，可以推算出这里取出的是`2`，再将`2`写入 EAX 寄存器。

`mov %ebx, [%esp+12]`

将 ESP 寄存器的值加12个字节，再按照这个地址在 Stack 取出数据，这次取出的是`3`，将其写入 EBX 寄存器。

## add指令

- 用于将两个运算子相加，并将结果写入第一个运算子。

`add %eax,%ebx`

将 EAX 寄存器的值（即2）加上 EBX 寄存器的值（即3），得到结果5，再将这个结果写入第一个运算子 EAX 寄存器。

`add %esp, 8`

将 ESP 寄存器里面的地址，手动加上8个字节，再写回 ESP 寄存器。这是因为 ESP 寄存器的是 Stack 的写入开始地址，前面的`pop`操作已经回收了4个字节，这里再回收8个字节，等于全部回收。

## pop指令

- 用于取出 Stack 最近一个写入的值（即最低位地址的值），并将这个值写入运算子指定的位置。
- `pop`指令还会将 ESP 寄存器里面的地址加4，即回收4个字节

`pop %ebx`

取出 Stack 最近写入的值（即 EBX 寄存器的原始值），再将这个值写回 EBX 寄存器

## ret指令

- `ret`指令用于终止当前函数的执行，将运行权交还给上层函数。也就是，当前函数的帧将被回收。

`ret`

该指令没有运算子。

## jmp指令

- 无条件转移指令，可转到内存中任何程序段

`JMP 1000H`

段内直接转移，转移地址的偏移量由指令给出

`JMP CX`

段内间接转移，转移地址的偏移量由CX指出。

`JMP 1000H:2000H`

段间直接转移，段码和偏移量由指令给出

`JMP DWORD PTR [SI]`

段间间接转移转移地址在SI所指地址开始的4个单元中

## shl指令

- 逻辑左移指令，将目的操作数顺序左移1位或CL寄存器中指定的位数。左移一位时，操作数的最高位移入进位标志位CF，最低位补零。

## shr指令

- 逻辑右移；右移，最高位补0，最低位进入CF。

## push指令

- 首先减少 ESP 的值，再将源操作数复制到堆栈。操作数是 16 位的，则 ESP 减 2，操作数是 32 位的，则 ESP 减 4。PUSH 指令有 3 种格式：

`PUSH reg/mem16`

`PUSH reg/mem32`

`PUSH inm32`

## pop指令

- 首先把 ESP 指向的堆栈元素内容复制到一个 16 位或 32 位目的操作数中，再增加 ESP 的值。如果操作数是 16 位的，ESP 加 2，如果操作数是 32 位的，ESP 加 4：

`POP reg/mem16`
`POP reg/mem32`

## inc指令

- 加1指令只有1个操作数，它将指定的操作数的内容加1；

## dec指令

- 减1指令

## sub指令

- 减法运算,对比于add

`sub ax,bx`

等同于C语言的： ax = ax - bx;

## cmp指令

- 执行从目的操作数中减去源操作数的隐含减法操作，并且不修改任何操作数

`CMP destination,source`
