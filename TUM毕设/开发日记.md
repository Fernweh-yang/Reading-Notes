# TimeLine

- [x] 框架
  - [x] config文件的创建和读取
  - [x] 读取照片
    - [x] 找到两个数据集中相同的照片
    - [x] 根据照片名字得到car pose和camera pose
    - [x] 设置内参矩阵
    - [x] 按顺序读取某一个record的照片
    - [x] 返回函数：返回一个字典(包含camera pose, 是否有car pose，id, rgb图, 深度图等信息)
  - [x] 创建多个线程
- [ ] 优化线程
  - [x] theseus图优化数据结构
  - [ ] theseus图优化计算函数 

# 环境配置

```shell
# 基本环境
pip install cython # 安装apollo数据集自带的库需要用到(在car_instance文件夹中安装)
# 安装apollo数据集的c++库需要sudo,如果和当前conda环境不一致需要用如下命令安装
sudo -E env "PATH=$PATH" bash install.sh
conda install pytorch torchvision torchaudio pytorch-cuda=11.8 -c pytorch -c nvidia
pip install numpy scipy matplotlib 
pip install opencv-python

# 安装theseus
## 安装前置库Dispenso,OpenBLAS,BaSpaCho
## 都只用sudo make install安装即可
## 从git官网下载最新版本theseus
git clone https://github.com/facebookresearch/theseus.git && cd theseus
BASPACHO_ROOT_DIR=/home/yang/3rdLibrary/baspacho pip install -e .
```



# 运行

```
python slam_system.py --config ./configs/apollo.yaml
```

# Debug

- 创建launch.json

  ```json
  {
      // Use IntelliSense to learn about possible attributes.
      // Hover to view descriptions of existing attributes.
      // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
      "version": "0.2.0",
      "configurations": [
          {
              "name": "Python: Current File",
              "type": "python",
              "request": "launch",
              "program": "${file}",
              "console": "integratedTerminal",
              "justMyCode": true,
              "args": [
                  "--config","./configs/apollo.yaml"
              ]
          }
      ]
  }
  ```

- 对主文件slam_system.py进行debug



# 3rdLib

## NerfStudio

### 1. 安装

参照[git官网](https://github.com/nerfstudio-project/nerfstudio/)来安装：

1. 在conda环境中安装python>=3.8和cuda11.8

2. 安装tiny-cuda-nn

   ```shell
   conda install -c "nvidia/label/cuda-11.8.0" cuda-toolkit
   pip install ninja git+https://github.com/NVlabs/tiny-cuda-nn/#subdirectory=bindings/torch
   ```

3. 下载安装nerfstudio

   ```shell
   git clone https://github.com/nerfstudio-project/nerfstudio.git
   cd nerfstudio
   pip install --upgrade pip setuptools
   pip install -e .
   ```

### 2. 运行

```
# Download some test data:
ns-download-data nerfstudio --capture-name=poster
# Train model
ns-train nerfacto --data data/nerfstudio/poster
```



## jaxtyping

在nerfstudio中有用到这个库。

根据[git官网](https://github.com/google/jaxtyping)介绍：是一个用于给[jax](https://jax.readthedocs.io/en/latest/index.html)数组类型, pytorch, numpy和 tensorflow做 **标注(annotate**) 和 **运行时类型检测(runtime type-checking** ) 的工具

> Just After eXceution（**JAX**）是CPU、GPU和TPU上的NumPy。它是一个用于高性能数值计算的Python库，特别是机器学习研究。

[文档](https://docs.kidger.site/jaxtyping/)

- 安装：

  ```
  pip install jaxtyping
  ```

- 例子：

  ```python
  # 在函数定义时写好，相当于在为数据类型做标注annotate
  from jaxtyping import Array, Float, PyTree, jaxtyped
  
  # 加了装饰器后，当调用下面函数时，会自动检查数据类型是否一致runtime type-checking
  # Use your favourite typechecker: usually one of the two lines below.
  from typeguard import typechecked as typechecker
  from beartype import beartype as typechecker
  
  
  # 例子1： 创建一个dtype=float类型的数组array，数组形状shape=dim1 x dim2
  # Accepts floating-point 2D arrays with matching axes
  # 形状可以是固定的数字如"28 28"，也可以是像这里的变量
  @jaxtyped(typechecker=typechecker)
  def matrix_multiply(x: Float[Array, "dim1 dim2"],
                      y: Float[Array, "dim2 dim3"]
                    ) -> Float[Array, "dim1 dim3"]:
      ...
  
  # 例子2： 为NumPy, TensorFlow, and PyTorch做类型检测：
  Float[np.ndarray, "..."]
  Float[tf.Tensor, "..."]
  Float[torch.Tensor, "..."]
      
      
  # 例子3： 创建一个PyTree类型的变量，int表示这个树的叶子数据类型
  def accepts_pytree_of_ints(x: PyTree[int]):
      ...
  
  def accepts_pytree_of_arrays(x: PyTree[Float[Array, "batch c1 c2"]]):
      ...
  ```

  

## toml

`.toml` 文件是一种配置文件格式，其名称来源于 "Tom's Obvious Minimal Language"，是一种易于阅读和编写的数据序列化语言。

Toml 旨在成为配置文件的一种简洁而直观的格式，它采用了键值对的结构，并支持嵌套、数组和其他复杂数据结构。

例子：

```python
import toml

# 例1：读取 Toml 文件
with open('your_file.toml', 'r') as file:
    data = toml.load(file)
print(data)

# 例2： 将字典写入Toml文件
data = {'key1': 'value1', 'key2': {'nested_key': 'nested_value'}}
with open('output_file.toml', 'w') as file:
    toml.dump(data, file)
```

